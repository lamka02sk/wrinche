/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 99);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Closer = __webpack_require__(100);

var _Closer2 = _interopRequireDefault(_Closer);

var _jquery = __webpack_require__(4);

var _jquery2 = _interopRequireDefault(_jquery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var baseURI = '?route=';
var route = document.querySelector('meta[name=route]').getAttribute('content');

exports.default = {

    body: document.body,
    html: document.body.parentNode,
    $html: (0, _jquery2.default)('html'),
    nav: document.querySelector('nav'),
    anchorBox: (0, _jquery2.default)('div.anchor-hover'),

    baseURI: baseURI,
    route: route,
    URI: baseURI + route + '/',

    routePrefix: null,
    routeAction: null,

    translate: null,
    closer: new _Closer2.default(),
    router: null,
    packery: null,
    componentsModule: null,
    MediaManager: null,
    managerActiveInstance: null,
    Selector: null

};

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _jquery = __webpack_require__(4);

var _jquery2 = _interopRequireDefault(_jquery);

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var confirmationElement = (0, _jquery2.default)('div.confirmation-menu');

exports.default = {
    pad: function pad(number, positions) {

        number = '' + number;
        return number.length < positions ? this.pad("0" + number, positions) : number;
    },
    validateUrl: function validateUrl(url) {

        return (/[(http(s)?):\/\/(www.)?a-zA-Z0-9@:%._+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_+.~#?&//=]*)/.test(url)
        );
    },
    validateTags: function validateTags(tags) {

        if ((typeof tags === 'undefined' ? 'undefined' : _typeof(tags)) === 'object') if (tags.length === 0) return true;

        return (/^[a-zA-Z]([a-zA-Z0-9_\s,]+)?[a-zA-Z0-9]$/.test(tags) && tags !== ''
        );
    },
    triggerEvent: function triggerEvent(element, event) {

        element.dispatchEvent(new MouseEvent(event, {
            view: window,
            cancelable: true,
            bubbles: true
        }));
    },
    registerEvent: function registerEvent(event) {

        // [events, elements, function] || { event, elements, content() }

        event = Object.values(event);
        var eventsList = event[0].split(' ');

        eventsList.forEach(function (eventName) {
            if (!event[1].length) event[1].addEventListener(eventName, event[2]);else event[1].forEach(function (element) {
                element.addEventListener(eventName, event[2]);
            });
        });
    },
    registerEvents: function registerEvents(events) {

        events.forEach(this.registerEvent);
    },
    capitalizeFirst: function capitalizeFirst(string) {

        string = string.toString();
        return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
    },
    showValidationResults: function showValidationResults(element, locale, hide, callback) {

        callback = callback || function () {};
        var messageBox = element.parentNode.querySelector('.validate-message');

        if (hide === true) {

            if (messageBox.innerText === '') return true;

            messageBox.innerText = '';
            messageBox.removeAttribute('data-locale');

            callback();
            return true;
        }

        if (messageBox.getAttribute('data-locale') === locale) {

            callback();
            return true;
        }

        messageBox.setAttribute('data-locale', locale);
        var loopBreak = false;

        for (var i in _Global2.default.translate.locale) {

            for (var j in _Global2.default.translate.locale[i]) {

                if (j === locale) {

                    messageBox.innerText = _Global2.default.translate.locale[i][j];
                    loopBreak = true;

                    break;
                }
            }

            if (loopBreak) break;
        }

        callback();
    },


    _confirmationElement: confirmationElement,
    _confirmationMessage: confirmationElement.find('.confirmation-action-message')[0],
    _confirmationProceed: confirmationElement.find('.confirmation-action-proceed'),
    _confirmationDismiss: confirmationElement.find('.confirmation-action-dismiss'),

    confirmAction: function confirmAction(action, callback) {

        callback = callback || function () {};
        this._confirmationElement.css({ display: 'table' }).animate({ opacity: 1 }, 150).addClass('open');
        this._confirmationMessage.innerHTML = action;

        var current = this;

        function clearEvents() {

            current._confirmationProceed.off('click');
            current._confirmationDismiss.off('click');
        }

        function hidePopup() {

            current._confirmationElement.animate({ opacity: 0 }, 150).removeClass('open').delay(100).queue(function () {
                (0, _jquery2.default)(this).css({ display: 'none' }).dequeue();
            });
        }

        // Proceed
        this._confirmationProceed.click(function () {

            callback();
            clearEvents();
            hidePopup();
        });

        // Dismiss
        this._confirmationDismiss.click(function () {

            clearEvents();
            hidePopup();
        });
    },


    _loadingBox: document.querySelector('.loading-box'),
    _responseBox: document.querySelector('.response-box'),

    showLoading: function showLoading() {
        var translate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;


        this._loadingBox.classList.add('open');

        if (translate) this._loadingBox.querySelector('span.message-content').innerHTML = _Global2.default.translate['locale']['admin_header']['HEADER_LOADING'];
    },
    hideLoading: function hideLoading() {
        var _this = this;

        setTimeout(function () {

            _this._loadingBox.classList.remove('open');
            _this._loadingBox.querySelector('span.message-content').innerHTML = '';
        }, 400);
    },
    hideSplash: function hideSplash() {
        document.querySelector('.splash').classList.add('done');
    },
    closeMediaManager: function closeMediaManager() {

        var closeElement = document.querySelector('div.media-manager span.close-manager');
        closeElement.click();
    }
};

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _jquery = __webpack_require__(4);

var _jquery2 = _interopRequireDefault(_jquery);

var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

var _Csrf = __webpack_require__(5);

var _Csrf2 = _interopRequireDefault(_Csrf);

var _Router = __webpack_require__(3);

var _Router2 = _interopRequireDefault(_Router);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
    post: function post(url, data, callback) {
        var async = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;


        _Utils2.default.showLoading();

        if (!data['csrf_token']) data['csrf_token'] = _Csrf2.default.getToken();

        _jquery2.default.ajax({
            url: url,
            method: 'POST',
            data: data,
            async: async,
            success: function success(response) {
                callback(response, 'success');
                _Utils2.default.hideLoading();
            },
            error: function error(response) {
                callback(response, 'error');
                _Utils2.default.hideLoading();
            }
        });
    },
    get: function get(url, _success, _error) {

        _Utils2.default.showLoading();
        var csrf_token = _Csrf2.default.getToken();

        _jquery2.default.ajax({
            url: url + '&csrf_token=' + csrf_token,
            method: 'GET',
            success: function success(response) {
                _success(response);
                _Utils2.default.hideLoading();
            },
            error: function error(response) {
                _error(response);
                _Utils2.default.hideLoading();
            }
        });
    },
    getFile: function getFile(url) {
        var translate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;


        _Utils2.default.showLoading(translate);

        return _jquery2.default.ajax({
            type: 'GET',
            url: url,
            global: false,
            async: false,
            cache: true,
            success: function success(data) {
                _Utils2.default.hideLoading();
                return data;
            },
            error: function error() {
                return _Utils2.default.hideLoading();
            }
        }).responseText;
    },
    getJSON: function getJSON(url) {
        var translate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;


        _Utils2.default.showLoading(translate);

        return JSON.parse(_jquery2.default.ajax({
            type: 'GET',
            url: url,
            dataType: 'json',
            global: false,
            async: false,
            cache: true,
            success: function success(data) {
                _Utils2.default.hideLoading();
                return data;
            },
            error: function error() {
                return _Utils2.default.hideLoading();
            }
        }).responseText);
    },
    api: function api(endpoint, method) {
        var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};


        if (method.toLowerCase() === 'post') return this.apiPost(endpoint, data);else return this.apiGet(endpoint);
    },
    apiGet: function apiGet(endpoint) {
        var _this = this;

        var url = _Router2.default.createLink('api/' + endpoint);
        return new Promise(function (resolve) {
            _this.get(url, function (response) {
                resolve(response, 'success');
            }, function (error) {
                resolve(error, 'error');
            });
        });
    },
    apiPost: function apiPost(endpoint, data) {
        var _this2 = this;

        data = { api: data };
        var url = _Router2.default.createLink('api/' + endpoint);

        return new Promise(function (resolve) {
            _this2.post(url, data, function (response, status) {
                resolve(response, status);
            });
        });
    }
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

var _History = __webpack_require__(101);

var _History2 = _interopRequireDefault(_History);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var routes = __webpack_require__(102);

var Router = function () {
    function Router() {
        _classCallCheck(this, Router);

        this.route = _Global2.default.route;
        this.parseLocation();
        this.views = {};

        _History2.default.initialize(this);
        this.findRoute();
    }

    _createClass(Router, [{
        key: 'saveActions',
        value: function saveActions(action) {

            var actions = action.toString().split('/').filter(function (item) {
                if (item.trim() !== '') return item.trim();
            });

            if (actions.length < 1) actions.push('dashboard');

            _Global2.default.routeAction = actions;
        }
    }, {
        key: 'changeLocation',
        value: function changeLocation(link) {
            var push = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            var target = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;


            if (target === 'blank') {

                var url = Router.createLink(link);
                window.open(url, '_blank');

                return true;
            }

            this.saveActions(link);
            this.findRoute(push);
        }
    }, {
        key: 'parseLocation',
        value: function parseLocation() {

            var location = window.location.href;
            var locationParts = location.split(this.route);

            _Global2.default.routePrefix = locationParts[0];
            var action = locationParts[1];

            this.saveActions(action);
        }
    }, {
        key: 'findRoute',
        value: function findRoute() {
            var push = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;


            if (!routes[_Global2.default.routeAction[0]]) {
                this.changeLocation(404);
                return false;
            }

            if (push) _History2.default.push(_Global2.default.routeAction);

            this.executeRoute();
        }
    }, {
        key: 'executeRoute',
        value: function executeRoute() {

            var View = __webpack_require__(103)("./" + routes[_Global2.default.routeAction[0]] + '.js').default;
            View.initialize(this);
        }
    }], [{
        key: 'getHash',
        value: function getHash() {
            return window.location.hash;
        }
    }, {
        key: 'createLink',
        value: function createLink(action) {
            var route = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;


            route = route ? '/' + route : _Global2.default.route;
            return _Global2.default.routePrefix + route + '/' + action;
        }
    }]);

    return Router;
}();

exports.default = Router;
;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.2.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2017-03-20T18:59Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};



	function DOMEval( code, doc ) {
		doc = doc || document;

		var script = doc.createElement( "script" );

		script.text = code;
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.2.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && Array.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type( obj ) === "function";
	},

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {

		// As of jQuery 3.0, isNumeric is limited to
		// strings and numbers (primitives or objects)
		// that can be coerced to finite numbers (gh-2662)
		var type = jQuery.type( obj );
		return ( type === "number" || type === "string" ) &&

			// parseFloat NaNs numeric-cast false positives ("")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			!isNaN( obj - parseFloat( obj ) );
	},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {

		/* eslint-disable no-unused-vars */
		// See https://github.com/eslint/eslint/issues/6125
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}

		// Support: Android <=2.3 only (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call( obj ) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		DOMEval( code );
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE <=9 - 11, Edge 12 - 13
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	disabledAncestor = addCombinator(
		function( elem ) {
			return elem.disabled === true && ("form" in elem || "label" in elem);
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						disabledAncestor( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Simple selector that can be filtered directly, removing non-Elements
	if ( risSimple.test( qualifier ) ) {
		return jQuery.filter( qualifier, elements, not );
	}

	// Complex selector, compare the two sets, removing non-Elements
	qualifier = jQuery.filter( qualifier, elements );
	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;
	} );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
        if ( nodeName( elem, "iframe" ) ) {
            return elem.contentDocument;
        }

        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
        // Treat the template element as a regular one in browsers that
        // don't support it.
        if ( nodeName( elem, "template" ) ) {
            elem = elem.content || elem;
        }

        return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( jQuery.isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && jQuery.isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( jQuery.isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				jQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ jQuery.camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ jQuery.camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( jQuery.camelCase );
			} else {
				key = jQuery.camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			jQuery.contains( elem.ownerDocument, elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted,
		scale = 1,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		do {

			// If previous iteration zeroed out, double until we get *something*.
			// Use string for doubling so we don't accidentally see scale as unchanged below
			scale = scale || ".5";

			// Adjust and apply
			initialInUnit = initialInUnit / scale;
			jQuery.style( elem, prop, initialInUnit + unit );

		// Update scale, tolerating zero or NaN from tween.cur()
		// Break the loop if scale is unchanged or perfect, or if we've just had enough.
		} while (
			scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
		);
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

var rscriptType = ( /^$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( jQuery.type( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();
var documentElement = document.documentElement;



var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 only
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: jQuery.isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( ">tbody", elem )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		isFunction = jQuery.isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( isFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( isFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rmargin = ( /^margin/ );

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		div.style.cssText =
			"box-sizing:border-box;" +
			"position:relative;display:block;" +
			"margin:auto;border:1px;padding:1px;" +
			"top:1%;width:50%";
		div.innerHTML = "";
		documentElement.appendChild( container );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = divStyle.marginLeft === "2px";
		boxSizingReliableVal = divStyle.width === "4px";

		// Support: Android 4.0 - 4.3 only
		// Some styles come back with percentage values, even though they shouldn't
		div.style.marginRight = "50%";
		pixelMarginRightVal = divStyle.marginRight === "4px";

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
		"padding:0;margin-top:1px;position:absolute";
	container.appendChild( div );

	jQuery.extend( support, {
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelMarginRight: function() {
			computeStyleTests();
			return pixelMarginRightVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a property mapped along what jQuery.cssProps suggests or to
// a vendor prefixed property.
function finalPropName( name ) {
	var ret = jQuery.cssProps[ name ];
	if ( !ret ) {
		ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
	}
	return ret;
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i,
		val = 0;

	// If we already have the right measurement, avoid augmentation
	if ( extra === ( isBorderBox ? "border" : "content" ) ) {
		i = 4;

	// Otherwise initialize for horizontal or vertical properties
	} else {
		i = name === "width" ? 1 : 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {

			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {

			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with computed style
	var valueIsBorderBox,
		styles = getStyles( elem ),
		val = curCSS( elem, name, styles ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Computed unit is not pixels. Stop here and return.
	if ( rnumnonpx.test( val ) ) {
		return val;
	}

	// Check for style in case a browser which returns unreliable values
	// for getComputedStyle silently falls back to the reliable elem.style
	valueIsBorderBox = isBorderBox &&
		( support.boxSizingReliable() || val === elem.style[ name ] );

	// Fall back to offsetWidth/Height when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	if ( val === "auto" ) {
		val = elem[ "offset" + name[ 0 ].toUpperCase() + name.slice( 1 ) ];
	}

	// Normalize "", auto, and prepare for extra
	val = parseFloat( val ) || 0;

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, name, extra );
						} ) :
						getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = extra && getStyles( elem ),
				subtract = extra && augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				);

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ name ] = value;
				value = jQuery.css( elem, name );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 13
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( jQuery.isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					jQuery.proxy( result.stop, result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnothtmlwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnothtmlwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( type === "string" ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = value.match( rnothtmlwhite ) || [];

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




support.focusin = "onfocusin" in window;


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = jQuery.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = jQuery.isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( jQuery.isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 13
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( jQuery.isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var doc, docElem, rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		rect = elem.getBoundingClientRect();

		doc = elem.ownerDocument;
		docElem = doc.documentElement;
		win = doc.defaultView;

		return {
			top: rect.top + win.pageYOffset - docElem.clientTop,
			left: rect.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
		// because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {

			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset = {
				top: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),
				left: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )
			};
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( jQuery.isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
		return jQuery;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Ajax = __webpack_require__(2);

var _Ajax2 = _interopRequireDefault(_Ajax);

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var tokenElement = document.querySelector('meta[name=csrf_token]');

exports.default = {

    _tokenElement: tokenElement,
    _csrfToken: undefined,

    constructor: function constructor() {

        this._csrfToken = this._tokenElement.getAttribute('content');
        this.register();
    },
    register: function register() {
        var _this = this;

        setInterval(function () {

            _Ajax2.default.get(_Global2.default.baseURI + 'api/system.auth.refresh.token', function (response) {
                _this._csrfToken = response.data;
                _this._tokenElement.setAttribute('content', _this._csrfToken);
            }, function () {
                confirmAction(
                // TODO: translate.locale.response['ACTION_CONFIRM_RELOAD_PAGE'],
                '', function () {
                    return window.location.reload();
                });
            });
        }, 1200000);
    },
    getToken: function getToken() {

        return this._csrfToken;
    }
};

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Ajax = __webpack_require__(2);

var _Ajax2 = _interopRequireDefault(_Ajax);

var _Router = __webpack_require__(3);

var _Router2 = _interopRequireDefault(_Router);

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {

    viewHTML: null,
    LOCALES: [],

    createView: function createView() {
        var _this = this;

        var locales = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];


        // Clear previous events
        this.clearEvents();

        return new Promise(function (resolve) {

            _this.LOCALES = locales;
            _this.fetchViewHTML(resolve);
        });
    },
    clearEvents: function clearEvents() {

        var contentWrapper = document.querySelector('.content-wrapper');

        if (contentWrapper) contentWrapper.outerHTML = contentWrapper.outerHTML;
    },
    fetchViewHTML: function fetchViewHTML(resolve) {
        var _this2 = this;

        var url = _Router2.default.createLink(_Global2.default.routeAction.join('/'));

        _Ajax2.default.get(url, function (response) {
            _this2.viewHTML = response;
            _this2.replaceViewHTML(_this2);
            resolve();
        }, function (response) {
            // Handle error event
            resolve();
        });
    },
    replaceViewHTML: function replaceViewHTML(parent) {

        var contentWrapper = document.querySelector('.content-wrapper');

        contentWrapper ? parent.showView(contentWrapper) : parent.createContentWrapper(true);
    },
    createContentWrapper: function createContentWrapper() {
        var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;


        var contentWrapper = document.createElement('div');
        contentWrapper.classList.add('content-wrapper');

        _Global2.default.body.appendChild(contentWrapper);

        if (show) this.showView(contentWrapper);
    },
    showView: function showView(contentWrapper) {

        contentWrapper.innerHTML = this.viewHTML;
        this.translate();
    },
    translate: function translate() {

        _Global2.default.translate.translateLocales(this.LOCALES);
    }
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {

    Slee: null,

    prepare: function prepare() {

        this.Slee = __webpack_require__(107);

        // Setup Slee
        this.Slee.prepare({
            animation: 'ease'
        });
    },
    error: function error(title, description) {

        title = _Global2.default.translate.locale['response'][title];
        description = _Global2.default.translate.locale['response'][description];

        this.Slee.error({
            title: title,
            description: description,
            picture: 'assets/icons/close_white.svg'
        });
    },
    success: function success(title, description) {

        title = _Global2.default.translate.locale['response'][title];
        description = _Global2.default.translate.locale['response'][description];

        this.Slee.success({
            title: title,
            description: description,
            picture: 'assets/icons/success_black.svg'
        });
    },
    info: function info() {}
};

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Main = __webpack_require__(6);

var _Main2 = _interopRequireDefault(_Main);

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

var _Ajax = __webpack_require__(2);

var _Ajax2 = _interopRequireDefault(_Ajax);

var _Router = __webpack_require__(3);

var _Router2 = _interopRequireDefault(_Router);

var _Slee = __webpack_require__(7);

var _Slee2 = _interopRequireDefault(_Slee);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {

    LOCALES: ['system', 'response', 'admin_settings'],
    components: [],

    initialize: function initialize() {

        // Render content
        _Main2.default.createView(this.LOCALES).then(function () {

            // Switch view
            var View = __webpack_require__(108)("./" + _Utils2.default.capitalizeFirst(_Global2.default.routeAction[1] || 'appearance'));
            View.initialize();
        });
    },
    postSettings: function postSettings(data) {

        function execute(resolve) {

            _Ajax2.default.post(_Router2.default.createLink('settings/' + (_Global2.default.routeAction[1] || 'appearance')), data, function (response, status) {

                try {

                    response = JSON.parse(response);

                    if (status !== 'success') {
                        _Slee2.default.error('ERROR', 0);
                        resolve();
                    } else if (response.code !== 200) {
                        _Slee2.default.error('ERROR', response.code);
                        resolve();
                    } else {
                        _Slee2.default.success('SUCCESS', 'SETTINGS_SAVED');
                        resolve(response);
                    }
                } catch (e) {
                    _Slee2.default.error('ERROR', 0);
                    resolve();
                }
            });
        }

        return new Promise(execute);
    }
};

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

var _Settings = __webpack_require__(8);

var _Settings2 = _interopRequireDefault(_Settings);

var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

var _jquery = __webpack_require__(4);

var _jquery2 = _interopRequireDefault(_jquery);

var _Router = __webpack_require__(3);

var _Router2 = _interopRequireDefault(_Router);

var _Csrf = __webpack_require__(5);

var _Csrf2 = _interopRequireDefault(_Csrf);

var _Slee = __webpack_require__(7);

var _Slee2 = _interopRequireDefault(_Slee);

var _lodash = __webpack_require__(109);

var _lodash2 = _interopRequireDefault(_lodash);

var _Ajax = __webpack_require__(2);

var _Ajax2 = _interopRequireDefault(_Ajax);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var account = {
    initialize: function initialize() {

        // Translate current route
        _Global2.default.translate.addTranslation('admin_settings/account');

        // Initialize Selector
        this.initializeSelector();

        // Register events
        this.createEvents();
    },
    initializeSelector: function initializeSelector() {
        var destroy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;


        if (destroy) this.selector.destroy();

        this.selector = new _Global2.default.Selector({
            element: '.content-subcontent select',
            selected: this.changeSettings
        });
    },
    changeSettings: function changeSettings(instance, option) {

        var reference = instance.dataset.reference;

        var data = {};
        data[reference] = option;

        _Settings2.default.postSettings(data);
    },
    createEvents: function createEvents() {

        // Profile box events
        this.createProfileBoxEvents();
    },
    createProfileBoxEvents: function createProfileBoxEvents() {

        this.subcontent = document.querySelector('.content-subcontent');
        var profileBox = this.subcontent.querySelector('.profile-box');
        var pictureBox = profileBox.querySelector('.profile-picture-wrapper');

        // Change profile picture
        this.changeProfilePicture(pictureBox);

        // Change username and e-mail
        this.changeProfileBoxValues(profileBox);

        // Change other inputs and textarea
        this.changeOtherInputs();

        // Edit sessions
        this.sessionsEditor();
    },
    changeProfilePicture: function changeProfilePicture(element) {

        _Utils2.default.registerEvent(['click', element.querySelector('.profile-picture-edit'), function () {

            var input = document.createElement('input');
            input.type = 'file';
            input.accept = "image/*";

            _Utils2.default.registerEvent(['input', input, function () {

                var file = new FormData();
                file.append('picture', input.files[0]);

                _jquery2.default.ajax({
                    method: "POST",
                    url: _Router2.default.createLink('settings/account&csrf_token=' + _Csrf2.default.getToken()),
                    data: file,
                    cache: false,
                    processData: false,
                    contentType: false,
                    success: function success(response) {

                        try {

                            response = JSON.parse(response);

                            if (response.picture) {
                                element.querySelector('img').src = response.picture;
                                document.querySelector('.header-account .write-icon_circle').style.backgroundImage = 'url(' + response.picture + ')';
                                _Slee2.default.success('SUCCESS', 'SETTINGS_SAVED');
                            } else _Slee2.default.error('ERROR', response.code);
                        } catch (e) {
                            _Slee2.default.error('ERROR', 0);
                        }
                    }
                });
            }]);

            input.click();
        }]);
    },
    blurEvent: function blurEvent() {

        var input = document.querySelector('.profile-box [contenteditable]');

        input.removeAttribute('contenteditable');
        input.parentNode.querySelector('.edit-value').classList.remove('hide');

        // Save data
        var value = input.innerText.trim();
        var data = {};

        data[input.dataset.edit] = value;
        _Settings2.default.postSettings(data).then(function (results) {

            if (!results) input.innerText = input.dataset.reset;
        });
    },
    closeProfileBoxEditor: function closeProfileBoxEditor(target) {

        target.blur();
        target.removeEventListener('blur', this.blurEvent);
    },
    changeProfileBoxValues: function changeProfileBoxValues(profileBox) {
        var _this = this;

        _Utils2.default.registerEvents([['click', profileBox, function (event) {

            var target = event.target;

            // Edit
            if (target.matches('.edit-value')) {

                var input = target.parentNode.querySelector('[data-edit]');

                target.classList.add('hide');
                input.setAttribute('contenteditable', '');
                input.focus();

                // Register blur event
                input.addEventListener('blur', _this.blurEvent);
            }
        }], ['keyup keypress', profileBox, function (event) {

            var target = event.target;

            // Edit
            if (target.matches('[data-edit]')) {

                if (event.type === 'keypress' && event.keyCode === 13) {
                    event.preventDefault();
                    return false;
                }

                if (event.type === 'keyup' && event.keyCode === 13) _this.closeProfileBoxEditor(target);
            }
        }]]);
    },
    changeOtherInputs: function changeOtherInputs() {

        function onInput(event) {

            var target = event.target;
            var identifier = target.name;
            var value = target.value.trim();

            var data = {};
            data[identifier] = value;

            _Settings2.default.postSettings(data);
        }

        var inputs = this.subcontent.querySelectorAll('input:not([type=checkbox]), textarea');

        _Utils2.default.registerEvent(['input blur', inputs, (0, _lodash2.default)(onInput, 750)]);
    },
    getSelectedSessions: function getSelectedSessions(rows) {

        var data = [];

        rows.forEach(function (row) {
            if (!!row.checked) data.push(row.parentNode.parentNode.dataset.id);
        });

        return data;
    },
    sessionsEditor: function sessionsEditor() {
        var _this2 = this;

        var rows = this.subcontent.querySelectorAll('.select-row input');
        var selectAll = this.subcontent.querySelector('.select-all input');
        var sessionsActions = this.subcontent.querySelector('.sessions-actions');

        _Utils2.default.registerEvents([['change', selectAll, function () {

            var status = selectAll.checked;

            rows.forEach(function (row) {
                row.checked = status;
            });

            if (status) sessionsActions.classList.add('active');else sessionsActions.classList.remove('active');
        }], ['change', rows, function (event) {

            var status = !!event.target.checked;

            if (!status) selectAll.checked = false;

            if (status) sessionsActions.classList.add('active');else if (!Array.from(rows).some(function (row) {
                return !!row.checked;
            })) sessionsActions.classList.remove('active');
        }], ['click', this.subcontent.querySelector('.sessions-actions'), function (event) {

            var target = event.target;

            // Logout
            if (target.matches('.selected-logout')) {

                var selectedSessions = _this2.getSelectedSessions(rows);
                _Ajax2.default.api('system.auth.logout', 'post', selectedSessions);

                selectedSessions.forEach(function (session) {
                    var row = _this2.subcontent.querySelector('[data-id="' + session + '"]');
                    row.parentNode.removeChild(row);
                });
            }

            // Refresh
            else if (target.matches('.selected-refresh')) _Ajax2.default.api('system.auth.refresh.login', 'post', _this2.getSelectedSessions(rows));
        }]]);
    }
};

module.exports = account;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

var _Settings = __webpack_require__(8);

var _Settings2 = _interopRequireDefault(_Settings);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var appearance = {

    selector: null,

    initialize: function initialize() {

        // Translate current route
        _Global2.default.translate.addTranslation('admin_settings/appearance');

        // Initialize Selectors
        this.initializeSelector();

        // Save all
        _Utils2.default.registerEvent(['click', document.querySelector('.save-button'), this.saveAllSettings]);
    },
    initializeSelector: function initializeSelector() {
        var destroy = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;


        if (destroy) this.selector.destroy();

        this.selector = new _Global2.default.Selector({
            element: '.content-subcontent select',
            selected: this.changeSettings
        });
    },
    changeSettings: function changeSettings(instance, option) {

        var reference = instance.dataset.reference;

        var data = {};
        data[reference] = option;

        _Settings2.default.postSettings(data);

        if (reference === 'language') {
            _Global2.default.translate.switchLanguage(option);
            appearance.initializeSelector(true);
        }
    },
    saveAllSettings: function saveAllSettings() {

        var selectors = document.querySelectorAll('.content-subcontent .selector-element');
        var data = {};

        selectors.forEach(function (selector) {
            return data[selector.dataset.reference] = selector.querySelector('.selector-selected').dataset.item;
        });

        _Settings2.default.postSettings(data);
    }
};

module.exports = appearance;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**!
 * Sortable
 * @author	RubaXa   <trash@rubaxa.org>
 * @license MIT
 */

(function sortableModule(factory) {
	"use strict";

	if (true) {
		!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	else if (typeof module != "undefined" && typeof module.exports != "undefined") {
		module.exports = factory();
	}
	else {
		/* jshint sub:true */
		window["Sortable"] = factory();
	}
})(function sortableFactory() {
	"use strict";

	if (typeof window == "undefined" || !window.document) {
		return function sortableError() {
			throw new Error("Sortable.js requires a window with a document");
		};
	}

	var dragEl,
		parentEl,
		ghostEl,
		cloneEl,
		rootEl,
		nextEl,
		lastDownEl,

		scrollEl,
		scrollParentEl,
		scrollCustomFn,

		lastEl,
		lastCSS,
		lastParentCSS,

		oldIndex,
		newIndex,

		activeGroup,
		putSortable,

		autoScroll = {},

		tapEvt,
		touchEvt,

		moved,

		/** @const */
		R_SPACE = /\s+/g,
		R_FLOAT = /left|right|inline/,

		expando = 'Sortable' + (new Date).getTime(),

		win = window,
		document = win.document,
		parseInt = win.parseInt,

		$ = win.jQuery || win.Zepto,
		Polymer = win.Polymer,

		captureMode = false,

		supportDraggable = !!('draggable' in document.createElement('div')),
		supportCssPointerEvents = (function (el) {
			// false when IE11
			if (!!navigator.userAgent.match(/Trident.*rv[ :]?11\./)) {
				return false;
			}
			el = document.createElement('x');
			el.style.cssText = 'pointer-events:auto';
			return el.style.pointerEvents === 'auto';
		})(),

		_silent = false,

		abs = Math.abs,
		min = Math.min,

		savedInputChecked = [],
		touchDragOverListeners = [],

		_autoScroll = _throttle(function (/**Event*/evt, /**Object*/options, /**HTMLElement*/rootEl) {
			// Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
			if (rootEl && options.scroll) {
				var _this = rootEl[expando],
					el,
					rect,
					sens = options.scrollSensitivity,
					speed = options.scrollSpeed,

					x = evt.clientX,
					y = evt.clientY,

					winWidth = window.innerWidth,
					winHeight = window.innerHeight,

					vx,
					vy,

					scrollOffsetX,
					scrollOffsetY
				;

				// Delect scrollEl
				if (scrollParentEl !== rootEl) {
					scrollEl = options.scroll;
					scrollParentEl = rootEl;
					scrollCustomFn = options.scrollFn;

					if (scrollEl === true) {
						scrollEl = rootEl;

						do {
							if ((scrollEl.offsetWidth < scrollEl.scrollWidth) ||
								(scrollEl.offsetHeight < scrollEl.scrollHeight)
							) {
								break;
							}
							/* jshint boss:true */
						} while (scrollEl = scrollEl.parentNode);
					}
				}

				if (scrollEl) {
					el = scrollEl;
					rect = scrollEl.getBoundingClientRect();
					vx = (abs(rect.right - x) <= sens) - (abs(rect.left - x) <= sens);
					vy = (abs(rect.bottom - y) <= sens) - (abs(rect.top - y) <= sens);
				}


				if (!(vx || vy)) {
					vx = (winWidth - x <= sens) - (x <= sens);
					vy = (winHeight - y <= sens) - (y <= sens);

					/* jshint expr:true */
					(vx || vy) && (el = win);
				}


				if (autoScroll.vx !== vx || autoScroll.vy !== vy || autoScroll.el !== el) {
					autoScroll.el = el;
					autoScroll.vx = vx;
					autoScroll.vy = vy;

					clearInterval(autoScroll.pid);

					if (el) {
						autoScroll.pid = setInterval(function () {
							scrollOffsetY = vy ? vy * speed : 0;
							scrollOffsetX = vx ? vx * speed : 0;

							if ('function' === typeof(scrollCustomFn)) {
								return scrollCustomFn.call(_this, scrollOffsetX, scrollOffsetY, evt);
							}

							if (el === win) {
								win.scrollTo(win.pageXOffset + scrollOffsetX, win.pageYOffset + scrollOffsetY);
							} else {
								el.scrollTop += scrollOffsetY;
								el.scrollLeft += scrollOffsetX;
							}
						}, 24);
					}
				}
			}
		}, 30),

		_prepareGroup = function (options) {
			function toFn(value, pull) {
				if (value === void 0 || value === true) {
					value = group.name;
				}

				if (typeof value === 'function') {
					return value;
				} else {
					return function (to, from) {
						var fromGroup = from.options.group.name;

						return pull
							? value
							: value && (value.join
								? value.indexOf(fromGroup) > -1
								: (fromGroup == value)
							);
					};
				}
			}

			var group = {};
			var originalGroup = options.group;

			if (!originalGroup || typeof originalGroup != 'object') {
				originalGroup = {name: originalGroup};
			}

			group.name = originalGroup.name;
			group.checkPull = toFn(originalGroup.pull, true);
			group.checkPut = toFn(originalGroup.put);
			group.revertClone = originalGroup.revertClone;

			options.group = group;
		}
	;


	/**
	 * @class  Sortable
	 * @param  {HTMLElement}  el
	 * @param  {Object}       [options]
	 */
	function Sortable(el, options) {
		if (!(el && el.nodeType && el.nodeType === 1)) {
			throw 'Sortable: `el` must be HTMLElement, and not ' + {}.toString.call(el);
		}

		this.el = el; // root element
		this.options = options = _extend({}, options);


		// Export instance
		el[expando] = this;

		// Default options
		var defaults = {
			group: Math.random(),
			sort: true,
			disabled: false,
			store: null,
			handle: null,
			scroll: true,
			scrollSensitivity: 30,
			scrollSpeed: 10,
			draggable: /[uo]l/i.test(el.nodeName) ? 'li' : '>*',
			ghostClass: 'sortable-ghost',
			chosenClass: 'sortable-chosen',
			dragClass: 'sortable-drag',
			ignore: 'a, img',
			filter: null,
			preventOnFilter: true,
			animation: 0,
			setData: function (dataTransfer, dragEl) {
				dataTransfer.setData('Text', dragEl.textContent);
			},
			dropBubble: false,
			dragoverBubble: false,
			dataIdAttr: 'data-id',
			delay: 0,
			forceFallback: false,
			fallbackClass: 'sortable-fallback',
			fallbackOnBody: false,
			fallbackTolerance: 0,
			fallbackOffset: {x: 0, y: 0}
		};


		// Set default options
		for (var name in defaults) {
			!(name in options) && (options[name] = defaults[name]);
		}

		_prepareGroup(options);

		// Bind all private methods
		for (var fn in this) {
			if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
				this[fn] = this[fn].bind(this);
			}
		}

		// Setup drag mode
		this.nativeDraggable = options.forceFallback ? false : supportDraggable;

		// Bind events
		_on(el, 'mousedown', this._onTapStart);
		_on(el, 'touchstart', this._onTapStart);
		_on(el, 'pointerdown', this._onTapStart);

		if (this.nativeDraggable) {
			_on(el, 'dragover', this);
			_on(el, 'dragenter', this);
		}

		touchDragOverListeners.push(this._onDragOver);

		// Restore sorting
		options.store && this.sort(options.store.get(this));
	}


	Sortable.prototype = /** @lends Sortable.prototype */ {
		constructor: Sortable,

		_onTapStart: function (/** Event|TouchEvent */evt) {
			var _this = this,
				el = this.el,
				options = this.options,
				preventOnFilter = options.preventOnFilter,
				type = evt.type,
				touch = evt.touches && evt.touches[0],
				target = (touch || evt).target,
				originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0]) || target,
				filter = options.filter,
				startIndex;

			_saveInputCheckedState(el);


			// Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.
			if (dragEl) {
				return;
			}

			if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
				return; // only left button or enabled
			}


			target = _closest(target, options.draggable, el);

			if (!target) {
				return;
			}

			if (lastDownEl === target) {
				// Ignoring duplicate `down`
				return;
			}

			// Get the index of the dragged element within its parent
			startIndex = _index(target, options.draggable);

			// Check filter
			if (typeof filter === 'function') {
				if (filter.call(this, evt, target, this)) {
					_dispatchEvent(_this, originalTarget, 'filter', target, el, startIndex);
					preventOnFilter && evt.preventDefault();
					return; // cancel dnd
				}
			}
			else if (filter) {
				filter = filter.split(',').some(function (criteria) {
					criteria = _closest(originalTarget, criteria.trim(), el);

					if (criteria) {
						_dispatchEvent(_this, criteria, 'filter', target, el, startIndex);
						return true;
					}
				});

				if (filter) {
					preventOnFilter && evt.preventDefault();
					return; // cancel dnd
				}
			}

			if (options.handle && !_closest(originalTarget, options.handle, el)) {
				return;
			}

			// Prepare `dragstart`
			this._prepareDragStart(evt, touch, target, startIndex);
		},

		_prepareDragStart: function (/** Event */evt, /** Touch */touch, /** HTMLElement */target, /** Number */startIndex) {
			var _this = this,
				el = _this.el,
				options = _this.options,
				ownerDocument = el.ownerDocument,
				dragStartFn;

			if (target && !dragEl && (target.parentNode === el)) {
				tapEvt = evt;

				rootEl = el;
				dragEl = target;
				parentEl = dragEl.parentNode;
				nextEl = dragEl.nextSibling;
				lastDownEl = target;
				activeGroup = options.group;
				oldIndex = startIndex;

				this._lastX = (touch || evt).clientX;
				this._lastY = (touch || evt).clientY;

				dragEl.style['will-change'] = 'transform';

				dragStartFn = function () {
					// Delayed drag has been triggered
					// we can re-enable the events: touchmove/mousemove
					_this._disableDelayedDrag();

					// Make the element draggable
					dragEl.draggable = _this.nativeDraggable;

					// Chosen item
					_toggleClass(dragEl, options.chosenClass, true);

					// Bind the events: dragstart/dragend
					_this._triggerDragStart(evt, touch);

					// Drag start event
					_dispatchEvent(_this, rootEl, 'choose', dragEl, rootEl, oldIndex);
				};

				// Disable "draggable"
				options.ignore.split(',').forEach(function (criteria) {
					_find(dragEl, criteria.trim(), _disableDraggable);
				});

				_on(ownerDocument, 'mouseup', _this._onDrop);
				_on(ownerDocument, 'touchend', _this._onDrop);
				_on(ownerDocument, 'touchcancel', _this._onDrop);
				_on(ownerDocument, 'pointercancel', _this._onDrop);
				_on(ownerDocument, 'selectstart', _this);

				if (options.delay) {
					// If the user moves the pointer or let go the click or touch
					// before the delay has been reached:
					// disable the delayed drag
					_on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
					_on(ownerDocument, 'touchend', _this._disableDelayedDrag);
					_on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
					_on(ownerDocument, 'mousemove', _this._disableDelayedDrag);
					_on(ownerDocument, 'touchmove', _this._disableDelayedDrag);
					_on(ownerDocument, 'pointermove', _this._disableDelayedDrag);

					_this._dragStartTimer = setTimeout(dragStartFn, options.delay);
				} else {
					dragStartFn();
				}


			}
		},

		_disableDelayedDrag: function () {
			var ownerDocument = this.el.ownerDocument;

			clearTimeout(this._dragStartTimer);
			_off(ownerDocument, 'mouseup', this._disableDelayedDrag);
			_off(ownerDocument, 'touchend', this._disableDelayedDrag);
			_off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
			_off(ownerDocument, 'mousemove', this._disableDelayedDrag);
			_off(ownerDocument, 'touchmove', this._disableDelayedDrag);
			_off(ownerDocument, 'pointermove', this._disableDelayedDrag);
		},

		_triggerDragStart: function (/** Event */evt, /** Touch */touch) {
			touch = touch || (evt.pointerType == 'touch' ? evt : null);

			if (touch) {
				// Touch device support
				tapEvt = {
					target: dragEl,
					clientX: touch.clientX,
					clientY: touch.clientY
				};

				this._onDragStart(tapEvt, 'touch');
			}
			else if (!this.nativeDraggable) {
				this._onDragStart(tapEvt, true);
			}
			else {
				_on(dragEl, 'dragend', this);
				_on(rootEl, 'dragstart', this._onDragStart);
			}

			try {
				if (document.selection) {
					// Timeout neccessary for IE9
					setTimeout(function () {
						document.selection.empty();
					});
				} else {
					window.getSelection().removeAllRanges();
				}
			} catch (err) {
			}
		},

		_dragStarted: function () {
			if (rootEl && dragEl) {
				var options = this.options;

				// Apply effect
				_toggleClass(dragEl, options.ghostClass, true);
				_toggleClass(dragEl, options.dragClass, false);

				Sortable.active = this;

				// Drag start event
				_dispatchEvent(this, rootEl, 'start', dragEl, rootEl, oldIndex);
			} else {
				this._nulling();
			}
		},

		_emulateDragOver: function () {
			if (touchEvt) {
				if (this._lastX === touchEvt.clientX && this._lastY === touchEvt.clientY) {
					return;
				}

				this._lastX = touchEvt.clientX;
				this._lastY = touchEvt.clientY;

				if (!supportCssPointerEvents) {
					_css(ghostEl, 'display', 'none');
				}

				var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY),
					parent = target,
					i = touchDragOverListeners.length;

				if (parent) {
					do {
						if (parent[expando]) {
							while (i--) {
								touchDragOverListeners[i]({
									clientX: touchEvt.clientX,
									clientY: touchEvt.clientY,
									target: target,
									rootEl: parent
								});
							}

							break;
						}

						target = parent; // store last element
					}
					/* jshint boss:true */
					while (parent = parent.parentNode);
				}

				if (!supportCssPointerEvents) {
					_css(ghostEl, 'display', '');
				}
			}
		},


		_onTouchMove: function (/**TouchEvent*/evt) {
			if (tapEvt) {
				var	options = this.options,
					fallbackTolerance = options.fallbackTolerance,
					fallbackOffset = options.fallbackOffset,
					touch = evt.touches ? evt.touches[0] : evt,
					dx = (touch.clientX - tapEvt.clientX) + fallbackOffset.x,
					dy = (touch.clientY - tapEvt.clientY) + fallbackOffset.y,
					translate3d = evt.touches ? 'translate3d(' + dx + 'px,' + dy + 'px,0)' : 'translate(' + dx + 'px,' + dy + 'px)';

				// only set the status to dragging, when we are actually dragging
				if (!Sortable.active) {
					if (fallbackTolerance &&
						min(abs(touch.clientX - this._lastX), abs(touch.clientY - this._lastY)) < fallbackTolerance
					) {
						return;
					}

					this._dragStarted();
				}

				// as well as creating the ghost element on the document body
				this._appendGhost();

				moved = true;
				touchEvt = touch;

				_css(ghostEl, 'webkitTransform', translate3d);
				_css(ghostEl, 'mozTransform', translate3d);
				_css(ghostEl, 'msTransform', translate3d);
				_css(ghostEl, 'transform', translate3d);

				evt.preventDefault();
			}
		},

		_appendGhost: function () {
			if (!ghostEl) {
				var rect = dragEl.getBoundingClientRect(),
					css = _css(dragEl),
					options = this.options,
					ghostRect;

				ghostEl = dragEl.cloneNode(true);

				_toggleClass(ghostEl, options.ghostClass, false);
				_toggleClass(ghostEl, options.fallbackClass, true);
				_toggleClass(ghostEl, options.dragClass, true);

				_css(ghostEl, 'top', rect.top - parseInt(css.marginTop, 10));
				_css(ghostEl, 'left', rect.left - parseInt(css.marginLeft, 10));
				_css(ghostEl, 'width', rect.width);
				_css(ghostEl, 'height', rect.height);
				_css(ghostEl, 'opacity', '0.8');
				_css(ghostEl, 'position', 'fixed');
				_css(ghostEl, 'zIndex', '100000');
				_css(ghostEl, 'pointerEvents', 'none');

				options.fallbackOnBody && document.body.appendChild(ghostEl) || rootEl.appendChild(ghostEl);

				// Fixing dimensions.
				ghostRect = ghostEl.getBoundingClientRect();
				_css(ghostEl, 'width', rect.width * 2 - ghostRect.width);
				_css(ghostEl, 'height', rect.height * 2 - ghostRect.height);
			}
		},

		_onDragStart: function (/**Event*/evt, /**boolean*/useFallback) {
			var dataTransfer = evt.dataTransfer,
				options = this.options;

			this._offUpEvents();

			if (activeGroup.checkPull(this, this, dragEl, evt)) {
				cloneEl = _clone(dragEl);

				cloneEl.draggable = false;
				cloneEl.style['will-change'] = '';

				_css(cloneEl, 'display', 'none');
				_toggleClass(cloneEl, this.options.chosenClass, false);

				rootEl.insertBefore(cloneEl, dragEl);
				_dispatchEvent(this, rootEl, 'clone', dragEl);
			}

			_toggleClass(dragEl, options.dragClass, true);

			if (useFallback) {
				if (useFallback === 'touch') {
					// Bind touch events
					_on(document, 'touchmove', this._onTouchMove);
					_on(document, 'touchend', this._onDrop);
					_on(document, 'touchcancel', this._onDrop);
					_on(document, 'pointermove', this._onTouchMove);
					_on(document, 'pointerup', this._onDrop);
				} else {
					// Old brwoser
					_on(document, 'mousemove', this._onTouchMove);
					_on(document, 'mouseup', this._onDrop);
				}

				this._loopId = setInterval(this._emulateDragOver, 50);
			}
			else {
				if (dataTransfer) {
					dataTransfer.effectAllowed = 'move';
					options.setData && options.setData.call(this, dataTransfer, dragEl);
				}

				_on(document, 'drop', this);
				setTimeout(this._dragStarted, 0);
			}
		},

		_onDragOver: function (/**Event*/evt) {
			var el = this.el,
				target,
				dragRect,
				targetRect,
				revert,
				options = this.options,
				group = options.group,
				activeSortable = Sortable.active,
				isOwner = (activeGroup === group),
				isMovingBetweenSortable = false,
				canSort = options.sort;

			if (evt.preventDefault !== void 0) {
				evt.preventDefault();
				!options.dragoverBubble && evt.stopPropagation();
			}

			if (dragEl.animated) {
				return;
			}

			moved = true;

			if (activeSortable && !options.disabled &&
				(isOwner
					? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list
					: (
						putSortable === this ||
						(
							(activeSortable.lastPullMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) &&
							group.checkPut(this, activeSortable, dragEl, evt)
						)
					)
				) &&
				(evt.rootEl === void 0 || evt.rootEl === this.el) // touch fallback
			) {
				// Smart auto-scrolling
				_autoScroll(evt, options, this.el);

				if (_silent) {
					return;
				}

				target = _closest(evt.target, options.draggable, el);
				dragRect = dragEl.getBoundingClientRect();

				if (putSortable !== this) {
					putSortable = this;
					isMovingBetweenSortable = true;
				}

				if (revert) {
					_cloneHide(activeSortable, true);
					parentEl = rootEl; // actualization

					if (cloneEl || nextEl) {
						rootEl.insertBefore(dragEl, cloneEl || nextEl);
					}
					else if (!canSort) {
						rootEl.appendChild(dragEl);
					}

					return;
				}


				if ((el.children.length === 0) || (el.children[0] === ghostEl) ||
					(el === evt.target) && (_ghostIsLast(el, evt))
				) {
					//assign target only if condition is true
					if (el.children.length !== 0 && el.children[0] !== ghostEl && el === evt.target) {
						target = el.lastElementChild;
					}

					if (target) {
						if (target.animated) {
							return;
						}

						targetRect = target.getBoundingClientRect();
					}

					_cloneHide(activeSortable, isOwner);

					if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt) !== false) {
						if (!dragEl.contains(el)) {
							el.appendChild(dragEl);
							parentEl = el; // actualization
						}

						this._animate(dragRect, dragEl);
						target && this._animate(targetRect, target);
					}
				}
				else if (target && !target.animated && target !== dragEl && (target.parentNode[expando] !== void 0)) {
					if (lastEl !== target) {
						lastEl = target;
						lastCSS = _css(target);
						lastParentCSS = _css(target.parentNode);
					}

					targetRect = target.getBoundingClientRect();

					var width = targetRect.right - targetRect.left,
						height = targetRect.bottom - targetRect.top,
						floating = R_FLOAT.test(lastCSS.cssFloat + lastCSS.display)
							|| (lastParentCSS.display == 'flex' && lastParentCSS['flex-direction'].indexOf('row') === 0),
						isWide = (target.offsetWidth > dragEl.offsetWidth),
						isLong = (target.offsetHeight > dragEl.offsetHeight),
						halfway = (floating ? (evt.clientX - targetRect.left) / width : (evt.clientY - targetRect.top) / height) > 0.5,
						nextSibling = target.nextElementSibling,
						after = false
					;

					if (floating) {
						var elTop = dragEl.offsetTop,
							tgTop = target.offsetTop;

						if (elTop === tgTop) {
							after = (target.previousElementSibling === dragEl) && !isWide || halfway && isWide;
						}
						else if (target.previousElementSibling === dragEl || dragEl.previousElementSibling === target) {
							after = (evt.clientY - targetRect.top) / height > 0.5;
						} else {
							after = tgTop > elTop;
						}
						} else if (!isMovingBetweenSortable) {
						after = (nextSibling !== dragEl) && !isLong || halfway && isLong;
					}

					var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);

					if (moveVector !== false) {
						if (moveVector === 1 || moveVector === -1) {
							after = (moveVector === 1);
						}

						_silent = true;
						setTimeout(_unsilent, 30);

						_cloneHide(activeSortable, isOwner);

						if (!dragEl.contains(el)) {
							if (after && !nextSibling) {
								el.appendChild(dragEl);
							} else {
								target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
							}
						}

						parentEl = dragEl.parentNode; // actualization

						this._animate(dragRect, dragEl);
						this._animate(targetRect, target);
					}
				}
			}
		},

		_animate: function (prevRect, target) {
			var ms = this.options.animation;

			if (ms) {
				var currentRect = target.getBoundingClientRect();

				if (prevRect.nodeType === 1) {
					prevRect = prevRect.getBoundingClientRect();
				}

				_css(target, 'transition', 'none');
				_css(target, 'transform', 'translate3d('
					+ (prevRect.left - currentRect.left) + 'px,'
					+ (prevRect.top - currentRect.top) + 'px,0)'
				);

				target.offsetWidth; // repaint

				_css(target, 'transition', 'all ' + ms + 'ms');
				_css(target, 'transform', 'translate3d(0,0,0)');

				clearTimeout(target.animated);
				target.animated = setTimeout(function () {
					_css(target, 'transition', '');
					_css(target, 'transform', '');
					target.animated = false;
				}, ms);
			}
		},

		_offUpEvents: function () {
			var ownerDocument = this.el.ownerDocument;

			_off(document, 'touchmove', this._onTouchMove);
			_off(document, 'pointermove', this._onTouchMove);
			_off(ownerDocument, 'mouseup', this._onDrop);
			_off(ownerDocument, 'touchend', this._onDrop);
			_off(ownerDocument, 'pointerup', this._onDrop);
			_off(ownerDocument, 'touchcancel', this._onDrop);
			_off(ownerDocument, 'pointercancel', this._onDrop);
			_off(ownerDocument, 'selectstart', this);
		},

		_onDrop: function (/**Event*/evt) {
			var el = this.el,
				options = this.options;

			clearInterval(this._loopId);
			clearInterval(autoScroll.pid);
			clearTimeout(this._dragStartTimer);

			// Unbind events
			_off(document, 'mousemove', this._onTouchMove);

			if (this.nativeDraggable) {
				_off(document, 'drop', this);
				_off(el, 'dragstart', this._onDragStart);
			}

			this._offUpEvents();

			if (evt) {
				if (moved) {
					evt.preventDefault();
					!options.dropBubble && evt.stopPropagation();
				}

				ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);

				if (rootEl === parentEl || Sortable.active.lastPullMode !== 'clone') {
					// Remove clone
					cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
				}

				if (dragEl) {
					if (this.nativeDraggable) {
						_off(dragEl, 'dragend', this);
					}

					_disableDraggable(dragEl);
					dragEl.style['will-change'] = '';

					// Remove class's
					_toggleClass(dragEl, this.options.ghostClass, false);
					_toggleClass(dragEl, this.options.chosenClass, false);

					// Drag stop event
					_dispatchEvent(this, rootEl, 'unchoose', dragEl, rootEl, oldIndex);

					if (rootEl !== parentEl) {
						newIndex = _index(dragEl, options.draggable);

						if (newIndex >= 0) {
							// Add event
							_dispatchEvent(null, parentEl, 'add', dragEl, rootEl, oldIndex, newIndex);

							// Remove event
							_dispatchEvent(this, rootEl, 'remove', dragEl, rootEl, oldIndex, newIndex);

							// drag from one list and drop into another
							_dispatchEvent(null, parentEl, 'sort', dragEl, rootEl, oldIndex, newIndex);
							_dispatchEvent(this, rootEl, 'sort', dragEl, rootEl, oldIndex, newIndex);
						}
					}
					else {
						if (dragEl.nextSibling !== nextEl) {
							// Get the index of the dragged element within its parent
							newIndex = _index(dragEl, options.draggable);

							if (newIndex >= 0) {
								// drag & drop within the same list
								_dispatchEvent(this, rootEl, 'update', dragEl, rootEl, oldIndex, newIndex);
								_dispatchEvent(this, rootEl, 'sort', dragEl, rootEl, oldIndex, newIndex);
							}
						}
					}

					if (Sortable.active) {
						/* jshint eqnull:true */
						if (newIndex == null || newIndex === -1) {
							newIndex = oldIndex;
						}

						_dispatchEvent(this, rootEl, 'end', dragEl, rootEl, oldIndex, newIndex);

						// Save sorting
						this.save();
					}
				}

			}

			this._nulling();
		},

		_nulling: function() {
			rootEl =
			dragEl =
			parentEl =
			ghostEl =
			nextEl =
			cloneEl =
			lastDownEl =

			scrollEl =
			scrollParentEl =

			tapEvt =
			touchEvt =

			moved =
			newIndex =

			lastEl =
			lastCSS =

			putSortable =
			activeGroup =
			Sortable.active = null;

			savedInputChecked.forEach(function (el) {
				el.checked = true;
			});
			savedInputChecked.length = 0;
		},

		handleEvent: function (/**Event*/evt) {
			switch (evt.type) {
				case 'drop':
				case 'dragend':
					this._onDrop(evt);
					break;

				case 'dragover':
				case 'dragenter':
					if (dragEl) {
						this._onDragOver(evt);
						_globalDragOver(evt);
					}
					break;

				case 'selectstart':
					evt.preventDefault();
					break;
			}
		},


		/**
		 * Serializes the item into an array of string.
		 * @returns {String[]}
		 */
		toArray: function () {
			var order = [],
				el,
				children = this.el.children,
				i = 0,
				n = children.length,
				options = this.options;

			for (; i < n; i++) {
				el = children[i];
				if (_closest(el, options.draggable, this.el)) {
					order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
				}
			}

			return order;
		},


		/**
		 * Sorts the elements according to the array.
		 * @param  {String[]}  order  order of the items
		 */
		sort: function (order) {
			var items = {}, rootEl = this.el;

			this.toArray().forEach(function (id, i) {
				var el = rootEl.children[i];

				if (_closest(el, this.options.draggable, rootEl)) {
					items[id] = el;
				}
			}, this);

			order.forEach(function (id) {
				if (items[id]) {
					rootEl.removeChild(items[id]);
					rootEl.appendChild(items[id]);
				}
			});
		},


		/**
		 * Save the current sorting
		 */
		save: function () {
			var store = this.options.store;
			store && store.set(this);
		},


		/**
		 * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
		 * @param   {HTMLElement}  el
		 * @param   {String}       [selector]  default: `options.draggable`
		 * @returns {HTMLElement|null}
		 */
		closest: function (el, selector) {
			return _closest(el, selector || this.options.draggable, this.el);
		},


		/**
		 * Set/get option
		 * @param   {string} name
		 * @param   {*}      [value]
		 * @returns {*}
		 */
		option: function (name, value) {
			var options = this.options;

			if (value === void 0) {
				return options[name];
			} else {
				options[name] = value;

				if (name === 'group') {
					_prepareGroup(options);
				}
			}
		},


		/**
		 * Destroy
		 */
		destroy: function () {
			var el = this.el;

			el[expando] = null;

			_off(el, 'mousedown', this._onTapStart);
			_off(el, 'touchstart', this._onTapStart);
			_off(el, 'pointerdown', this._onTapStart);

			if (this.nativeDraggable) {
				_off(el, 'dragover', this);
				_off(el, 'dragenter', this);
			}

			// Remove draggable attributes
			Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
				el.removeAttribute('draggable');
			});

			touchDragOverListeners.splice(touchDragOverListeners.indexOf(this._onDragOver), 1);

			this._onDrop();

			this.el = el = null;
		}
	};


	function _cloneHide(sortable, state) {
		if (sortable.lastPullMode !== 'clone') {
			state = true;
		}

		if (cloneEl && (cloneEl.state !== state)) {
			_css(cloneEl, 'display', state ? 'none' : '');

			if (!state) {
				if (cloneEl.state) {
					if (sortable.options.group.revertClone) {
						rootEl.insertBefore(cloneEl, nextEl);
						sortable._animate(dragEl, cloneEl);
					} else {
						rootEl.insertBefore(cloneEl, dragEl);
					}
				}
			}

			cloneEl.state = state;
		}
	}


	function _closest(/**HTMLElement*/el, /**String*/selector, /**HTMLElement*/ctx) {
		if (el) {
			ctx = ctx || document;

			do {
				if ((selector === '>*' && el.parentNode === ctx) || _matches(el, selector)) {
					return el;
				}
				/* jshint boss:true */
			} while (el = _getParentOrHost(el));
		}

		return null;
	}


	function _getParentOrHost(el) {
		var parent = el.host;

		return (parent && parent.nodeType) ? parent : el.parentNode;
	}


	function _globalDragOver(/**Event*/evt) {
		if (evt.dataTransfer) {
			evt.dataTransfer.dropEffect = 'move';
		}
		evt.preventDefault();
	}


	function _on(el, event, fn) {
		el.addEventListener(event, fn, captureMode);
	}


	function _off(el, event, fn) {
		el.removeEventListener(event, fn, captureMode);
	}


	function _toggleClass(el, name, state) {
		if (el) {
			if (el.classList) {
				el.classList[state ? 'add' : 'remove'](name);
			}
			else {
				var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
				el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
			}
		}
	}


	function _css(el, prop, val) {
		var style = el && el.style;

		if (style) {
			if (val === void 0) {
				if (document.defaultView && document.defaultView.getComputedStyle) {
					val = document.defaultView.getComputedStyle(el, '');
				}
				else if (el.currentStyle) {
					val = el.currentStyle;
				}

				return prop === void 0 ? val : val[prop];
			}
			else {
				if (!(prop in style)) {
					prop = '-webkit-' + prop;
				}

				style[prop] = val + (typeof val === 'string' ? '' : 'px');
			}
		}
	}


	function _find(ctx, tagName, iterator) {
		if (ctx) {
			var list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;

			if (iterator) {
				for (; i < n; i++) {
					iterator(list[i], i);
				}
			}

			return list;
		}

		return [];
	}



	function _dispatchEvent(sortable, rootEl, name, targetEl, fromEl, startIndex, newIndex) {
		sortable = (sortable || rootEl[expando]);

		var evt = document.createEvent('Event'),
			options = sortable.options,
			onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1);

		evt.initEvent(name, true, true);

		evt.to = rootEl;
		evt.from = fromEl || rootEl;
		evt.item = targetEl || rootEl;
		evt.clone = cloneEl;

		evt.oldIndex = startIndex;
		evt.newIndex = newIndex;

		rootEl.dispatchEvent(evt);

		if (options[onName]) {
			options[onName].call(sortable, evt);
		}
	}


	function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvt, willInsertAfter) {
		var evt,
			sortable = fromEl[expando],
			onMoveFn = sortable.options.onMove,
			retVal;

		evt = document.createEvent('Event');
		evt.initEvent('move', true, true);

		evt.to = toEl;
		evt.from = fromEl;
		evt.dragged = dragEl;
		evt.draggedRect = dragRect;
		evt.related = targetEl || toEl;
		evt.relatedRect = targetRect || toEl.getBoundingClientRect();
		evt.willInsertAfter = willInsertAfter;

		fromEl.dispatchEvent(evt);

		if (onMoveFn) {
			retVal = onMoveFn.call(sortable, evt, originalEvt);
		}

		return retVal;
	}


	function _disableDraggable(el) {
		el.draggable = false;
	}


	function _unsilent() {
		_silent = false;
	}


	/** @returns {HTMLElement|false} */
	function _ghostIsLast(el, evt) {
		var lastEl = el.lastElementChild,
			rect = lastEl.getBoundingClientRect();

		// 5  min delta
		// abs   ,      
		return (evt.clientY - (rect.top + rect.height) > 5) ||
			(evt.clientX - (rect.left + rect.width) > 5);
	}


	/**
	 * Generate id
	 * @param   {HTMLElement} el
	 * @returns {String}
	 * @private
	 */
	function _generateId(el) {
		var str = el.tagName + el.className + el.src + el.href + el.textContent,
			i = str.length,
			sum = 0;

		while (i--) {
			sum += str.charCodeAt(i);
		}

		return sum.toString(36);
	}

	/**
	 * Returns the index of an element within its parent for a selected set of
	 * elements
	 * @param  {HTMLElement} el
	 * @param  {selector} selector
	 * @return {number}
	 */
	function _index(el, selector) {
		var index = 0;

		if (!el || !el.parentNode) {
			return -1;
		}

		while (el && (el = el.previousElementSibling)) {
			if ((el.nodeName.toUpperCase() !== 'TEMPLATE') && (selector === '>*' || _matches(el, selector))) {
				index++;
			}
		}

		return index;
	}

	function _matches(/**HTMLElement*/el, /**String*/selector) {
		if (el) {
			selector = selector.split('.');

			var tag = selector.shift().toUpperCase(),
				re = new RegExp('\\s(' + selector.join('|') + ')(?=\\s)', 'g');

			return (
				(tag === '' || el.nodeName.toUpperCase() == tag) &&
				(!selector.length || ((' ' + el.className + ' ').match(re) || []).length == selector.length)
			);
		}

		return false;
	}

	function _throttle(callback, ms) {
		var args, _this;

		return function () {
			if (args === void 0) {
				args = arguments;
				_this = this;

				setTimeout(function () {
					if (args.length === 1) {
						callback.call(_this, args[0]);
					} else {
						callback.apply(_this, args);
					}

					args = void 0;
				}, ms);
			}
		};
	}

	function _extend(dst, src) {
		if (dst && src) {
			for (var key in src) {
				if (src.hasOwnProperty(key)) {
					dst[key] = src[key];
				}
			}
		}

		return dst;
	}

	function _clone(el) {
		return $
			? $(el).clone(true)[0]
			: (Polymer && Polymer.dom
				? Polymer.dom(el).cloneNode(true)
				: el.cloneNode(true)
			);
	}

	function _saveInputCheckedState(root) {
		var inputs = root.getElementsByTagName('input');
		var idx = inputs.length;

		while (idx--) {
			var el = inputs[idx];
			el.checked && savedInputChecked.push(el);
		}
	}

	// Fixed #973: 
	_on(document, 'touchmove', function (evt) {
		if (Sortable.active) {
			evt.preventDefault();
		}
	});

	try {
		window.addEventListener('test', null, Object.defineProperty({}, 'passive', {
			get: function () {
				captureMode = {
					capture: false,
					passive: false
				};
			}
		}));
	} catch (err) {}

	// Export utils
	Sortable.utils = {
		on: _on,
		off: _off,
		css: _css,
		find: _find,
		is: function (el, selector) {
			return !!_closest(el, selector, el);
		},
		extend: _extend,
		throttle: _throttle,
		closest: _closest,
		toggleClass: _toggleClass,
		clone: _clone,
		index: _index
	};


	/**
	 * Create sortable instance
	 * @param {HTMLElement}  el
	 * @param {Object}      [options]
	 */
	Sortable.create = function (el, options) {
		return new Sortable(el, options);
	};


	// Export
	Sortable.version = '1.6.1';
	return Sortable;
});


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

var ar = __webpack_require__(13)["ar"];
var bg = __webpack_require__(14)["bg"];
var bn = __webpack_require__(15)["bn"];
var cat = __webpack_require__(16)["cat"];
var cs = __webpack_require__(17)["cs"];
var cy = __webpack_require__(18)["cy"];
var da = __webpack_require__(19)["da"];
var de = __webpack_require__(20)["de"];
var eo = __webpack_require__(21)["eo"];
var es = __webpack_require__(22)["es"];
var et = __webpack_require__(23)["et"];
var fa = __webpack_require__(24)["fa"];
var fi = __webpack_require__(25)["fi"];
var fr = __webpack_require__(26)["fr"];
var gr = __webpack_require__(27)["gr"];
var he = __webpack_require__(28)["he"];
var hi = __webpack_require__(29)["hi"];
var hr = __webpack_require__(30)["hr"];
var hu = __webpack_require__(31)["hu"];
var id = __webpack_require__(32)["id"];
var it = __webpack_require__(33)["it"];
var ja = __webpack_require__(34)["ja"];
var ko = __webpack_require__(35)["ko"];
var lt = __webpack_require__(36)["lt"];
var lv = __webpack_require__(37)["lv"];
var mk = __webpack_require__(38)["mk"];
var ms = __webpack_require__(39)["ms"];
var my = __webpack_require__(40)["my"];
var nl = __webpack_require__(41)["nl"];
var no = __webpack_require__(42)["no"];
var pa = __webpack_require__(43)["pa"];
var pl = __webpack_require__(44)["pl"];
var pt = __webpack_require__(45)["pt"];
var ro = __webpack_require__(46)["ro"];
var ru = __webpack_require__(47)["ru"];
var si = __webpack_require__(48)["si"];
var sk = __webpack_require__(49)["sk"];
var sl = __webpack_require__(50)["sl"];
var sq = __webpack_require__(51)["sq"];
var sr = __webpack_require__(52)["sr"];
var sv = __webpack_require__(53)["sv"];
var th = __webpack_require__(54)["th"];
var tr = __webpack_require__(55)["tr"];
var uk = __webpack_require__(56)["uk"];
var vn = __webpack_require__(57)["vn"];
var zh = __webpack_require__(58)["zh"];

var l10n = {
	ar: ar,
	bg: bg,
	bn: bn,
	cat: cat,
	cs: cs,
	cy: cy,
	da: da,
	de: de,
	eo: eo,
	es: es,
	et: et,
	fa: fa,
	fi: fi,
	fr: fr,
	gr: gr,
	he: he,
	hi: hi,
	hr: hr,
	hu: hu,
	id: id,
	it: it,
	ja: ja,
	ko: ko,
	lt: lt,
	lv: lv,
	mk: mk,
	ms: ms,
	my: my,
	nl: nl,
	no: no,
	pa: pa,
	pl: pl,
	pt: pt,
	ro: ro,
	ru: ru,
	si: si,
	sk: sk,
	sl: sl,
	sq: sq,
	sr: sr,
	sv: sv,
	th: th,
	tr: tr,
	uk: uk,
	vn: vn,
	zh: zh
};

if (true) module.exports = l10n;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

/* Arabic locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.ar = {};

flatpickr.l10ns.ar.weekdays = {
	shorthand: ["", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", ""]
};

flatpickr.l10ns.ar.months = {
	shorthand: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
	longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

/* Bulgarian locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.bg = {};

flatpickr.l10ns.bg.weekdays = {
	shorthand: ["", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", ""]
};

flatpickr.l10ns.bg.months = {
	shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

/* Bangla locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.bn = {};

flatpickr.l10ns.bn.weekdays = {
	shorthand: ["", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", ""]
};

flatpickr.l10ns.bn.months = {
	shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

/* Catalan locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.cat = {};

flatpickr.l10ns.cat.weekdays = {
	shorthand: ["Dg", "Dl", "Dt", "Dc", "Dj", "Dv", "Ds"],
	longhand: ["Diumenge", "Dilluns", "Dimarts", "Dimecres", "Dijous", "Divendres", "Dissabte"]
};

flatpickr.l10ns.cat.months = {
	shorthand: ["Gen", "Febr", "Mar", "Abr", "Maig", "Juny", "Jul", "Ag", "Set", "Oct", "Nov", "Des"],
	longhand: ["Gener", "Febrer", "Mar", "Abril", "Maig", "Juny", "Juliol", "Agost", "Setembre", "Octubre", "Novembre", "Desembre"]
};

flatpickr.l10ns.cat.ordinal = function (nth) {
	var s = nth % 100;
	if (s > 3 && s < 21) return "";
	switch (s % 10) {
		case 1:
			return "r";
		case 2:
			return "n";
		case 3:
			return "r";
		case 4:
			return "t";
		default:
			return "";
	}
};

flatpickr.l10ns.cat.firstDayOfWeek = 1;

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

/* Czech locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.cs = {};

flatpickr.l10ns.cs.weekdays = {
	shorthand: ["Ne", "Po", "t", "St", "t", "P", "So"],
	longhand: ["Nedle", "Pondl", "ter", "Steda", "tvrtek", "Ptek", "Sobota"]
};

flatpickr.l10ns.cs.months = {
	shorthand: ["Led", "n", "Be", "Dub", "Kv", "er", "vc", "Srp", "Z", "j", "Lis", "Pro"],
	longhand: ["Leden", "nor", "Bezen", "Duben", "Kvten", "erven", "ervenec", "Srpen", "Z", "jen", "Listopad", "Prosinec"]
};

flatpickr.l10ns.cs.firstDayOfWeek = 1;

flatpickr.l10ns.cs.ordinal = function () {
	return ".";
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

/* Welsh locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.cy = {};

flatpickr.l10ns.cy.weekdays = {
	shorthand: ["Sul", "Llun", "Maw", "Mer", "Iau", "Gwe", "Sad"],
	longhand: ["Dydd Sul", "Dydd Llun", "Dydd Mawrth", "Dydd Mercher", "Dydd Iau", "Dydd Gwener", "Dydd Sadwrn"]
};

flatpickr.l10ns.cy.months = {
	shorthand: ["Ion", "Chwef", "Maw", "Ebr", "Mai", "Meh", "Gorff", "Awst", "Medi", "Hyd", "Tach", "Rhag"],
	longhand: ["Ionawr", "Chwefror", "Mawrth", "Ebrill", "Mai", "Mehefin", "Gorffennaf", "Awst", "Medi", "Hydref", "Tachwedd", "Rhagfyr"]
};

flatpickr.l10ns.cy.firstDayOfWeek = 1;

flatpickr.l10ns.cy.ordinal = function (nth) {
	if (nth === 1) return "af";

	if (nth === 2) return "ail";

	if (nth === 3 || nth === 4) return "ydd";

	if (nth === 5 || nth === 6) return "ed";

	if (nth >= 7 && nth <= 10 || nth == 12 || nth == 15 || nth == 18 || nth == 20) return "fed";

	if (nth == 11 || nth == 13 || nth == 14 || nth == 16 || nth == 17 || nth == 19) return "eg";

	if (nth >= 21 && nth <= 39) return "ain";

	// Inconclusive.
	return "";
};

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

/* Danish locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.da = {};

flatpickr.l10ns.da.weekdays = {
	shorthand: ["Sn", "Man", "Tir", "Ons", "Tors", "Fre", "Lr"],
	longhand: ["Sndag", "Mandag", "Tirsdag", "Onsdag", "Torsdag", "Fredag", "Lrdag"]
};

flatpickr.l10ns.da.months = {
	shorthand: ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dec"],
	longhand: ["Januar", "Februar", "Marts", "April", "Maj", "Juni", "Juli", "August", "September", "Oktober", "November", "December"]
};

flatpickr.l10ns.da.ordinal = function () {
	return ".";
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

/* German locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.de = {};

flatpickr.l10ns.de.weekdays = {
	shorthand: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
	longhand: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"]
};

flatpickr.l10ns.de.months = {
	shorthand: ["Jan", "Feb", "Mr", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"],
	longhand: ["Januar", "Februar", "Mrz", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"]
};

flatpickr.l10ns.de.firstDayOfWeek = 1;
flatpickr.l10ns.de.weekAbbreviation = "KW";
flatpickr.l10ns.de.rangeSeparator = " bis ";
flatpickr.l10ns.de.scrollTitle = "Zum ndern scrollen";
flatpickr.l10ns.de.toggleTitle = "Zum Umschalten klicken";

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

/* Esperanto locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.eo = {};

flatpickr.l10ns.eo.firstDayOfWeek = 1;

flatpickr.l10ns.eo.rangeSeparator = " is ";
flatpickr.l10ns.eo.weekAbbreviation = "Sem";
flatpickr.l10ns.eo.scrollTitle = "Rulumu por pligrandigi la valoron";
flatpickr.l10ns.eo.toggleTitle = "Klaku por alti";

flatpickr.l10ns.eo.weekdays = {
	shorthand: ["Dim", "Lun", "Mar", "Mer", "a", "Ven", "Sab"],
	longhand: ["dimano", "lundo", "mardo", "merkredo", "ado", "vendredo", "sabato"]
};

flatpickr.l10ns.eo.months = {
	shorthand: ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Ag", "Sep", "Okt", "Nov", "Dec"],
	longhand: ["januaro", "februaro", "marto", "aprilo", "majo", "junio", "julio", "agusto", "septembro", "oktobro", "novembro", "decembro"]
};

flatpickr.l10ns.eo.ordinal = function () {
	return "-a";
};

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

/* Spanish locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.es = {};

flatpickr.l10ns.es.weekdays = {
	shorthand: ["Dom", "Lun", "Mar", "Mi", "Jue", "Vie", "Sb"],
	longhand: ["Domingo", "Lunes", "Martes", "Mircoles", "Jueves", "Viernes", "Sbado"]
};

flatpickr.l10ns.es.months = {
	shorthand: ["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"],
	longhand: ["Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"]
};

flatpickr.l10ns.es.ordinal = function () {
	return "";
};

flatpickr.l10ns.es.firstDayOfWeek = 1;
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

/* Estonian locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.et = {};

flatpickr.l10ns.et.weekdays = {
	shorthand: ["P", "E", "T", "K", "N", "R", "L"],
	longhand: ["Phapev", "Esmaspev", "Teisipev", "Kolmapev", "Neljapev", "Reede", "Laupev"]
};

flatpickr.l10ns.et.months = {
	shorthand: ["Jaan", "Veebr", "Mrts", "Apr", "Mai", "Juuni", "Juuli", "Aug", "Sept", "Okt", "Nov", "Dets"],
	longhand: ["Jaanuar", "Veebruar", "Mrts", "Aprill", "Mai", "Juuni", "Juuli", "August", "September", "Oktoober", "November", "Detsember"]
};

flatpickr.l10ns.et.firstDayOfWeek = 1;

flatpickr.l10ns.et.ordinal = function () {
	return ".";
};

flatpickr.l10ns.et.weekAbbreviation = "Nd";
flatpickr.l10ns.et.rangeSeparator = " kuni ";
flatpickr.l10ns.et.scrollTitle = "Keri, et suurendada";
flatpickr.l10ns.et.toggleTitle = "Klpsa, et vahetada";

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

/* Farsi (Persian) locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.fa = {};

flatpickr.l10ns.fa.weekdays = {
	shorthand: ["", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", ""]
};

flatpickr.l10ns.fa.months = {
	shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
};

flatpickr.l10ns.fa.ordinal = function () {
	return "";
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

/* Finnish locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.fi = {};

flatpickr.l10ns.fi.firstDayOfWeek = 1;

flatpickr.l10ns.fi.weekdays = {
	shorthand: ["Su", "Ma", "Ti", "Ke", "To", "Pe", "La"],
	longhand: ["Sunnuntai", "Maanantai", "Tiistai", "Keskiviikko", "Torstai", "Perjantai", "Lauantai"]
};

flatpickr.l10ns.fi.months = {
	shorthand: ["Tammi", "Helmi", "Maalis", "Huhti", "Touko", "Kes", "Hein", "Elo", "Syys", "Loka", "Marras", "Joulu"],
	longhand: ["Tammikuu", "Helmikuu", "Maaliskuu", "Huhtikuu", "Toukokuu", "Keskuu", "Heinkuu", "Elokuu", "Syyskuu", "Lokakuu", "Marraskuu", "Joulukuu"]
};

flatpickr.l10ns.fi.ordinal = function () {
	return ".";
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

/* French locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.fr = {};

flatpickr.l10ns.fr.firstDayOfWeek = 1;

flatpickr.l10ns.fr.weekdays = {
	shorthand: ["Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam"],
	longhand: ["Dimanche", "Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Samedi"]
};

flatpickr.l10ns.fr.months = {
	shorthand: ["Janv", "Fvr", "Mars", "Avr", "Mai", "Juin", "Juil", "Aot", "Sept", "Oct", "Nov", "Dc"],
	longhand: ["Janvier", "Fvrier", "Mars", "Avril", "Mai", "Juin", "Juillet", "Aot", "Septembre", "Octobre", "Novembre", "Dcembre"]
};

flatpickr.l10ns.fr.ordinal = function (nth) {
	if (nth > 1) return "me";

	return "er";
};
if (true) module.exports = flatpickr.l10ns;

flatpickr.l10ns.fr.rangeSeparator = " au ";
flatpickr.l10ns.fr.weekAbbreviation = "Sem";
flatpickr.l10ns.fr.scrollTitle = "Dfiler pour augmenter la valeur";
flatpickr.l10ns.fr.toggleTitle = "Cliquer pour basculer";

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

/* Greek locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.gr = {};

flatpickr.l10ns.gr.weekdays = {
	shorthand: ["", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", ""]
};

flatpickr.l10ns.gr.months = {
	shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
};

flatpickr.l10ns.gr.firstDayOfWeek = 1;

flatpickr.l10ns.gr.ordinal = function () {
	return "";
};

flatpickr.l10ns.gr.weekAbbreviation = "";
flatpickr.l10ns.gr.rangeSeparator = "  ";
flatpickr.l10ns.gr.scrollTitle = "  ";
flatpickr.l10ns.gr.toggleTitle = "   ";

flatpickr.l10ns.gr.am = "";
flatpickr.l10ns.gr.pm = "";

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

/* Hebrew locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.he = {};

flatpickr.l10ns.he.weekdays = {
	shorthand: ["", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", ""]
};

flatpickr.l10ns.he.months = {
	shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

/* Hindi locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.hi = {};

flatpickr.l10ns.hi.weekdays = {
	shorthand: ["", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", ""]
};

flatpickr.l10ns.hi.months = {
	shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
	longhand: [" ", "", "", "", "", "", "", " ", "", "", "", ""]
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

/* Croatian locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.hr = {};

flatpickr.l10ns.hr.firstDayOfWeek = 1;

flatpickr.l10ns.hr.weekdays = {
	shorthand: ["Ned", "Pon", "Uto", "Sri", "et", "Pet", "Sub"],
	longhand: ["Nedjelja", "Ponedjeljak", "Utorak", "Srijeda", "etvrtak", "Petak", "Subota"]
};

flatpickr.l10ns.hr.months = {
	shorthand: ["Sij", "Velj", "Ou", "Tra", "Svi", "Lip", "Srp", "Kol", "Ruj", "Lis", "Stu", "Pro"],
	longhand: ["Sijeanj", "Veljaa", "Oujak", "Travanj", "Svibanj", "Lipanj", "Srpanj", "Kolovoz", "Rujan", "Listopad", "Studeni", "Prosinac"]
};

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

/* Hungarian locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.hu = {};

flatpickr.l10ns.hu.firstDayOfWeek = 1;

flatpickr.l10ns.hu.weekdays = {
	shorthand: ["V", "H", "K", "Sz", "Cs", "P", "Szo"],
	longhand: ["Vasrnap", "Htf", "Kedd", "Szerda", "Cstrtk", "Pntek", "Szombat"]
};

flatpickr.l10ns.hu.months = {
	shorthand: ["Jan", "Feb", "Mr", "pr", "Mj", "Jn", "Jl", "Aug", "Szep", "Okt", "Nov", "Dec"],
	longhand: ["Janur", "Februr", "Mrcius", "prilis", "Mjus", "Jnius", "Jlius", "Augusztus", "Szeptember", "Oktber", "November", "December"]
};

flatpickr.l10ns.hu.ordinal = function () {
	return ".";
};

flatpickr.l10ns.hu.weekAbbreviation = "Ht";
flatpickr.l10ns.hu.scrollTitle = "Grgessen";
flatpickr.l10ns.hu.toggleTitle = "Kattintson a vltshoz";

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

/* Indonesian locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.id = {};

flatpickr.l10ns.id.weekdays = {
	shorthand: ["Min", "Sen", "Sel", "Rab", "Kam", "Jum", "Sab"],
	longhand: ["Minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu"]
};

flatpickr.l10ns.id.months = {
	shorthand: ["Jan", "Feb", "Mar", "Apr", "Mei", "Jun", "Jul", "Agu", "Sep", "Okt", "Nov", "Des"],
	longhand: ["Januari", "Februari", "Maret", "April", "Mei", "Juni", "Juli", "Agustus", "September", "Oktober", "November", "Desember"]
};

flatpickr.l10ns.id.firstDayOfWeek = 1;

flatpickr.l10ns.id.ordinal = function () {
	return "";
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

/* Italian locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.it = {};

flatpickr.l10ns.it.weekdays = {
	shorthand: ["Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"],
	longhand: ["Domenica", "Luned", "Marted", "Mercoled", "Gioved", "Venerd", "Sabato"]
};

flatpickr.l10ns.it.months = {
	shorthand: ["Gen", "Feb", "Mar", "Apr", "Mag", "Giu", "Lug", "Ago", "Set", "Ott", "Nov", "Dic"],
	longhand: ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"]
};

flatpickr.l10ns.it.firstDayOfWeek = 1;

flatpickr.l10ns.it.ordinal = "";

flatpickr.l10ns.it.weekAbbreviation = "Se";

flatpickr.l10ns.it.scrollTitle = "Scrolla per aumentare";

flatpickr.l10ns.it.toggleTitle = "Clicca per cambiare";

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

/* Japanese locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.ja = {};

flatpickr.l10ns.ja.weekdays = {
	shorthand: ["", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", ""]
};

flatpickr.l10ns.ja.months = {
	shorthand: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
	longhand: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"]
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

/* Republic of Korea locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.ko = {};

flatpickr.l10ns.ko.weekdays = {
	shorthand: ["", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", ""]
};

flatpickr.l10ns.ko.months = {
	shorthand: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
	longhand: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"]
};

flatpickr.l10ns.ko.ordinal = function () {
	return "";
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

/* Lithuanian locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.lt = {};

flatpickr.l10ns.lt.weekdays = {
	shorthand: ["S", "Pr", "A", "T", "K", "Pn", ""],
	longhand: ["Sekmadienis", "Pirmadienis", "Antradienis", "Treiadienis", "Ketvirtadienis", "Penktadienis", "etadienis"]
};

flatpickr.l10ns.lt.months = {
	shorthand: ["Sau", "Vas", "Kov", "Bal", "Geg", "Bir", "Lie", "Rgp", "Rgs", "Spl", "Lap", "Grd"],
	longhand: ["Sausis", "Vasaris", "Kovas", "Balandis", "Gegu", "Birelis", "Liepa", "Rugpjutis", "Rugsejis", "Spalis", "Lapkritis", "Gruodis"]
};

flatpickr.l10ns.lt.firstDayOfWeek = 1;

flatpickr.l10ns.lt.ordinal = function () {
	return "-a";
};

flatpickr.l10ns.lt.weekAbbreviation = "Sav";
flatpickr.l10ns.lt.scrollTitle = "Keisti laik pels rateliu";
flatpickr.l10ns.lt.toggleTitle = "Perjungti laiko format";

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

/* Latvian locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.lv = {};

flatpickr.l10ns.lv.firstDayOfWeek = 1;

flatpickr.l10ns.lv.weekdays = {
	shorthand: ["Sv", "P", "Ot", "Tr", "Ce", "Pk", "Se"],
	longhand: ["Svtdiena", "Pirmdiena", "Otrdiena", "Trediena", "Ceturtdiena", "Piektdiena", "Sestdiena"]
};

flatpickr.l10ns.lv.months = {
	shorthand: ["Jan", "Feb", "Mar", "Mai", "Apr", "Jn", "Jl", "Aug", "Sep", "Okt", "Nov", "Dec"],
	longhand: ["Janvris", "Februris", "Marts", "Aprlis", "Maijs", "Jnijs", "Jlijs", "Augusts", "Septembris", "Oktobris", "Novembris", "Decembris"]
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

/* Macedonian locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.mk = {};

flatpickr.l10ns.mk.weekdays = {
	shorthand: ["", "", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", "", ""]
};

flatpickr.l10ns.mk.months = {
	shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
};

flatpickr.l10ns.mk.firstDayOfWeek = 1;
flatpickr.l10ns.mk.weekAbbreviation = ".";
flatpickr.l10ns.mk.rangeSeparator = "  ";

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

/* Malaysian locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.ms = {};

flatpickr.l10ns.ms.weekdays = {
	shorthand: ["Min", "Isn", "Sel", "Rab", "Kha", "Jum", "Sab"],
	longhand: ["Minggu", "Isnin", "Selasa", "Rabu", "Khamis", "Jumaat", "Sabtu"]
};

flatpickr.l10ns.ms.months = {
	shorthand: ["Jan", "Feb", "Mac", "Apr", "Mei", "Jun", "Jul", "Ogo", "Sep", "Okt", "Nov", "Dis"],
	longhand: ["Januari", "Februari", "Mac", "April", "Mei", "Jun", "Julai", "Ogos", "September", "Oktober", "November", "Disember"]
};

flatpickr.l10ns.ms.firstDayOfWeek = 1;

flatpickr.l10ns.ms.ordinal = function () {
	return "";
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

/* Burmese locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.my = {};

flatpickr.l10ns.my.weekdays = {
	shorthand: ["", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", ""]
};

flatpickr.l10ns.my.months = {
	shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
};

flatpickr.l10ns.my.firstDayOfWeek = 1;

flatpickr.l10ns.my.ordinal = function () {
	return "";
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

/* Dutch locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.nl = {};

flatpickr.l10ns.nl.weekdays = {
	shorthand: ["zo", "ma", "di", "wo", "do", "vr", "za"],
	longhand: ["zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag"]
};

flatpickr.l10ns.nl.months = {
	shorthand: ["jan", "feb", "mrt", "apr", "mei", "jun", "jul", "aug", "sept", "okt", "nov", "dec"],
	longhand: ["januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december"]
};

flatpickr.l10ns.nl.firstDayOfWeek = 1;
flatpickr.l10ns.nl.weekAbbreviation = "wk";
flatpickr.l10ns.nl.rangeSeparator = " tot ";
flatpickr.l10ns.nl.scrollTitle = "Scroll voor volgende / vorige";
flatpickr.l10ns.nl.toggleTitle = "Klik om te wisselen";

flatpickr.l10ns.nl.ordinal = function (nth) {
	if (nth === 1 || nth === 8 || nth >= 20) return "ste";

	return "de";
};

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

/* Norwegian locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.no = {};

flatpickr.l10ns.no.weekdays = {
	shorthand: ["Sn", "Man", "Tir", "Ons", "Tor", "Fre", "Lr"],
	longhand: ["Sndag", "Mandag", "Tirsdag", "Onsdag", "Torsdag", "Fredag", "Lrdag"]
};

flatpickr.l10ns.no.months = {
	shorthand: ["Jan", "Feb", "Mar", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Des"],
	longhand: ["Januar", "Februar", "Mars", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Desember"]
};

flatpickr.l10ns.no.firstDayOfWeek = 1;
flatpickr.l10ns.no.rangeSeparator = " til ";
flatpickr.l10ns.no.weekAbbreviation = "Uke";
flatpickr.l10ns.no.scrollTitle = "Scroll for  endre";
flatpickr.l10ns.no.toggleTitle = "Klikk for  veksle";

flatpickr.l10ns.no.ordinal = function () {
	return ".";
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

/* Punjabi locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.pa = {};

flatpickr.l10ns.pa.weekdays = {
	shorthand: ["", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", ""]
};

flatpickr.l10ns.pa.months = {
	shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

/* Polish locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.pl = {};

flatpickr.l10ns.pl.weekdays = {
	shorthand: ["Nd", "Pn", "Wt", "r", "Cz", "Pt", "So"],
	longhand: ["Niedziela", "Poniedziaek", "Wtorek", "roda", "Czwartek", "Pitek", "Sobota"]
};

flatpickr.l10ns.pl.months = {
	shorthand: ["Sty", "Lut", "Mar", "Kwi", "Maj", "Cze", "Lip", "Sie", "Wrz", "Pa", "Lis", "Gru"],
	longhand: ["Stycze", "Luty", "Marzec", "Kwiecie", "Maj", "Czerwiec", "Lipiec", "Sierpie", "Wrzesie", "Padziernik", "Listopad", "Grudzie"]
};

flatpickr.l10ns.pl.ordinal = function () {
	return ".";
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

/* Portuguese locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.pt = {};

flatpickr.l10ns.pt.weekdays = {
	shorthand: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sb"],
	longhand: ["Domingo", "Segunda-feira", "Tera-feira", "Quarta-feira", "Quinta-feira", "Sexta-feira", "Sbado"]
};

flatpickr.l10ns.pt.months = {
	shorthand: ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"],
	longhand: ["Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"]
};

flatpickr.l10ns.pt.rangeSeparator = " at ";

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

/* Romanian locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.ro = {};

flatpickr.l10ns.ro.weekdays = {
	shorthand: ["Dum", "Lun", "Mar", "Mie", "Joi", "Vin", "Sam"],
	longhand: ["Duminic", "Luni", "Mari", "Miercuri", "Joi", "Vineri", "Smbt"]
};

flatpickr.l10ns.ro.months = {
	shorthand: ["Ian", "Feb", "Mar", "Apr", "Mai", "Iun", "Iul", "Aug", "Sep", "Oct", "Noi", "Dec"],
	longhand: ["Ianuarie", "Februarie", "Martie", "Aprilie", "Mai", "Iunie", "Iulie", "August", "Septembrie", "Octombrie", "Noiembrie", "Decembrie"]
};

flatpickr.l10ns.ro.firstDayOfWeek = 1;

flatpickr.l10ns.ro.ordinal = function () {
	return "";
};

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

/* Russian locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.ru = {};

flatpickr.l10ns.ru.firstDayOfWeek = 1; // Monday

flatpickr.l10ns.ru.weekdays = {
	shorthand: ["", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", ""]
};

flatpickr.l10ns.ru.months = {
	shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

/* Sinhala locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.si = {};

flatpickr.l10ns.si.weekdays = {
	shorthand: ["", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", ""]
};

flatpickr.l10ns.si.months = {
	shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
};

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

/* Slovak locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.sk = {};

flatpickr.l10ns.sk.weekdays = {
	shorthand: ["Ned", "Pon", "Ut", "Str", "tv", "Pia", "Sob"],
	longhand: ["Nedea", "Pondelok", "Utorok", "Streda", "tvrtok", "Piatok", "Sobota"]
};

flatpickr.l10ns.sk.months = {
	shorthand: ["Jan", "Feb", "Mar", "Apr", "Mj", "Jn", "Jl", "Aug", "Sep", "Okt", "Nov", "Dec"],
	longhand: ["Janur", "Februr", "Marec", "Aprl", "Mj", "Jn", "Jl", "August", "September", "Oktber", "November", "December"]
};

flatpickr.l10ns.sk.firstDayOfWeek = 1;
flatpickr.l10ns.sk.rangeSeparator = " do ";
flatpickr.l10ns.sk.ordinal = function () {
	return ".";
};

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

/* Slovenian locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.sl = {};

flatpickr.l10ns.sl.weekdays = {
	shorthand: ["Ned", "Pon", "Tor", "Sre", "et", "Pet", "Sob"],
	longhand: ["Nedelja", "Ponedeljek", "Torek", "Sreda", "etrtek", "Petek", "Sobota"]
};

flatpickr.l10ns.sl.months = {
	shorthand: ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Avg", "Sep", "Okt", "Nov", "Dec"],
	longhand: ["Januar", "Februar", "Marec", "April", "Maj", "Junij", "Julij", "Avgust", "September", "Oktober", "November", "December"]
};

flatpickr.l10ns.sl.firstDayOfWeek = 1;
flatpickr.l10ns.sl.rangeSeparator = " do ";
flatpickr.l10ns.sl.ordinal = function () {
	return ".";
};

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

/* Albanian locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.sq = {};

flatpickr.l10ns.sq.weekdays = {
	shorthand: ["Di", "H", "Ma", "M", "En", "Pr", "Sh"],
	longhand: ["E Diel", "E Hn", "E Mart", "E Mrkur", "E Enjte", "E Premte", "E Shtun"]
};

flatpickr.l10ns.sq.months = {
	shorthand: ["Jan", "Shk", "Mar", "Pri", "Maj", "Qer", "Kor", "Gus", "Sht", "Tet", "Nn", "Dhj"],
	longhand: ["Janar", "Shkurt", "Mars", "Prill", "Maj", "Qershor", "Korrik", "Gusht", "Shtator", "Tetor", "Nntor", "Dhjetor"]
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

/* Serbian locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.sr = {};

flatpickr.l10ns.sr.weekdays = {
	shorthand: ["Ned", "Pon", "Uto", "Sre", "et", "Pet", "Sub", "Ned"],
	longhand: ["Nedelja", "Ponedeljak", "Utorak", "Sreda", "etvrtak", "Petak", "Subota", "Nedelja"]
};

flatpickr.l10ns.sr.months = {
	shorthand: ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Avg", "Sep", "Okt", "Nov", "Dec"],
	longhand: ["Januar", "Februar", "Mart", "April", "Maj", "Jun", "Jul", "Avgust", "Septembar", "Oktobar", "Novembar", "Decembar"]
};

flatpickr.l10ns.sr.firstDayOfWeek = 1;
flatpickr.l10ns.sr.weekAbbreviation = "Ned.";
flatpickr.l10ns.sr.rangeSeparator = " do ";

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

/* Swedish locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.sv = {};

flatpickr.l10ns.sv.firstDayOfWeek = 1;
flatpickr.l10ns.sv.weekAbbreviation = "v";

flatpickr.l10ns.sv.weekdays = {
	shorthand: ["Sn", "Mn", "Tis", "Ons", "Tor", "Fre", "Lr"],
	longhand: ["Sndag", "Mndag", "Tisdag", "Onsdag", "Torsdag", "Fredag", "Lrdag"]
};

flatpickr.l10ns.sv.months = {
	shorthand: ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dec"],
	longhand: ["Januari", "Februari", "Mars", "April", "Maj", "Juni", "Juli", "Augusti", "September", "Oktober", "November", "December"]
};

flatpickr.l10ns.sv.ordinal = function () {
	return ".";
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

/* Thai locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.th = {};

flatpickr.l10ns.th.weekdays = {
	shorthand: ["", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", ""]
};

flatpickr.l10ns.th.months = {
	shorthand: ["..", "..", "..", "..", "..", "..", "..", "..", "..", "..", "..", ".."],
	longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
};

flatpickr.l10ns.th.firstDayOfWeek = 1;
flatpickr.l10ns.th.rangeSeparator = "  ";
flatpickr.l10ns.th.scrollTitle = "";
flatpickr.l10ns.th.toggleTitle = "";

flatpickr.l10ns.th.ordinal = function () {
	return "";
};

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

/* Turkish locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.tr = {};

flatpickr.l10ns.tr.firstDayOfWeek = 1;

flatpickr.l10ns.tr.weekdays = {
	shorthand: ["Paz", "Pzt", "Sal", "ar", "Per", "Cum", "Cmt"],
	longhand: ["Pazar", "Pazartesi", "Sal", "aramba", "Perembe", "Cuma", "Cumartesi"]
};

flatpickr.l10ns.tr.months = {
	shorthand: ["Oca", "ub", "Mar", "Nis", "May", "Haz", "Tem", "Au", "Eyl", "Eki", "Kas", "Ara"],
	longhand: ["Ocak", "ubat", "Mart", "Nisan", "Mays", "Haziran", "Temmuz", "Austos", "Eyll", "Ekim", "Kasm", "Aralk"]
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

/* Ukrainian locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.uk = {};

flatpickr.l10ns.uk.firstDayOfWeek = 1;

flatpickr.l10ns.uk.weekdays = {
	shorthand: ["", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "'", ""]
};

flatpickr.l10ns.uk.months = {
	shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

/* Vietnamese locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.vn = {};

flatpickr.l10ns.vn.weekdays = {
	shorthand: ["CN", "T2", "T3", "T4", "T5", "T6", "T7"],
	longhand: ["Ch nht", "Th hai", "Th ba", "Th t", "Th nm", "Th su", "Th by"]
};

flatpickr.l10ns.vn.months = {
	shorthand: ["Th1", "Th2", "Th3", "Th4", "Th5", "Th6", "Th7", "Th8", "Th9", "Th10", "Th11", "Th12"],
	longhand: ["Thng mt", "Thng hai", "Thng ba", "Thng t", "Thng nm", "Thng su", "Thng by", "Thng tm", "Thng chn", "Thng mi", "Thng 11", "Thng 12"]
};

flatpickr.l10ns.vn.firstDayOfWeek = 1;

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

/* Mandarin locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.zh = {};

flatpickr.l10ns.zh.weekdays = {
	shorthand: ["", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", ""]
};

flatpickr.l10ns.zh.months = {
	shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
};

flatpickr.l10ns.zh.rangeSeparator = "  ";
flatpickr.l10ns.zh.weekAbbreviation = "";
flatpickr.l10ns.zh.scrollTitle = "";
flatpickr.l10ns.zh.toggleTitle = " 12/24 ";

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var accessibility = {

    accessibility_selector: 0,

    start: function start() {

        // Save elements
        accessibility.parentElement = document.querySelector('[data-component=accessibility]');
        accessibility.passwordElement = accessibility.parentElement.querySelector('.component_accessibility_password');
        accessibility.passwordInput = accessibility.passwordElement.querySelector('input');
        accessibility.selectElement = accessibility.parentElement.querySelector('select');

        accessibility.selector = accessibility.createSelector();
    },
    createSelector: function createSelector() {

        return new _Global2.default.Selector({

            element: 'select[name=component_accessibility_selector]',
            selected: function selected(instance, option) {

                accessibility.accessibility_selector = option;

                if (parseInt(accessibility.accessibility_selector) === 1) accessibility.passwordElement.classList.remove('hide');else accessibility.passwordElement.classList.add('hide');

                _Global2.default.packery.reloadItems();
            },


            opened: _Global2.default.packery.reloadItems,
            closed: _Global2.default.packery.reloadItems

        });
    },
    resume: function resume() {

        // Save current instance
        var data = this.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var accessibility = JSON.parse(data);

        var selectOptions = this.selectElement.querySelectorAll('option');
        this.accessibility_selector = accessibility.accessibility_selector;
        this.passwordInput.value = accessibility.accessibility_password;

        if (accessibility.accessibility_selector === 1) this.passwordElement.classList.remove('hide');

        Object.values(selectOptions).forEach(function (selectOption, index) {

            if (index !== accessibility.accessibility_selector) selectOption.removeAttribute('selected');else selectOption.setAttribute('selected', 'true');
        });

        this.selector.destroy();
        this.selector = this.createSelector();
    },
    validate: function validate() {

        var data = accessibility.serialize();
        var validateSelector = data.accessibility_selector > -1 && data.accessibility_selector < 3;
        var validatePassword = data.accessibility_password.length < 121;

        return validateSelector && validatePassword;
    },
    serialize: function serialize() {

        return {

            accessibility_selector: accessibility.accessibility_selector,
            accessibility_password: accessibility.passwordInput.value.trim()

        };
    }
};

module.exports = accessibility;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var analytics = {

    start: function start() {

        // Save elements
        analytics.parentElement = document.querySelector('[data-component=analytics]');
        analytics.detailsElement = analytics.parentElement.querySelector('div.component_analytics_details');
        analytics.analyticsCheck = analytics.parentElement.querySelector('[name=component_analytics]');
        analytics.detailsCheck = analytics.parentElement.querySelector('[name=component_analytics_details]');

        // Show / Hide "detailed analytics" checkbox
        _Utils2.default.registerEvent({

            event: 'change',
            element: analytics.analyticsCheck,

            content: function content(event) {

                var classList = analytics.detailsElement.classList;

                if (!!event.target.checked) classList.remove('hide');else classList.add('hide');

                _Global2.default.packery.reloadItems();
            }

        });
    },

    resume: function resume() {

        // Save current instance
        var data = this.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var analytics = JSON.parse(data);

        this.analyticsCheck.checked = !!analytics.analytics;
        _Utils2.default.triggerEvent(this.analyticsCheck, 'change');

        this.detailsCheck.checked = !!analytics.analytics_details;
    },

    validate: function validate() {

        return true;
    },

    serialize: function serialize() {

        return {

            analytics: !!analytics.analyticsCheck.checked,
            analytics_details: !!analytics.detailsCheck.checked

        };
    }

};

module.exports = analytics;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var attachments = {
    start: function start() {

        // Save elements
        attachments.parentElement = document.querySelector('[data-component=attachments]');
        attachments.listElement = attachments.parentElement.querySelector('.attachments-list');
        attachments.templateElement = attachments.parentElement.querySelector('#template_component_attachments_added').childNodes[0];

        // Delegate events
        _Utils2.default.registerEvent({

            event: 'click',
            element: attachments.parentElement,
            content: function content(event) {

                // Open MediaManager
                if (event.target.matches('.add-attachment')) {

                    var type = event.target.getAttribute('data-content');

                    _Global2.default.managerActiveInstance = new _Global2.default.MediaManager({
                        manager: type,
                        onSelect: function onSelect(path) {

                            attachments.addNew(path, type);
                        }
                    });
                }

                // Remove attachment
                else if (event.target.matches('.attachment-remove')) {

                        attachments.listElement.removeChild(event.target.parentNode);
                        _Global2.default.packery.reloadItems();
                    }
            }

        });
    },
    resume: function resume() {
        var _this = this;

        // Save attachments instance
        var data = this.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var attachments = JSON.parse(data).attachments;

        if (attachments === null) return true;

        var attachmentTypes = ['images', 'videos', 'sounds', 'files'];
        var attachmentDefinitions = ['app/Data/Files/Images/', 'app/Data/Files/Videos/', 'app/Data/Files/Sounds/', 'app/Data/Files/Files/'];

        Array.from(attachments).forEach(function (attachment) {

            var typeNumber = attachmentDefinitions.findIndex(function (definition) {
                return ~attachment.indexOf(definition);
            });

            attachment = attachment.replace(attachmentDefinitions[typeNumber], '');

            _this.addNew(attachment, attachmentTypes[typeNumber]);
        });
    },
    isDuplicate: function isDuplicate(path) {

        return ~attachments.serialize().attachments.indexOf(path);
    },
    addNew: function addNew(path, type) {

        var types = {
            images: ['Images', 'image'],
            videos: ['Videos', 'video'],
            sounds: ['Sounds', 'audio'],
            files: ['Files', 'file']
        };

        var pathPrefix = 'app/Data/Files/';
        var fileType = types[type][1];
        var text = path;

        path = pathPrefix + types[type][0] + '/' + path;

        if (attachments.isDuplicate(path)) return _Utils2.default.closeMediaManager();

        var template = attachments.templateElement.cloneNode(true);

        template.classList.add('component-instance');
        template.setAttribute('data-path', path);
        template.classList.add('icon-' + fileType);
        template.childNodes[1].innerText = text;

        attachments.listElement.insertBefore(template, attachments.listElement.childNodes[0]);

        _Utils2.default.closeMediaManager();
        _Global2.default.packery.reloadItems();
    },
    validate: function validate() {

        return true;
    },
    serialize: function serialize() {

        var attachmentsElements = attachments.listElement.childNodes;
        var attachmentsList = Array.from(attachmentsElements).reverse().map(function (element) {
            return element.getAttribute('data-path');
        });

        return {

            attachments: attachmentsList

        };
    }
};

module.exports = attachments;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var audio = {

    data: {},

    resumeInline: function resumeInline(identifier, element, resumeData) {

        var path = resumeData.audio;

        audio.create(identifier, element);
        audio.onSelect(identifier, element, path, true);
    },

    validateInput: function validateInput(element, identifier, path, onSuccess) {

        var messageBox = element.querySelector('.validate-message');

        if (!/[(http(s)?):\/\/(www\.)?a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)/.test(path)) {

            _Utils2.default.showValidationResults(messageBox, 'COMPONENT_URL_INVALID', false);

            return false;
        }

        new Promise(function (resolve) {

            var audio = new Audio();

            audio.addEventListener('canplaythrough', function () {
                resolve(true);
            });

            audio.addEventListener('error', function () {
                resolve(false);
            });

            audio.src = path;
        }).then(function (result) {

            if (result) _Utils2.default.showValidationResults(messageBox, 'COMPONENT_URL_INVALID', true);else _Utils2.default.showValidationResults(messageBox, 'COMPONENT_URL_INVALID', false);
        });

        if (onSuccess) onSuccess();
    },

    remove: function remove(element) {

        element.querySelectorAll('div.component-instance').forEach(function (item) {
            item.querySelector('span.item-remove').click();
        });
    },

    onSelect: function onSelect(identifier, element, path, outside) {

        var contentElement = element.querySelector('div.component-element-content');
        contentElement.classList.add('no-padding');

        // Remove current audio
        audio.remove(element);

        // Create source link
        if (!outside) path = 'app/Data/Files/Sounds/' + path;

        // Save audio path
        audio.data[identifier] = {
            audio: path
        };

        // Create template
        var template = contentElement.querySelector('#template_component_content_audio_item').children[0].cloneNode(true);
        template.setAttribute('data-path', path);
        template.classList.add('component-instance');
        template.children[0].setAttribute('src', path);
        template.children[3].innerText = path.split('/').pop();
        contentElement.appendChild(template);

        var timer = void 0;
        template.children[1].addEventListener('click', function (event) {
            if (template.children[0].ended) template.children[2].click();
            if (template.children[0].paused) {
                template.children[0].play();
                showPlayerTime();
                timer = setInterval(showPlayerTime, 1000);
            } else {
                template.children[0].pause();
                showPlayerTime();
                clearInterval(timer);
            }
            event.target.classList.toggle('icon-pause');
        });

        template.children[2].addEventListener('click', function () {
            template.children[0].currentTime = 0;
            template.children[0].pause();
            template.children[1].classList.remove('icon-pause');
            clearInterval(timer);
            showPlayerTime();
        });

        function showPlayerTime() {
            var position = template.children[0].currentTime;
            position = parseInt(position / 60, 10) + ':' + _Utils2.default.pad(Math.round(position % 60), 2);
            var duration = template.children[0].duration;
            var minutes = parseInt(duration / 60, 10);
            var seconds = duration % 60;
            template.children[5].innerText = position + '/' + minutes + ':' + _Utils2.default.pad(Math.round(seconds), 2);
        }

        // Hide media manager
        template.children[0].addEventListener('loadedmetadata', function () {
            showPlayerTime();
            contentElement.querySelector('div.input-box.select-image').classList.add('hide');
            document.querySelector('div.media-manager span.close-manager').click();
        });

        // Remove audio
        template.children[4].addEventListener('click', function () {
            contentElement.querySelector('div.input-box.select-image').classList.remove('hide');
            contentElement.removeChild(template);
            contentElement.classList.remove('no-padding');
            delete audio.data[identifier];
        });
    },

    create: function create(identifier, element) {

        audio.data[identifier] = {
            title: '',
            disabled: 0
        };

        _Utils2.default.registerEvents([{
            // Open Media manager
            event: 'click',
            element: element.querySelector('button.inline-image_manager'),
            content: function content() {
                _Global2.default.managerActiveInstance = new _Global2.default.MediaManager({
                    manager: 'sounds',
                    onSelect: function onSelect(path) {
                        audio.onSelect(identifier, element, path, false);
                    }
                });
            }
        }, {
            // Enter custom URL to audio
            event: 'keypress',
            element: element.querySelector('input[name=component_inline_audio_input]'),
            content: function content(event) {
                if (event.keyCode && event.keyCode === 13) {
                    var path = event.target.value;
                    audio.validateInput(element, identifier, path, function () {
                        audio.onSelect(identifier, element, path, true);
                    });
                }
            }
        }, {
            // Real-time URL validation
            event: 'change keyup',
            element: element.querySelector('input[name=component_inline_audio_input]'),
            content: function content(event) {
                audio.validateInput(element, identifier, event.target.value);
            }
        }]);
    },

    validate: function validate() {
        return true;
    },

    serialize: function serialize() {
        return audio.data;
    }

};

module.exports = audio;

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

var _Ajax = __webpack_require__(2);

var _Ajax2 = _interopRequireDefault(_Ajax);

var _Router = __webpack_require__(3);

var _Router2 = _interopRequireDefault(_Router);

var _Csrf = __webpack_require__(5);

var _Csrf2 = _interopRequireDefault(_Csrf);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var categories = {
    start: function start() {
        var _this = this;

        // Save elements
        var current = this;
        current.parentElement = document.querySelector('[data-component=categories]');
        current.listElement = current.parentElement.querySelector('.categories-list');
        current.inputElement = current.parentElement.querySelector('input');
        current.templateElement = current.parentElement.querySelector('#template_component_categories_item').childNodes[0];

        // Get and show categories
        var categories = _Ajax2.default.getJSON(_Router2.default.createLink('api/categories.all&csrf_token=' + _Csrf2.default.getToken()));

        if (!categories.success || categories.code !== 200) return true;

        Object.values(categories.data).forEach(function (category) {

            var template = current.templateElement.cloneNode(true);
            template.setAttribute('data-category', category.id);
            template.setAttribute('data-active', 'false');
            template.children[0].innerText = category.name;

            _this.listElement.appendChild(template);
        });

        // Events
        _Utils2.default.registerEvents([{
            // Delegate click events
            event: 'click',
            element: current.parentElement,
            content: function content(event) {

                var target = event.target;

                // Add category
                if (target.matches('.add-category')) {

                    target.parentNode.setAttribute('data-active', 'true');
                    target.classList.add('hide');
                    target.nextSibling.classList.remove('hide');
                }

                // Remove category
                else if (target.matches('.remove-category')) {

                        target.parentNode.setAttribute('data-active', 'false');
                        target.previousSibling.classList.remove('hide');
                        target.classList.add('hide');
                    }
            }
        }, {
            // Search in categories
            event: 'change keyup',
            element: current.inputElement,
            content: function content() {

                var searchPhrase = current.inputElement.value.trim().toLowerCase();

                Array.from(current.listElement.childNodes).forEach(function (categoryElement) {

                    var categoryName = categoryElement.childNodes[0].innerText.toLowerCase();

                    if (~categoryName.indexOf(searchPhrase)) categoryElement.classList.remove('hide');else categoryElement.classList.add('hide');
                });

                _Global2.default.packery.reloadItems();
            }
        }]);

        _Global2.default.packery.reloadItems();
    },
    resume: function resume() {
        var _this2 = this;

        // Save current instance
        var data = this.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var categories = JSON.parse(data).categories;

        if (categories === null) return true;

        categories.forEach(function (category) {

            _this2.listElement.querySelector('[data-category="' + category + '"]').childNodes[1].click();
        });
    },
    validate: function validate() {

        return true;
    },
    serialize: function serialize() {

        var categoriesElements = categories.listElement.querySelectorAll('[data-active=true]');

        var activeCategories = Object.values(categoriesElements).map(function (categoryElement) {
            return categoryElement.getAttribute('data-category');
        });

        return {

            categories: activeCategories

        };
    }
};

module.exports = categories;

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Ajax = __webpack_require__(2);

var _Ajax2 = _interopRequireDefault(_Ajax);

var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var code = {

    programmingLanguages: [],
    select: false,
    data: {},

    resumeInline: function resumeInline(identifier, element, resumeData) {

        code.create(identifier, element, resumeData);
    },
    createSelector: function createSelector(identifier) {

        setTimeout(function () {

            new _Global2.default.Selector({

                element: 'select[name=component-inline-code-programming_languages-select_' + identifier + ']',
                selected: function selected(instance, option) {
                    code.data[identifier].code_language = +option.trim();
                }
            });
        });
    },
    create: function create(identifier, element, resumeData) {

        // Load programming languages
        if (code.programmingLanguages.length === 0) code.programmingLanguages = _Ajax2.default.getJSON('app/Config/programming_languages.json');

        // Create language selector
        if (code.select === false) {

            var _select = document.createElement('select');

            _select.setAttribute('id', 'select-relative');
            _select.setAttribute('data-type', 'search-selector');

            code.programmingLanguages.forEach(function (language, key) {

                var option = document.createElement('option');
                option.setAttribute('value', key.toString());

                if (language === 'JavaScript') option.setAttribute('selected', 'true');

                option.innerText = language;
                _select.appendChild(option);
            });

            code.select = _select;
        }

        var contentElement = element.querySelector('div.component-element-content');
        var textarea = contentElement.querySelector('textarea');
        var select = code.select.cloneNode(true);

        // Initialize data object
        code.data[identifier] = {
            title: '',
            code: '',
            code_language: 299,
            disabled: 0
        };

        if (resumeData) {

            if (resumeData.code) code.data[identifier].code = textarea.value = resumeData.code.trim();

            if (resumeData.code_language) {

                var selected = select.querySelector('[selected]');
                code.data[identifier].code_language = resumeData.code_language;

                selected.removeAttribute('selected');
                select.children[resumeData.code_language].setAttribute('selected', 'true');
            }
        }

        select.setAttribute('name', 'component-inline-code-programming_languages-select_' + identifier);
        contentElement.appendChild(select);

        code.createSelector(identifier);

        // Initialize events
        _Utils2.default.registerEvents([{
            // Serialize textarea
            event: 'change keyup',
            element: textarea,
            content: function content(event) {
                code.data[identifier].code = event.target.value.trim();
            }
        }, {
            // Tab in textarea
            event: 'keydown',
            element: textarea,
            content: function content(event) {

                var keyCode = event.keyCode || event.which;

                if (keyCode === 9) {

                    event.preventDefault();

                    var start = this.selectionStart;
                    var end = this.selectionEnd;
                    var val = this.value;
                    var _selected = val.substring(start, end);
                    var re = /^/gm;
                    var count = _selected.match(re).length * 4;

                    this.value = val.substring(0, start) + _selected.replace(re, '    ') + val.substring(end);

                    if (start === end) this.selectionStart = end + count;else this.selectionStart = start;

                    this.selectionEnd = end + count;
                }
            }
        }]);
    },
    validate: function validate() {
        return true;
    },
    serialize: function serialize() {
        return code.data;
    }
};

module.exports = code;

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var comments = {
    start: function start() {

        // Save elements
        comments.parentElement = document.querySelector('[data-component=comments]');
        comments.commentsCheck = comments.parentElement.querySelector('[name=component_comments]');
        comments.approveBox = comments.parentElement.querySelector('.component_comments_approve');
        comments.approveCheck = comments.approveBox.querySelector('input');

        // Events
        _Utils2.default.registerEvent({

            event: 'change',
            element: comments.commentsCheck,
            content: function content() {

                if (!!comments.commentsCheck.checked) comments.approveBox.classList.remove('hide');else comments.approveBox.classList.add('hide');

                _Global2.default.packery.reloadItems();
            }
        });
    },
    resume: function resume() {

        // Save current instance
        var data = this.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var comments = JSON.parse(data);

        this.commentsCheck.checked = !!comments.comments;
        _Utils2.default.triggerEvent(this.commentsCheck, 'change');

        this.approveCheck.checked = comments.comments_approve;
    },
    validate: function validate() {

        return true;
    },
    serialize: function serialize() {

        return {

            comments: !!comments.commentsCheck.checked,
            comments_approve: !!comments.approveCheck.checked

        };
    }
};

module.exports = comments;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var copy = {
    start: function start() {

        // Save elements
        copy.parentElement = document.querySelector('[data-component=copyright]');
        copy.selectElement = copy.parentElement.querySelector('select');

        copy.selector = copy.createSelector();
    },
    createSelector: function createSelector() {

        return new _Global2.default.Selector({
            element: '[name=component_copyright_selector]',
            opened: _Global2.default.packery.reloadItems,
            closed: _Global2.default.packery.reloadItems
        });
    },
    resume: function resume() {

        // Save current instance
        var data = this.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var copyright = JSON.parse(data).copyright;

        var selectOptions = this.selectElement.querySelectorAll('option');

        Object.values(selectOptions).forEach(function (selectOption, index) {

            if (index !== copyright) selectOption.removeAttribute('selected');else selectOption.setAttribute('selected', 'true');
        });

        this.selector.destroy();
        this.selector = this.createSelector();
    },
    validate: function validate() {

        var data = copy.serialize().copyright;

        return data > -1 && data < 6;
    },
    serialize: function serialize() {

        return {

            copyright: parseInt(copy.selectElement.querySelector('[selected=true]').getAttribute('value'))

        };
    }
};

module.exports = copy;

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var created = {
    start: function start() {

        // Save elements
        created.parentElement = document.querySelector('[data-component=created_at]');
        created.customCheck = created.parentElement.querySelector('[name=component_created]');
        created.dateBox = created.parentElement.querySelector('.component_created_custom');
        created.dateInput = created.dateBox.querySelector('input');
        created.clearInput = created.dateBox.querySelector('.clear-input');

        created.customCheck.checked = false;

        // Events
        _Utils2.default.registerEvents([{
            // Show / Hide custom input
            event: 'change',
            element: created.customCheck,
            content: function content() {

                if (created.customCheck.checked) created.dateBox.classList.remove('hide');else created.dateBox.classList.add('hide');

                _Global2.default.packery.reloadItems();
            }
        }, {
            // Clear input
            event: 'click',
            element: created.clearInput,
            content: function content() {

                created.dateInput.value = '';
            }
        }]);
    },
    resume: function resume() {

        // Save current instance
        var data = this.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        this.dateInput.value = JSON.parse(data).created_at;
        _Utils2.default.triggerEvent(this.customCheck, 'click');
    },
    validate: function validate() {

        return true;
    },
    serialize: function serialize() {

        var isCustom = created.customCheck.checked;
        var data = false;

        if (isCustom && created.dateInput.value !== '') data = created.dateInput.value.trim();

        return {

            created_at: data

        };
    }
};

module.exports = created;

/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var fields = {
    start: function start() {

        // Save elements
        fields.parentElement = document.querySelector('[data-component=custom_fields]');
        fields.listElement = fields.parentElement.querySelector('.custom_fields-list');
        fields.identifierInput = fields.parentElement.querySelector('#component_custom-fields_add_name');
        fields.valueInput = fields.parentElement.querySelector('#component_custom-fields_add_value');
        fields.addButton = fields.parentElement.querySelector('.add-custom_field');
        fields.templateElement = fields.parentElement.querySelector('#template_component_custom-fields_field').childNodes[0];

        _Utils2.default.registerEvents([{
            // Delegate click events
            event: 'click',
            element: fields.parentElement,
            content: function content(event) {

                var target = event.target;

                // Add custom field
                if (target.matches('.add-custom_field')) fields.addField();

                // Edit custom field
                else if (target.matches('.edit-custom_field')) {

                        var item = target.parentNode;

                        fields.identifierInput.value = item.childNodes[0].innerText.trim();
                        fields.valueInput.value = item.childNodes[1].innerText.trim();

                        fields.listElement.removeChild(item);
                        fields.identifierInput.focus();

                        _Global2.default.packery.reloadItems();
                    }

                    // Remove custom field
                    else if (target.matches('.remove-custom_field')) {

                            fields.listElement.removeChild(target.parentNode);
                            fields.identifierInput.focus();

                            _Global2.default.packery.reloadItems();
                        }
            }
        }, {
            // Allow submit with Enter key
            event: 'keydown',
            element: fields.valueInput,
            content: function content(event) {

                if (event.keyCode && event.keyCode === 13) fields.addButton.click();
            }
        }]);
    },
    resume: function resume() {
        var _this = this;

        // Save current instance
        var data = this.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var fields = JSON.parse(data).custom_fields;

        if (fields === null) return true;

        Object.keys(fields).map(function (key) {

            _this.addField(key, fields[key]);
        });
    },
    addField: function addField(id, val) {

        var identifier = id || fields.identifierInput.value.trim();
        var value = val || fields.valueInput.value.trim();

        if (identifier === '' || value === '') return true;

        if (fields.serialize().custom_fields[identifier]) {

            fields.identifierInput.value = '';
            fields.identifierInput.focus();
            fields.valueInput.value = '';

            return true;
        }

        var template = fields.templateElement.cloneNode(true);
        template.childNodes[0].innerText = identifier;
        template.childNodes[1].innerText = value;

        fields.listElement.insertBefore(template, fields.listElement.childNodes[0]);

        id || fields.identifierInput.focus();
        fields.identifierInput.value = '';
        fields.valueInput.value = '';

        _Global2.default.packery.reloadItems();
    },
    validate: function validate() {

        return true;
    },
    serialize: function serialize() {

        var fieldElements = fields.listElement.childNodes;
        var data = {};

        Array.from(fieldElements).map(function (fieldElement) {

            data[fieldElement.childNodes[0].innerText.trim()] = fieldElement.childNodes[1].innerText.trim();
        });

        return {

            custom_fields: data

        };
    }
};

module.exports = fields;

/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var excerpt = {
    start: function start() {

        // Save elements
        excerpt.parentElement = document.querySelector('[data-component=excerpt]');
        excerpt.inputElement = excerpt.parentElement.querySelector('textarea');
        excerpt.excerptBox = document.querySelector('.header-description');

        _Utils2.default.registerEvent({

            event: 'keydown keyup change',
            element: excerpt.inputElement,
            content: function content(event) {

                var value = event.target.value.trim();
                var length = value.length;

                if (length > 36) value = value.substr(0, 36) + '...';

                excerpt.excerptBox.innerText = value;
            }

        });
    },
    resume: function resume() {

        // Save current instance
        var data = excerpt.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var object = JSON.parse(data);
        excerpt.inputElement.value = object.excerpt;

        _Utils2.default.triggerEvent(excerpt.inputElement, 'change');
    },
    validate: function validate() {

        var data = excerpt.serialize().excerpt;

        return data.length < 361;
    },
    serialize: function serialize() {

        return {
            excerpt: excerpt.inputElement.value.trim()
        };
    }
};

module.exports = excerpt;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var gallery = {

    data: {},

    validate: function validate() {
        return true;
    },
    serialize: function serialize() {
        return gallery.data;
    },
    resumeInline: function resumeInline(identifier, element, resumeData) {

        gallery.create(identifier, element);

        resumeData.gallery.forEach(function (image) {
            gallery.onSelect(identifier, element, image, true);
        });
    },
    validateInput: function validateInput(identifier, element, path, onSuccess) {

        if (!/[(http(s)?):\/\/(www\.)?a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)/.test(path)) {
            _Utils2.default.showValidationResults(element, 'COMPONENT_URL_INVALID', false);
            return false;
        }

        var promise = new Promise(function (resolve, reject) {
            var image = new Image();
            image.onload = function () {
                resolve(true);
            };
            image.onerror = function () {
                resolve(false);
            };
            image.src = path;
        });

        promise.then(function (result) {

            if (result) {
                _Utils2.default.showValidationResults(element, '', true);
                if (onSuccess) onSuccess(identifier, element, path, true);
                return true;
            }

            _Utils2.default.showValidationResults(element, 'COMPONENT_URL_INVALID', false);
        });
    },
    onSelect: function onSelect(identifier, element, path, outside) {

        var contentElement = element.querySelector('div.gallery-items');
        contentElement.classList.remove('no-padding');

        // Create source link
        if (!outside) path = 'app/Data/Files/Images/' + path;

        // Check gallery data
        if (gallery.data[identifier]) {

            if (~gallery.data[identifier].gallery.indexOf(path)) {

                _Global2.default.closeMediaManager();
                return false;
            }

            gallery.data[identifier].gallery.push(path);
        } else gallery.data[identifier] = {
            title: '',
            gallery: [path],
            disabled: 0
        };

        // Create template
        if (!gallery.templateElement) gallery.templateElement = element.querySelector('#template_component_gallery_item').children[0].cloneNode(true);

        var template = gallery.templateElement.cloneNode(true);

        template.setAttribute('data-path', path);
        template.classList.add('component-instance');

        template.children[0].children[0].setAttribute('src', path);
        template.children[0].children[0].setAttribute('alt', path);

        // Remove image
        template.children[1].addEventListener('click', function () {

            contentElement.removeChild(template);

            for (var i = 0; i < gallery.data[identifier].gallery.length; ++i) {

                if (gallery.data[identifier].gallery[i] === path) gallery.data[identifier].gallery.splice(i, 1);
            }
        });

        // Show image
        contentElement.appendChild(template);

        // Hide Media manager
        if (!outside) document.querySelector('div.media-manager span.close-manager').click();
    },
    create: function create(identifier, element) {

        _Utils2.default.registerEvents([{
            // Open Media Manager
            event: 'click',
            element: element.querySelector('button.inline-image_manager'),
            content: function content() {

                _Global2.default.managerActiveInstance = new _Global2.default.MediaManager({
                    manager: 'images',
                    onSelect: function onSelect(path) {
                        gallery.onSelect(identifier, element, path, false);
                    }
                });
            }
        }, {
            // Enter custom URL to image
            event: 'keypress',
            element: element.querySelector('input[name=component_inline_picture_input]'),
            content: function content(event) {

                if (event.keyCode && event.keyCode === 13) {

                    var path = event.target.value.trim();

                    gallery.validateInput(identifier, element, path, gallery.onSelect);
                }
            }
        }, {
            // Validate image URL
            event: 'change keyup',
            element: element.querySelector('input[name=component_inline_picture_input]'),
            content: function content(event) {

                gallery.validateInput(identifier, element, event.target.value.trim());
            }
        }]);
    }
};

module.exports = gallery;

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var header = {
    start: function start() {

        // Save elements
        header.parentElement = document.querySelector('[data-component=header_image]');
        header.inputBox = header.parentElement.querySelector('.input-box');
        header.mediaButton = header.inputBox.querySelector('.image_manager');
        header.mediaInput = header.inputBox.querySelector('input');
        header.messageElement = header.inputBox.querySelector('.validate-message');
        header.templateElement = header.parentElement.querySelector('#template_component_header-image_image').childNodes[0];

        // Events
        _Utils2.default.registerEvents([{
            // Delegate click events
            event: 'click',
            element: header.parentElement,
            content: function content(event) {

                // Open MediaManager
                if (event.target.matches('.image_manager')) {

                    _Global2.default.managerActiveInstance = new _Global2.default.MediaManager({
                        manager: 'images',
                        onSelect: function onSelect(path) {

                            header.addNew(path, false);
                        }
                    });
                }

                // Remove header image
                else if (event.target.matches('.header_image-remove')) {

                        header.inputBox.classList.remove('hide');

                        header.parentElement.removeChild(header.parentElement.querySelector('div.component-instance'));

                        _Global2.default.packery.reloadItems();
                    }
            }
        }, {
            // Enter custom URL to image
            event: 'keypress',
            element: header.mediaInput,
            content: function content(event) {

                if (!event.keyCode || event.keyCode !== 13) return false;

                var path = event.target.value.trim();

                header.validateInput(path, function () {

                    header.addNew(path, true);
                });
            }
        }, {
            // Real-time URL validation
            event: 'change keyup',
            element: header.mediaInput,
            content: function content(event) {

                header.validateInput(event.target.value.trim());
            }
        }]);
    },
    resume: function resume() {

        // Save current instance
        var data = header.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var headerImage = JSON.parse(data).header_image;

        if (headerImage === '') return true;

        header.addNew(headerImage, !~headerImage.indexOf('app/Data/Files/Images/'));
    },
    removeCurrent: function removeCurrent(parent) {

        if (parent.querySelector('div.header_image-image.component-instance')) parent.removeChild(parent.querySelector('div.header_image-image.component-instance'));
    },


    // --------------------------------------------------------

    addNew: function addNew(path, outside) {

        path = path.replace('app/Data/Files/Images/', '');

        var text = path;
        var template = header.templateElement.cloneNode(true);

        header.removeCurrent(header.parentElement);
        header.inputBox.value = '';

        if (!outside) path = 'app/Data/Files/Images/' + path;

        template.setAttribute('data-path', path);
        template.classList.add('component-instance');

        template.childNodes[0].setAttribute('src', path);
        template.childNodes[0].setAttribute('alt', path);

        template.childNodes[1].innerText = text;

        header.parentElement.appendChild(template);

        header.inputBox.classList.add('hide');

        _Utils2.default.closeMediaManager();
        _Global2.default.packery.reloadItems();
    },


    // ---------------------------------------

    validateInput: function validateInput(path, onSuccess, onError) {

        if (!_Utils2.default.validateUrl(path)) return _Utils2.default.showValidationResults(header.messageElement, 'COMPONENT_URL_INVALID', false, _Global2.default.packery.reloadItems);

        new Promise(function (resolve) {

            var image = new Image();

            image.onload = function () {
                resolve(true);
            };

            image.onerror = function () {
                resolve(false);
            };

            image.src = path;
        }).then(function (result) {

            if (result) {

                _Utils2.default.showValidationResults(header.messageElement, 'COMPONENT_URL_INVALID', true, _Global2.default.packery.reloadItems);

                if (onSuccess) onSuccess();
            } else {

                _Utils2.default.showValidationResults(header.messageElement, 'COMPONENT_URL_INVALID', false, _Global2.default.packery.reloadItems);

                if (onError) onError();
            }
        });
    },
    validate: function validate() {

        return true;
    },
    serialize: function serialize() {

        var instance = header.parentElement.querySelector('div.header_image-image.component-instance');
        var data = '';

        if (instance) data = instance.getAttribute('data-path');

        return {
            header_image: data
        };
    }
};

module.exports = header;

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var heading = {

    data: {},
    elements: {},

    start: function start() {

        // Save elements
        heading.templateElement = document.querySelector('#component_heading_template').children[0];
        heading.resumeData = heading.templateElement.getAttribute('data-resume');
    },
    resumeInline: function resumeInline(identifier, element, resumeData) {

        heading.create(identifier, element, function (data, elements) {

            elements.inputElement.value = resumeData.value.trim();
            _Utils2.default.triggerEvent(elements.inputElement, 'change');

            elements.typeOptions[+resumeData.type - 1].click();
        });
    },
    create: function create(identifier, element, callback) {

        heading.data[identifier] = {
            title: '',
            type: '1',
            value: '',
            disabled: 0
        };

        heading.elements[identifier] = {
            typeOptions: element.querySelectorAll('div.heading-types span'),
            inputElement: element.querySelector('input[name=component_inline_heading]')
        };

        var data = heading.data[identifier];
        var elements = heading.elements[identifier];

        _Utils2.default.registerEvents([{
            // Serialize input element
            event: 'change keyup',
            element: elements.inputElement,
            content: function content(event) {

                data.value = event.target.value.trim();
            }
        }, {
            // Heading type switcher
            event: 'click',
            element: elements.typeOptions,
            content: function content(event) {

                elements.typeOptions.forEach(function (item) {
                    item.classList.remove('type-selected');
                });

                event.target.classList.add('type-selected');
                data.type = event.target.getAttribute('data-heading').trim();
            }
        }]);

        if (callback) callback(data, elements);
    },
    validate: function validate() {

        return true;
    },
    serialize: function serialize() {

        return heading.data;
    }
};

module.exports = heading;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.languages = {

    start: function start() {

        // Load languages
        languages = getJson('app/Config/languages.json');
        var listElement = document.querySelector('div.languages-list');
        var targetSelect = document.querySelector('select[name=write_current_language]');

        var _loop = function _loop(abbr) {
            var template = document.querySelector('#template_component_languages_item').childNodes[0].cloneNode(true);
            var localeString = 'LANGUAGE_' + languages[abbr].toUpperCase().split(';')[0];
            template.setAttribute('data-language', abbr);
            template.childNodes[0].setAttribute('data-locale', localeString);
            template.childNodes[0].innerText = languages[abbr];
            listElement.appendChild(template);

            // Add language
            template.childNodes[1].addEventListener('click', function () {
                var currentOptions = targetSelect.children;
                for (var i = 0; i < currentOptions.length; ++i) {
                    if (currentOptions[i].getAttribute('data-locale') === localeString) return false;
                }var newOption = document.createElement('option');
                newOption.setAttribute('value', abbr);
                newOption.setAttribute('data-locale', localeString);
                newOption.innerText = languages[abbr];
                targetSelect.appendChild(newOption);
                selector.destroy();
                selector = new Selector({
                    selector: 'select.selector-search-select'
                });
                template.childNodes[1].classList.add('hide');
                template.childNodes[2].classList.remove('hide');
                if (componentsModule.modules.languages.data.languages.indexOf(abbr) === -1) componentsModule.modules.languages.data.languages.push(abbr);
                // ...
            });

            // Remove language
            template.childNodes[2].addEventListener('click', function () {
                var actionTextLocale = translate.locale.system[localeString];
                if (typeof actionTextLocale === 'undefined') actionTextLocale = languages[abbr];
                var actionText = translate.locale.response['ACTION_CONFIRM_REMOVE_LANGUAGE'].replace('%language%', actionTextLocale);
                confirmAction(actionText, function () {
                    var option = targetSelect.querySelector('option[data-locale=' + localeString + ']');
                    if (option.getAttribute('selected')) targetSelect.children[0].setAttribute('selected', 'true');
                    targetSelect.removeChild(option);
                    selector.destroy();
                    selector = new Selector({
                        selector: 'select.selector-search-select'
                    });
                    template.childNodes[2].classList.add('hide');
                    template.childNodes[1].classList.remove('hide');
                    if (componentsModule.modules.languages.data.languages.indexOf(abbr) !== -1) componentsModule.modules.languages.data.languages.splice(componentsModule.modules.languages.data.languages.indexOf(abbr), 1);
                    // ...
                });
            });
        };

        for (var abbr in languages) {
            _loop(abbr);
        }

        translate.addTranslation(['system']);
    },

    data: {
        languages: []
    },

    validate: function validate() {},

    serialize: function serialize() {
        return componentsModule.modules.languages.data.languages;
    },

    events: [{
        // Search in languages list
        event: "change keyup",
        element: document.querySelector('input[name=component_language_search]'),
        content: function content(event) {
            var searchPhrase = event.target.value.toLowerCase();
            var searchPhraseLength = searchPhrase.length;
            var listElements = document.querySelector('div.languages-list').childNodes;
            var listElementsLength = listElements.length;
            // Search by abbr
            if (searchPhraseLength < 3) {
                for (var i = 0; i < listElementsLength; ++i) {
                    var abbr = listElements[i].getAttribute('data-language').substring(0, searchPhraseLength).toLowerCase();
                    if (abbr === searchPhrase) listElements[i].classList.remove('hide');else listElements[i].classList.add('hide');
                }
                packery.packery().reloadItems();
                return true;
            }
            // Search by name
            for (var _i = 0; _i < listElementsLength; ++_i) {
                var _abbr = listElements[_i].childNodes[0].innerText.substring(0, searchPhraseLength).toLowerCase();
                if (_abbr === searchPhrase) listElements[_i].classList.remove('hide');else listElements[_i].classList.add('hide');
            }
            packery.packery().reloadItems();
        }
    }]

};

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var updated = {
    start: function start() {

        // Save elements
        updated.parentElement = document.querySelector('[data-component=last_update]');
        updated.customCheck = updated.parentElement.querySelector('[name=component_last-update]');
        updated.dateBox = updated.parentElement.querySelector('.component_last_custom');
        updated.dateInput = updated.dateBox.querySelector('input');
        updated.clearInput = updated.dateBox.querySelector('.clear-input');

        updated.customCheck.checked = false;

        // Events
        _Utils2.default.registerEvents([{
            // Show / Hide custom input
            event: 'change',
            element: updated.customCheck,
            content: function content() {

                if (updated.customCheck.checked) updated.dateBox.classList.remove('hide');else updated.dateBox.classList.add('hide');

                _Global2.default.packery.reloadItems();
            }
        }, {
            // Clear input
            event: 'click',
            element: updated.clearInput,
            content: function content() {

                updated.dateInput.value = '';
            }
        }]);
    },
    resume: function resume() {

        // Save current instance
        var data = this.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        this.dateInput.value = JSON.parse(data).last_update;
        _Utils2.default.triggerEvent(this.customCheck, 'click');
    },
    validate: function validate() {

        return true;
    },
    serialize: function serialize() {

        var isCustom = updated.customCheck.checked;
        var data = false;

        if (isCustom && updated.dateInput.value !== '') data = updated.dateInput.value.trim();

        return {

            last_update: data

        };
    }
};

module.exports = updated;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var link = {

    data: {},

    resumeInline: function resumeInline(identifier, element, resumeData) {

        link.create(identifier, element, resumeData);
    },
    createSelector: function createSelector(identifier) {

        setTimeout(function () {

            new _Global2.default.Selector({

                element: 'select[name="' + identifier + '"]',
                selected: function selected(instance, option) {
                    link.data[identifier].link_target = +option.trim();
                }
            });
        });
    },
    create: function create(identifier, element, resumeData) {

        // Initialize Data
        link.data[identifier] = {
            title: '',
            link: '',
            link_text: '',
            link_position: 1,
            link_target: 0,
            disabled: 0
        };

        var select = element.querySelector('select[name=component_inline_link_target]');
        var positionItems = element.querySelectorAll('span.position-item');
        var linkInput = element.querySelector('input[name=component_inline_link_url]');
        var linkName = element.querySelector('input[name=component_inline_link_name]');

        if (resumeData) {

            if (resumeData.link) link.data[identifier].link = linkInput.value = resumeData.link.trim();

            if (resumeData.link_text) link.data[identifier].link_text = linkName.value = resumeData.link_text.trim();

            if (resumeData.link_position !== undefined) {

                link.data[identifier].link_position = resumeData.link_position;

                positionItems.forEach(function (item) {

                    if (item.matches('[data-position="' + resumeData.link_position + '"]')) {

                        item.classList.add('active');
                        return true;
                    }

                    item.classList.remove('active');
                });
            }

            if (resumeData.link_target !== undefined) {

                var selected = select.querySelector('[selected]');

                selected.removeAttribute('selected');
                select.children[resumeData.link_target].setAttribute('selected', 'true');
            }
        }

        // Initialize target Selector
        select.setAttribute('name', identifier);
        link.createSelector(identifier);

        _Utils2.default.registerEvents([{
            // Serialize link
            event: 'change keyup',
            element: linkInput,
            content: function content(event) {
                link.data[identifier].link = event.target.value.trim();
            }
        }, {
            // Serialize link text
            event: 'change keyup',
            element: linkName,
            content: function content(event) {
                link.data[identifier].link_text = event.target.value.trim();
            }
        }, {
            // Serialize position component
            event: 'click',
            element: positionItems,
            content: function content(event) {

                link.data[identifier].link_position = event.target.getAttribute('data-position');

                positionItems.forEach(function (item) {
                    item.classList.remove('active');
                });

                event.target.classList.add('active');
            }
        }]);
    },
    validate: function validate() {
        return true;
    },
    serialize: function serialize() {
        return link.data;
    }
};

module.exports = link;

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

var _sortablejs = __webpack_require__(11);

var _sortablejs2 = _interopRequireDefault(_sortablejs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var list = {

    data: {},
    itemClone: false,

    validate: function validate() {
        return true;
    },
    serialize: function serialize() {
        return list.data;
    },
    resumeInline: function resumeInline(identifier, element, resumeData) {

        var listElement = list.create(identifier, element, resumeData);

        resumeData.list.forEach(function (listItem, index) {

            if (listItem === '') return true;

            var checked = resumeData.list_checked[index] || 0;

            list.createItem(identifier, listElement, undefined, false, [listItem.trim(), checked]);
        });

        if (list.data[identifier].list.length < 1) list.createItem(identifier, listElement);
    },
    reloadItems: function reloadItems(identifier, listElement) {

        var newOrder = [];
        var newContent = [];
        var newChecked = [];

        listElement.querySelectorAll('.list-item').forEach(function (item, key) {

            newOrder.push(parseFloat(item.getAttribute('data-item')));
            item.querySelector('.item-number').innerText = +key + 1 + '.';

            var text = item.querySelector('p').innerText.trim();

            if (text === list.itemClone.querySelector('p').innerText.trim()) text = '';

            newContent.push(text);
            newChecked.push(item.querySelector('.item-check').classList.contains('checked'));
        });

        list.data[identifier].list = newContent;
        list.data[identifier].list_checked = newChecked;
        list.data[identifier].order = newOrder;
    },
    createItem: function createItem(identifier, listElement, after, focus, data) {

        if (!data) data = [];

        var itemID = Math.random() * (99999 - 10000) + 10000;

        // Create item data
        var index = void 0;
        var checked = data[1] || false;
        var value = data[0] || '';

        if (!after) {

            list.data[identifier].list.push(value);
            list.data[identifier].list_checked.push(checked);
            list.data[identifier].order.push(itemID);
            index = +list.data[identifier].order.indexOf(itemID);
        } else {

            index = +list.data[identifier].order.indexOf(after);

            if (index === -1) return false;

            index += 1;
            list.data[identifier].list.splice(index, 0, value);
            list.data[identifier].list_checked.splice(index, 0, checked);
            list.data[identifier].order.splice(index, 0, itemID);
        }

        // Create item clone
        var itemElement = list.itemClone.cloneNode(true);
        itemElement.setAttribute('data-item', itemID.toString());
        itemElement.querySelector('.item-number').innerText = +index + 1 + '.';

        var itemText = itemElement.querySelector('p');
        var itemCheck = itemElement.querySelector('.item-check');

        // Create item events
        _Utils2.default.registerEvents([{
            // Check item
            event: 'click',
            element: itemCheck,
            content: function content(event) {
                event.target.classList.toggle('checked');
                var index = list.data[identifier].order.indexOf(itemID);
                list.data[identifier].list_checked[index] = event.target.classList.contains('checked');
            }
        }, {
            // Focus hide placeholder
            event: 'focus',
            element: itemText,
            content: function content(event) {

                var target = event.target;

                if (target.innerText.trim() !== list.itemClone.querySelector('p').innerText) return false;

                target.classList.remove('item-text-placeholder');
                target.innerText = '';
            }
        }, {
            // Blur add placeholder
            event: 'blur',
            element: itemText,
            content: function content(event) {

                var target = event.target;
                var nextItem = target.parentNode.nextSibling;

                if (target.innerText.trim() !== '' && nextItem === null) list.createItem(identifier, listElement, itemID, true);

                if (target.innerText.trim() !== '') return false;

                target.classList.add('item-text-placeholder');
                target.innerText = list.itemClone.querySelector('p').innerText;
            }
        }, {
            // Add item after
            event: 'keydown',
            element: itemText,
            content: function content(event) {

                if (event.keyCode !== 13) return false;

                var currentItem = event.target.parentNode;
                var nextItem = currentItem.nextSibling;

                if (nextItem !== null) nextItem.querySelector('p').focus();else event.target.blur();

                event.preventDefault();
            }
        }, {
            // Serialize item
            event: 'keyup change',
            element: itemText,
            content: function content(event) {

                list.data[identifier].list[index] = event.target.innerText.trim();
            }
        }, {
            // Delete item
            event: 'click',
            element: itemElement.querySelector('.list-item-delete'),
            content: function content() {

                if (listElement.children.length < 2) return false;

                var index = list.data[identifier].order.indexOf(itemID);

                if (index === -1) return false;

                list.data[identifier].list.splice(index, 1);
                list.data[identifier].order.splice(index, 1);
                list.data[identifier].list_checked.splice(index, 1);

                listElement.removeChild(itemElement);
                list.reloadItems(identifier, listElement);
            }
        }]);

        // Show item
        if (!after) listElement.appendChild(itemElement);else {

            if (!list.data[identifier].order[index + 1]) listElement.appendChild(itemElement);else listElement.insertBefore(itemElement, listElement.children[index + 1]);
        }

        // Resume data
        itemText.innerText = data[0] || itemText.innerText;

        if (data[0] !== undefined) itemText.classList.remove('item-text-placeholder');

        if (data[1] === 1) itemCheck.click();

        // Focus
        if (focus) itemText.focus();
    },
    create: function create(identifier, element, resumeData) {

        var contentElement = element.querySelector('.component-element-content');
        var listElement = contentElement.querySelector('.component-inline-list-content');
        var listItem = listElement.querySelector('.list-item');

        if (!list.itemClone) list.itemClone = listItem.cloneNode(true);

        listElement.removeChild(listItem);

        // Data
        list.data[identifier] = {
            title: '',
            disabled: 0,
            list: [],
            order: [],
            list_checked: [],
            list_title: '',
            list_type: 0,
            list_position: 1
        };

        // Drag & Drop
        _sortablejs2.default.create(listElement, {
            sort: true,
            animation: 200,
            scroll: false,
            draggable: '.list-item',
            handle: '.list-item-move',
            onStart: function onStart(event) {
                event.item.classList.add('chosen');
            },
            onEnd: function onEnd(event) {
                event.item.classList.remove('chosen');
                list.reloadItems(identifier, listElement);
            }
        });

        // Events
        var typeItems = contentElement.querySelectorAll('.component-list_type .position-item');
        var positionItems = contentElement.querySelectorAll('.component-list_align .position-item');
        var nameInput = contentElement.querySelector('input[name=component_inline_list_name]');

        _Utils2.default.registerEvents([{
            // Serialize list title
            event: 'change keyup',
            element: nameInput,
            content: function content(event) {
                list.data[identifier].list_title = event.target.value.trim();
            }
        }, {
            // Serialize list type
            event: 'click',
            element: typeItems,
            content: function content(event) {
                listElement.setAttribute('data-type', list.data[identifier].list_type = event.target.getAttribute('data-position'));
                typeItems.forEach(function (item) {
                    item.classList.remove('active');
                });
                event.target.classList.add('active');
            }
        }, {
            // Serialize list align
            event: 'click',
            element: positionItems,
            content: function content(event) {
                list.data[identifier].list_position = event.target.getAttribute('data-position');
                positionItems.forEach(function (item) {
                    item.classList.remove('active');
                });
                event.target.classList.add('active');
            }
        }]);

        if (resumeData !== undefined) {

            nameInput.value = resumeData.list_title.trim();
            _Utils2.default.triggerEvent(nameInput, 'change');

            typeItems[+resumeData.list_type].click();
            positionItems[+resumeData.list_position].click();
        }

        // First item
        if (!resumeData) list.createItem(identifier, listElement);

        return listElement;
    }
};

module.exports = list;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var meta = {
    start: function start() {

        // Save elements
        meta.parentElement = document.querySelector('[data-component=meta]');
        meta.customCheck = meta.parentElement.querySelector('[name=component_meta_manually]');
        meta.customBox = meta.parentElement.querySelector('.component_meta_custom');
        meta.keyInput = meta.parentElement.querySelector('[name=component_meta_keywords]');
        meta.descInput = meta.parentElement.querySelector('[name=component_meta_description]');
        meta.robotsSelect = meta.parentElement.querySelector('[name=component_meta_robots]');

        meta.customCheck.checked = false;

        // Selector
        meta.selector = meta.createSelector();

        // Events
        _Utils2.default.registerEvent({

            event: 'change',
            element: meta.customCheck,
            content: function content() {

                if (meta.customCheck.checked) meta.customBox.classList.remove('hide');else meta.customBox.classList.add('hide');

                _Global2.default.packery.reloadItems();
            }
        });
    },
    createSelector: function createSelector() {

        return new _Global2.default.Selector({
            element: '[name=component_meta_robots]',
            opened: _Global2.default.packery.reloadItems,
            closed: _Global2.default.packery.reloadItems
        });
    },
    resume: function resume() {

        // Save current instance
        var data = this.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var meta = JSON.parse(data);

        this.customCheck.checked = !!meta.meta;
        _Utils2.default.triggerEvent(this.customCheck, 'change');

        this.keyInput.value = meta.meta_keywords.trim();
        this.descInput.value = meta.meta_description.trim();

        var selectOptions = this.robotsSelect.querySelectorAll('option');

        Object.values(selectOptions).forEach(function (selectOption, index) {

            if (index !== meta.meta_robots) selectOption.removeAttribute('selected');else selectOption.setAttribute('selected', 'true');
        });

        this.selector.destroy();
        this.selector = this.createSelector();
    },
    validate: function validate() {

        return true;
    },
    serialize: function serialize() {

        return {

            meta: meta.customCheck.checked,
            meta_keywords: meta.keyInput.value.trim(),
            meta_description: meta.descInput.value.trim(),
            meta_robots: parseInt(meta.robotsSelect.querySelector('[selected=true]').getAttribute('value'))

        };
    }
};

module.exports = meta;

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var mistakes = {

    start: function start() {

        // Save elements
        mistakes.parentElement = document.querySelector('[data-component=mistakes]');
        mistakes.enableCheck = mistakes.parentElement.querySelector('[name=component_mistakes]');
        mistakes.notifyBox = mistakes.parentElement.querySelector('.component_mistakes_notify');
        mistakes.notifyCheck = mistakes.notifyBox.querySelector('[name=component_mistakes_notify]');
        mistakes.emailBox = mistakes.notifyBox.querySelector('div');
        mistakes.emailCheck = mistakes.emailBox.querySelector('input');

        // Delegate change event
        _Utils2.default.registerEvent({

            event: 'change',
            element: mistakes.parentElement,
            content: function content(event) {

                var target = event.target;

                // Show notifications settings
                if (target === mistakes.enableCheck) {

                    if (!!target.checked) mistakes.notifyBox.classList.remove('hide');else mistakes.notifyBox.classList.add('hide');

                    _Global2.default.packery.reloadItems();
                }

                // Show email notifications settings
                else if (target === mistakes.notifyCheck) {

                        if (!!target.checked) mistakes.emailBox.classList.remove('hide');else mistakes.emailBox.classList.add('hide');

                        _Global2.default.packery.reloadItems();
                    }
            }

        });
    },

    resume: function resume() {

        // Save current instance
        var data = this.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var mistakes = JSON.parse(data);

        this.enableCheck.checked = !!mistakes.mistakes;
        _Utils2.default.triggerEvent(this.enableCheck, 'change');

        this.emailCheck.checked = !!mistakes.mistakes_email;

        this.notifyCheck.checked = !!mistakes.mistakes_notify;
        _Utils2.default.triggerEvent(this.notifyCheck, 'change');
    },

    validate: function validate() {

        return true;
    },

    serialize: function serialize() {

        return {

            mistakes: !!mistakes.enableCheck.checked,
            mistakes_notify: !!mistakes.notifyCheck.checked,
            mistakes_email: !!mistakes.emailCheck.checked

        };
    }

};

module.exports = mistakes;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var note = {

    data: {},

    resumeInline: function resumeInline(identifier, element, resumeData) {

        note.create(identifier, element, resumeData);
    },
    validate: function validate() {
        return true;
    },
    serialize: function serialize() {
        return note.data;
    },
    create: function create(identifier, element, resumeData) {

        var positionItems = element.querySelectorAll('span.position-item');
        var textarea = element.querySelector('textarea[name=component_inline_note]');

        note.data[identifier] = {
            title: '',
            note: '',
            note_position: 1,
            disabled: 0
        };

        _Utils2.default.registerEvents([{
            // Serialize textarea
            event: 'change keyup',
            element: textarea,
            content: function content(event) {
                note.data[identifier].note = event.target.value.trim();
            }
        }, {
            // Serialize position
            event: 'click',
            element: positionItems,
            content: function content(event) {
                note.data[identifier].note_position = event.target.getAttribute('data-position');
                positionItems.forEach(function (item) {
                    item.classList.remove('active');
                });
                event.target.classList.add('active');
            }
        }]);

        if (resumeData) {

            if (resumeData.note) {

                textarea.value = resumeData.note.trim();
                _Utils2.default.triggerEvent(textarea, 'change');
            }

            if (resumeData.note_position !== undefined) positionItems[resumeData.note_position].click();
        }
    }
};

module.exports = note;

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var perex = {

    start: function start() {

        // Save elements
        perex.parentElement = document.querySelector('[data-component=perex]');
        perex.dateInput = perex.parentElement.querySelector('[name=component_perex_date]');
        perex.locationInput = perex.parentElement.querySelector('[name=component_perex_location]');

        // Clear date input
        _Utils2.default.registerEvent({

            event: 'click',
            element: perex.parentElement.querySelector('.clear-perex-date'),
            content: function content() {
                perex.dateInput.value = '';
            }

        });
    },

    resume: function resume() {

        // Save current instance
        var data = perex.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var object = JSON.parse(data);

        perex.dateInput.value = object.perex_date;
        perex.locationInput.value = object.perex_location;

        _Utils2.default.triggerEvent(perex.locationInput, 'change');
    },

    validate: function validate() {

        var data = perex.serialize().perex_location;

        return data.length < 121;
    },

    serialize: function serialize() {

        return {
            perex_date: perex.dateInput.value.trim(),
            perex_location: perex.locationInput.value.trim()
        };
    }

};

module.exports = perex;

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var picture = {

    data: {},
    elements: {},

    start: function start() {

        // Save elements
        picture.contentElement = document.querySelector('.content-wrapper');
        picture.templateElement = picture.contentElement.querySelector('#template_component_content_picture_image').children[0];
    },
    resumeInline: function resumeInline(identifier, element, resumeData) {

        var path = resumeData.picture;
        picture.create(identifier, element);

        picture.onSelect(identifier, element, path, true, function (description, align) {

            description.value = resumeData.picture_description.trim();
            _Utils2.default.triggerEvent(description, 'change');

            align[resumeData.picture_align].click();
        });
    },
    validateInput: function validateInput(path, identifier, onSuccess, onError) {

        var elements = picture.elements[identifier];

        if (!_Utils2.default.validateUrl(path)) return _Utils2.default.showValidationResults(elements.messageBox, 'COMPONENT_URL_INVALID', false);

        new Promise(function (resolve) {

            var image = new Image();

            image.onload = function () {
                resolve(true);
            };

            image.onerror = function () {
                resolve(false);
            };

            image.src = path;
        }).then(function (result) {

            if (result) {

                _Utils2.default.showValidationResults(elements.messageBox, 'COMPONENT_URL_INVALID', true);

                if (onSuccess) onSuccess();
            } else {

                _Utils2.default.showValidationResults(elements.messageBox, 'COMPONENT_URL_INVALID', false);

                if (onError) onError();
            }
        });
    },
    removeCurrent: function removeCurrent(element) {

        var instance = element.querySelector('div.component-instance span.picture-remove');

        if (instance) instance.click();
    },
    onSelect: function onSelect(identifier, element, path, outside, callback) {

        var elements = picture.elements[identifier];
        elements.contentElement.classList.add('no-padding');

        // Remove current image
        picture.removeCurrent(element);

        // Create source link
        if (!outside) path = 'app/Data/Files/Images/' + path;

        // Save image path
        picture.data[identifier] = {
            picture: path,
            picture_description: '',
            picture_align: 1
        };

        // Create template
        var template = picture.templateElement.cloneNode(true);

        template.setAttribute('data-path', path);
        template.classList.add('component-instance');

        template.children[0].setAttribute('src', path);
        template.children[0].setAttribute('alt', path);

        elements.contentElement.appendChild(template);

        // Hide media manager
        template.children[0].addEventListener('load', function () {

            _Utils2.default.closeMediaManager();
            elements.inputBox.classList.add('hide');
        });

        var alignOptions = Array.from(template.children[3].children);

        _Utils2.default.registerEvents([{
            // Serialize description
            event: 'change keyup',
            element: template.children[2],
            content: function content(event) {

                picture.data[identifier].picture_description = event.target.value.trim();
            }
        }, {
            // Align picture
            event: 'click',
            element: alignOptions,
            content: function content(event) {

                picture.data[identifier].picture_align = +event.target.getAttribute('data-value');

                Object.values(alignOptions).forEach(function (item) {

                    item.classList.remove('active');
                });

                event.target.classList.add('active');
            }
        }]);

        // Remove image
        template.children[1].addEventListener('click', function () {

            elements.inputBox.classList.remove('hide');
            elements.contentElement.removeChild(template);
            elements.contentElement.classList.remove('no-padding');

            delete picture.data[identifier];
        });

        if (callback) callback(template.children[2], alignOptions);
    },
    create: function create(identifier, element) {

        picture.elements[identifier] = {};

        // Prepare basic data
        picture.data[identifier] = {
            title: '',
            disabled: 0
        };

        var elements = picture.elements[identifier];
        elements.parentElement = element;
        elements.contentElement = element.querySelector('div.component-element-content');
        elements.inputBox = elements.contentElement.querySelector('div.input-box.select-image');
        elements.messageBox = elements.inputBox.querySelector('.validate-message');

        _Utils2.default.registerEvents([{
            // Open Media Manager
            event: 'click',
            element: element.querySelector('button.inline-image_manager'),
            content: function content() {

                _Global2.default.managerActiveInstance = new _Global2.default.MediaManager({
                    manager: 'images',
                    onSelect: function onSelect(path) {

                        picture.onSelect(identifier, element, path, false);
                    }
                });
            }
        }, {
            // Enter custom URL to image
            event: 'keypress',
            element: element.querySelector('input[name=component_inline_picture_input]'),
            content: function content(event) {

                if (!event.keyCode || event.keyCode !== 13) return false;

                var path = event.target.value.trim();

                picture.validateInput(path, identifier, function () {

                    picture.onSelect(identifier, element, path, true);
                });
            }
        }, {
            // Real-time URL validation
            event: 'change keyup',
            element: element.querySelector('input[name=component_inline_picture_input]'),
            content: function content(event) {

                picture.validateInput(event.target.value.trim(), identifier);
            }
        }]);
    },
    validate: function validate() {

        return true;
    },
    serialize: function serialize() {

        return picture.data;
    }
};

module.exports = picture;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var pin = {

    start: function start() {

        // Save elements
        pin.parentElement = document.querySelector('[data-component=pin]');
        pin.checkElement = pin.parentElement.querySelector('input');
    },

    resume: function resume() {

        // Save current instance
        var data = pin.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var object = JSON.parse(data);
        pin.checkElement.checked = !!object.pin;
    },

    validate: function validate() {

        var data = pin.serialize().pin;

        return typeof data === 'boolean';
    },

    serialize: function serialize() {

        return {
            pin: !!pin.checkElement.checked
        };
    }

};

module.exports = pin;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var planner = {
    start: function start() {

        // Save elements
        planner.parentElement = document.querySelector('[data-component=planner');
        planner.customPublish = planner.parentElement.querySelector('.component_planner_publish_custom');
        planner.notifyBox = planner.parentElement.querySelector('.component_planner_notify_email');

        planner.publishAuto = planner.parentElement.querySelector('[name=component_planner_publish]');
        planner.publishInput = planner.parentElement.querySelector('[name=component_planner_publish_datetime]');
        planner.expiryInput = planner.parentElement.querySelector('[name=component_planner_publish_expiry]');
        planner.plannerNotify = planner.parentElement.querySelector('[name=component_planner_notify]');
        planner.notifyEmail = planner.parentElement.querySelector('[name=component_planner_notify_email]');

        // Events
        _Utils2.default.registerEvents([{
            // Delegate change events
            event: 'change',
            element: planner.parentElement,
            content: function content(event) {

                var target = event.target;

                // Auto-publication change
                if (target === planner.publishAuto) {

                    if (target.checked) planner.customPublish.classList.add('hide');else planner.customPublish.classList.remove('hide');

                    _Global2.default.packery.reloadItems();
                }

                // Notification change
                else if (target === planner.plannerNotify) {

                        if (target.checked) planner.notifyBox.classList.remove('hide');else planner.notifyBox.classList.add('hide');

                        _Global2.default.packery.reloadItems();
                    }
            }
        }, {
            // Delegate click events
            event: 'click',
            element: planner.parentElement,
            content: function content(event) {

                // Clear input
                if (event.target.matches('.clear-input')) {

                    event.target.parentNode.querySelector('input').value = '';
                }
            }
        }]);
    },
    resume: function resume() {

        // Save current instance
        var data = this.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var planner = JSON.parse(data);

        if (planner === null) return true;

        this.publishAuto.checked = !planner.planner;
        _Utils2.default.triggerEvent(this.publishAuto, 'change');

        this.publishInput.value = planner.planner_date;
        this.expiryInput.value = planner.planner_expiry;

        this.plannerNotify.checked = !!planner.planner_notify;
        _Utils2.default.triggerEvent(this.plannerNotify, 'change');

        this.notifyEmail.checked = !!planner.planner_notify_email;
    },
    validate: function validate() {

        return true;
    },
    serialize: function serialize() {

        return {

            planner: !planner.publishAuto.checked,
            planner_date: planner.publishInput.value.trim(),
            planner_expiry: planner.expiryInput.value.trim(),
            planner_notify: !!planner.plannerNotify.checked,
            planner_notify_email: !!planner.notifyEmail.checked

        };
    }
};

module.exports = planner;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

var _sortablejs = __webpack_require__(11);

var _sortablejs2 = _interopRequireDefault(_sortablejs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var poll = {

    data: {},
    itemClone: false,

    validate: function validate() {
        return true;
    },

    serialize: function serialize() {
        return poll.data;
    },

    resumeInline: function resumeInline(identifier, element, resumeData) {

        var listElement = poll.create(identifier, element, resumeData);

        resumeData.poll.forEach(function (pollItem) {

            if (pollItem === '') return true;

            poll.createItem(identifier, listElement, undefined, false, pollItem);
        });

        if (poll.data[identifier].poll.length < 1) poll.createItem(identifier, listElement);
    },

    reloadItems: function reloadItems(identifier, listElement) {

        var newOrder = [];
        var newContent = [];

        listElement.querySelectorAll('.poll-item').forEach(function (item) {
            newOrder.push(parseFloat(item.getAttribute('data-item')));
            var text = item.querySelector('p').innerText.trim();
            if (text === poll.itemClone.querySelector('p').innerText.trim()) text = '';
            newContent.push(text);
        });

        poll.data[identifier].poll = newContent;
        poll.data[identifier].order = newOrder;
    },

    createItem: function createItem(identifier, listElement, after, focus, pollItem) {

        if (!pollItem) pollItem = '';

        var itemID = Math.random() * (99999 - 10000) + 10000;
        var index = void 0;

        // Create item data
        if (!after) {

            poll.data[identifier].poll.push(pollItem);
            poll.data[identifier].order.push(itemID);
            index = +poll.data[identifier].order.indexOf(itemID);
        } else {

            index = +poll.data[identifier].order.indexOf(after);

            if (index === -1) return false;

            index += 1;
            poll.data[identifier].poll.splice(index, 0, pollItem);
            poll.data[identifier].order.splice(index, 0, itemID);
        }

        // Create item clone
        var itemElement = poll.itemClone.cloneNode(true);
        var itemText = itemElement.querySelector('p');

        itemElement.setAttribute('data-item', itemID.toString());

        // Create item events
        _Utils2.default.registerEvents([{
            // Focus hide placeholder
            event: 'focus',
            element: itemText,
            content: function content(event) {

                var target = event.target;

                if (target.innerText.trim() !== poll.itemClone.querySelector('p').innerText) return false;

                target.classList.remove('item-text-placeholder');
                target.innerText = '';
            }
        }, {
            // Blur add placeholder
            event: 'blur',
            element: itemText,
            content: function content(event) {

                var target = event.target;
                var nextItem = target.parentNode.nextSibling;

                if (target.innerText.trim() !== '' && nextItem === null) poll.createItem(identifier, listElement, itemID, true);

                if (target.innerText.trim() !== '') return false;

                target.classList.add('item-text-placeholder');
                target.innerText = poll.itemClone.querySelector('p').innerText;
            }
        }, {
            // Add item after
            event: 'keydown',
            element: itemText,
            content: function content(event) {

                if (event.keyCode !== 13) return false;

                var currentItem = event.target.parentNode;
                var nextItem = currentItem.nextSibling;

                if (nextItem !== null) nextItem.querySelector('p').focus();else event.target.blur();

                event.preventDefault();
            }
        }, {
            // Serialize item
            event: 'keyup change',
            element: itemText,
            content: function content(event) {

                poll.data[identifier].poll[index] = event.target.innerText.trim();
            }
        }, {
            // Delete item
            event: 'click',
            element: itemElement.querySelector('.poll-item-delete'),
            content: function content() {

                if (listElement.children.length < 2) return false;

                var index = poll.data[identifier].order.indexOf(itemID);

                if (index === -1) return false;

                poll.data[identifier].poll.splice(index, 1);
                poll.data[identifier].order.splice(index, 1);

                listElement.removeChild(itemElement);
                poll.reloadItems(identifier, listElement);
            }
        }]);

        // Show item
        if (!after) listElement.appendChild(itemElement);else {

            if (!poll.data[identifier].order[index + 1]) listElement.appendChild(itemElement);else listElement.insertBefore(itemElement, listElement.children[index + 1]);
        }

        // Resume data
        itemText.innerText = pollItem ? pollItem : itemText.innerText;

        if (pollItem) itemText.classList.remove('item-text-placeholder');

        // Focus
        if (focus) itemText.focus();
    },

    create: function create(identifier, element, resumeData) {

        var contentElement = element.querySelector('.component-element-content');
        var listElement = contentElement.querySelector('.component-inline-poll-content');
        var listItem = listElement.querySelector('.poll-item');

        if (!poll.itemClone) poll.itemClone = listItem.cloneNode(true);
        listElement.removeChild(listItem);

        // Data
        poll.data[identifier] = {
            title: '',
            disabled: 0,
            poll: [],
            order: [],
            poll_title: '',
            poll_type: 0,
            poll_position: 1
        };

        // Drag & Drop
        _sortablejs2.default.create(listElement, {
            sort: true,
            animation: 200,
            scroll: false,
            draggable: '.poll-item',
            handle: '.poll-item-move',
            onStart: function onStart(event) {
                event.item.classList.add('chosen');
            },
            onEnd: function onEnd(event) {
                event.item.classList.remove('chosen');
                poll.reloadItems(identifier, listElement);
            }
        });

        // Events
        var typeItems = contentElement.querySelectorAll('.component-poll_type .position-item');
        var positionItems = contentElement.querySelectorAll('.component-poll_align .position-item');
        var nameInput = contentElement.querySelector('input[name=component_inline_poll_name]');

        _Utils2.default.registerEvents([{
            // Serialize poll title
            event: 'change keyup',
            element: nameInput,
            content: function content(event) {
                poll.data[identifier].poll_title = event.target.value.trim();
            }
        }, {
            // Serialize poll type
            event: 'click',
            element: typeItems,
            content: function content(event) {
                listElement.setAttribute('data-type', poll.data[identifier].poll_type = event.target.getAttribute('data-position'));
                typeItems.forEach(function (item) {
                    item.classList.remove('active');
                });
                event.target.classList.add('active');
            }
        }, {
            // Serialize poll align
            event: 'click',
            element: positionItems,
            content: function content(event) {
                poll.data[identifier].poll_position = event.target.getAttribute('data-position');
                positionItems.forEach(function (item) {
                    item.classList.remove('active');
                });
                event.target.classList.add('active');
            }
        }]);

        if (resumeData !== undefined) {

            nameInput.value = resumeData.poll_title.trim();
            _Utils2.default.triggerEvent(nameInput, 'change');

            typeItems[+resumeData.poll_type].click();
            positionItems[+resumeData.poll_position].click();
        }

        // First item
        if (!resumeData) poll.createItem(identifier, listElement);

        return listElement;
    }

};

module.exports = poll;

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var quote = {

    data: {},

    validate: function validate() {
        return true;
    },
    serialize: function serialize() {
        return quote.data;
    },
    resumeInline: function resumeInline(identifier, element, resumeData) {

        quote.create(identifier, element, resumeData);
    },
    create: function create(identifier, element, resumeData) {

        // Create instance data
        quote.data[identifier] = {
            title: '',
            quote: '',
            quote_author: '',
            quote_position: 1,
            disabled: 0
        };

        var positionItems = element.querySelectorAll('span.position-item');
        var quoteInput = element.querySelector('textarea[name=component_inline_quote_text]');
        var authorInput = element.querySelector('input[name=component_inline_quote_author]');

        _Utils2.default.registerEvents([{
            // Serialize quote body
            event: 'change keyup',
            element: quoteInput,
            content: function content(event) {
                quote.data[identifier].quote = event.target.value.trim();
            }
        }, {
            // Serialize quote author
            event: 'change keyup',
            element: authorInput,
            content: function content(event) {
                quote.data[identifier].quote_author = event.target.value.trim();
            }
        }, {
            // Serialize position component
            event: 'click',
            element: positionItems,
            content: function content(event) {
                quote.data[identifier].quote_position = event.target.getAttribute('data-position');
                positionItems.forEach(function (item) {
                    item.classList.remove('active');
                });
                event.target.classList.add('active');
            }
        }]);

        if (resumeData) {

            if (resumeData.quote) {

                quoteInput.value = resumeData.quote.trim();
                _Utils2.default.triggerEvent(quoteInput, 'change');
            }

            if (resumeData.quote_author) {

                authorInput.value = resumeData.quote_author.trim();
                _Utils2.default.triggerEvent(authorInput, 'change');
            }

            if (resumeData.quote_position !== undefined) positionItems[resumeData.quote_position].click();
        }
    }
};

module.exports = quote;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var revisions = {
    start: function start() {

        // Save elements
        revisions.parentElement = document.querySelector('[data-component=revisions]');
        revisions.textInput = revisions.parentElement.querySelector('textarea');
        revisions.listElement = revisions.parentElement.querySelector('.revisions-list');
        revisions.templateElement = revisions.parentElement.querySelector('#template_component_revisions_item').childNodes[0];
    },
    resume: function resume() {
        var _this = this;

        // Save current instance
        var data = this.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var revisions = JSON.parse(data).revision;

        if (revisions === null) return true;

        revisions.forEach(function (revision) {

            var template = _this.templateElement.cloneNode(true);
            template.childNodes[0].innerText = revision.created_at;
            template.childNodes[1].innerText = revision.description;

            _this.listElement.appendChild(template);
        });

        this.listElement.scrollTop = this.listElement.scrollHeight;

        _Global2.default.packery.reloadItems();
    },
    validate: function validate() {

        var data = revisions.serialize().revision;

        return data.length < 251;
    },
    serialize: function serialize() {

        return {

            revision: revisions.textInput.value.trim()

        };
    }
};

module.exports = revisions;

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

var _Config = __webpack_require__(115);

var _Config2 = _interopRequireDefault(_Config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var editor = {

    data: {},
    elements: {},

    resumeInline: function resumeInline(identifier, element, resumeData) {

        editor.create(identifier, element, function () {

            editor.data[identifier].value = resumeData.value.trim();
        });
    },
    reload: function reload(identifier) {

        editor.onCreate(identifier);
        CKEDITOR.instances['editor_' + identifier].setData(editor.data[identifier].value);
    },
    create: function create(identifier, element, callback) {

        editor.data[identifier] = {
            title: '',
            value: '',
            disabled: 0
        };

        element.querySelector('textarea').setAttribute('id', 'editor_' + identifier);

        if (callback) callback();
    },
    onCreate: function onCreate(identifier) {

        CKEDITOR.replace('editor_' + identifier, _Config2.default.editor);

        CKEDITOR.instances['editor_' + identifier].on('change', function () {
            editor.data[identifier].value = CKEDITOR.instances['editor_' + identifier].getData().trim();
        });

        if (editor.data[identifier].value !== '') CKEDITOR.instances['editor_' + identifier].setData(editor.data[identifier].value);
    },
    validate: function validate() {

        return true;
    },
    serialize: function serialize() {

        return editor.data;
    }
};

module.exports = editor;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var sources = {
    start: function start() {

        // Save elements
        sources.parentElement = document.querySelector('[data-component=sources]');
        sources.nameInput = sources.parentElement.querySelector('[name=component_sources_add_name]');
        sources.valueInput = sources.parentElement.querySelector('[name=component_sources_add_source]');
        sources.addButton = sources.parentElement.querySelector('.sources-add');
        sources.itemsList = sources.parentElement.querySelector('.sources-list');
        sources.templateElement = sources.parentElement.querySelector('#template_component_sources_item').childNodes[0];

        // Events
        _Utils2.default.registerEvents([{
            // Enter to add source
            event: 'keyup',
            element: sources.valueInput,
            content: function content(event) {

                if (!event.keyCode || event.keyCode !== 13) return true;

                sources.addButton.click();
            }
        }, {
            // Delegate click events
            event: 'click',
            element: sources.parentElement,
            content: function content(event) {

                var target = event.target;

                // Add source
                if (target === sources.addButton) sources.addSource();

                // Edit source
                else if (target.matches('.source-edit')) {

                        var parent = target.parentNode;

                        sources.nameInput.value = parent.childNodes[0].innerText.trim();
                        sources.valueInput.value = parent.childNodes[1].innerText.trim();
                        sources.nameInput.focus();

                        sources.itemsList.removeChild(parent);

                        _Global2.default.packery.reloadItems();
                    }

                    // Remove source
                    else if (target.matches('.source-remove')) {

                            sources.nameInput.value = '';
                            sources.valueInput.value = '';
                            sources.nameInput.focus();

                            sources.itemsList.removeChild(target.parentNode);

                            _Global2.default.packery.reloadItems();
                        }
            }
        }]);
    },
    addSource: function addSource(source) {

        // Save current
        var currentSources = sources.itemsList.childNodes;

        var sourceNames = Object.values(currentSources).map(function (sourceElement) {
            return sourceElement.childNodes[0].innerText.trim();
        });

        var sourceName = source ? source[0] : sources.nameInput.value.trim();

        if (~sourceNames.indexOf(sourceName)) {
            sources.nameInput.value = '';
            if (!source) sources.nameInput.focus();
            return true;
        }

        var sourceValue = source ? source[1] : sources.valueInput.value.trim();

        if (sourceName === '' || sourceValue === '') {
            if (!source) sources.nameInput.focus();
            return true;
        }

        var template = sources.templateElement.cloneNode(true);
        template.children[0].innerText = sourceName;
        template.children[1].innerText = sourceValue;

        sources.nameInput.value = '';
        sources.valueInput.value = '';

        if (!source) sources.nameInput.focus();

        sources.itemsList.insertBefore(template, sources.itemsList.childNodes[0]);
        _Global2.default.packery.reloadItems();
    },
    resume: function resume() {
        var _this = this;

        // Save current instance
        var data = this.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var sources = JSON.parse(data).sources;

        if (sources === null) return true;

        sources.forEach(function (source) {
            _this.addSource(source);
        });

        _Global2.default.packery.reloadItems();
    },
    validate: function validate() {

        return true;
    },
    serialize: function serialize() {

        var sourceItems = this.itemsList.childNodes;

        var sources = Object.values(sourceItems).reverse().map(function (sourceItem) {

            return [sourceItem.childNodes[0].innerText.trim(), sourceItem.childNodes[1].innerText.trim()];
        });

        return {

            sources: sources

        };
    }
};

module.exports = sources;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var status = {
    start: function start() {

        // Save elements
        status.parentElement = document.querySelector('[data-component=status]');
        status.selectElement = status.parentElement.querySelector('select');

        status.selector = status.createSelector();
    },
    createSelector: function createSelector() {

        return new _Global2.default.Selector({
            element: 'select[name=component_status]',
            opened: _Global2.default.packery.reloadItems,
            closed: _Global2.default.packery.reloadItems
        });
    },
    resume: function resume() {

        // Save current instance
        var data = this.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var status = JSON.parse(data).status;

        var selectOptions = this.selectElement.querySelectorAll('option');

        Object.values(selectOptions).forEach(function (selectOption, index) {

            if (index !== status) selectOption.removeAttribute('selected');else selectOption.setAttribute('selected', 'true');
        });

        this.selector.destroy();
        this.selector = this.createSelector();
    },
    validate: function validate() {

        var data = status.serialize().status;

        return data > -1 && data < 4;
    },
    serialize: function serialize() {

        return {

            status: parseInt(status.selectElement.querySelector('[selected=true]').getAttribute('value'))

        };
    }
};

module.exports = status;

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var table = {

    data: {},

    template: false,
    clones: {

        clone: false,

        actionRow: false,
        headerRow: false,
        tableRow: false,

        headerActionFirst: false,
        headerAction: false,

        asideActionFirst: false,
        asideAction: false,

        headerCell: false,
        contentCell: false,

        emptyCell: false

    },

    resumeInline: function resumeInline(identifier, element, resumeData) {

        table.create(identifier, element, resumeData);
    },
    validate: function validate() {
        return true;
    },
    serialize: function serialize() {
        return table.data;
    },
    addRow: function addRow(table, identifier, before, resumeData) {

        var clones = this.clones;
        var data = this.data[identifier];
        var tableRow = clones.tableRow.cloneNode(true);
        var actionCell = clones.asideAction.cloneNode(true);
        var columnID = data.table.order.columns[0];
        var headerCell = clones.headerCell.cloneNode(true);

        var rowID = Math.floor(Math.random() * (9999999 - 1000000)) + 1000000;

        tableRow.appendChild(actionCell);
        headerCell.setAttribute('data-column', data.table.order.columns[0]);
        tableRow.appendChild(headerCell);

        // Serialize row header cell
        data.table.rows[rowID] = {};
        tableRow.setAttribute('data-row', rowID);

        if (before === undefined) data.table.order.rows.push(rowID);else {

            var beforeID = parseFloat(before.getAttribute('data-row'));
            var beforeIndex = data.table.order.rows.indexOf(beforeID);

            if (beforeIndex === -1) return false;

            data.table.order.rows.splice(beforeIndex, 0, rowID);
        }

        if (data.table.hidden) if (data.table.hidden.columns.indexOf(columnID) !== -1) headerCell.classList.add('hidden');

        for (var i = 0; i < data.dimensions[0]; ++i) {

            var contentCell = clones.contentCell.cloneNode(true);
            var _columnID = data.table.order.columns[+i + 1];

            contentCell.setAttribute('data-column', _columnID);
            tableRow.appendChild(contentCell);
        }

        if (!before) table.appendChild(tableRow);else table.insertBefore(tableRow, before);

        if (resumeData !== undefined) {

            if (resumeData.hidden) _Utils2.default.triggerEvent(actionCell.children[0], 'click');

            if (resumeData.header) {
                headerCell.innerText = resumeData.header;
                _Utils2.default.triggerEvent(headerCell, 'input');
            }
        }

        ++data.dimensions[1];
        return table;
    },
    addColumn: function addColumn(table, identifier, afterID, resumeData) {

        var data = this.data[identifier];
        var clones = this.clones;

        var columnID = Math.floor(Math.random() * (999999 - 100000)) + 100000;
        var actionRow = table.querySelector('.table-action-row');
        var actionCell = clones.headerAction.cloneNode(true);

        var headerRow = table.querySelector('.table-header-row');
        var headerCell = clones.headerCell.cloneNode(true);

        var contentRows = table.querySelectorAll('.table-row');
        var contentCell = clones.contentCell.cloneNode(true);

        if (afterID !== undefined) {

            var afterIndex = data.table.order.columns.indexOf(parseInt(afterID));
            data.table.order.columns.splice(++afterIndex, 0, columnID);
        } else data.table.order.columns.push(columnID);

        actionCell.setAttribute('data-column', columnID.toString());
        headerCell.setAttribute('data-column', columnID.toString());
        contentCell.setAttribute('data-column', columnID.toString());

        if (afterID === undefined) {

            actionRow.appendChild(actionCell);
            headerRow.appendChild(headerCell);

            if (resumeData !== undefined) {

                if (resumeData.header) {
                    headerCell.innerText = resumeData.header;
                    _Utils2.default.triggerEvent(headerCell, 'input');
                }
            }

            contentRows.forEach(function (row, index) {

                var currentCell = contentCell.cloneNode(true);
                row.appendChild(currentCell);

                if (resumeData !== undefined) {

                    if (resumeData.data[index] !== undefined) {
                        currentCell.innerText = resumeData.data[index];
                        _Utils2.default.triggerEvent(currentCell, 'input');
                    }

                    // If hidden row
                    var rowID = row.getAttribute('data-row');
                    if (data.table.hidden) if (data.table.hidden.rows.indexOf(rowID) !== -1) currentCell.classList.add('hidden');
                }
            });
        } else {

            var afterAction = actionRow.querySelector('[data-column="' + afterID + '"]');
            var afterHeader = headerRow.querySelector('[data-column="' + afterID + '"]');
            var done = false;

            actionRow.insertBefore(actionCell, afterAction.nextSibling);
            headerRow.insertBefore(headerCell, afterHeader.nextSibling);

            contentRows.forEach(function (row) {

                if (done) return false;

                var afterCell = row.querySelector('[data-column="' + afterID + '"]');
                var clone = contentCell.cloneNode(true);

                row.insertBefore(clone, afterCell.nextSibling);
            });
        }

        if (resumeData !== undefined) {

            // If column is hidden
            if (resumeData.hidden !== undefined) _Utils2.default.triggerEvent(actionCell.children[0], 'click');
        }

        ++this.data[identifier].dimensions[0];
        return table;
    },
    allowHorizontalScrolling: function allowHorizontalScrolling(contentElement) {

        _Utils2.default.registerEvent({

            event: 'wheel',
            element: contentElement,

            content: function content(event) {

                this.scrollLeft -= -(event.deltaY * 20);
                event.preventDefault();
            }

        });
    },
    createTemplateClones: function createTemplateClones(element) {

        var template = table.template;
        var clones = table.clones;

        // Save parent template
        if (template === false) table.template = template = element.querySelector('#template_inline_table_components').cloneNode(true).children[0];

        // Other clones
        if (clones.actionRow === false) clones.actionRow = template.querySelector('.table-action-row').cloneNode(true);

        if (clones.headerActionFirst === false) clones.headerActionFirst = template.querySelector('.table-header-action-first').cloneNode(true);

        if (clones.headerAction === false) clones.headerAction = template.querySelector('.table-header-action').cloneNode(true);

        if (clones.emptyCell === false) clones.emptyCell = document.createElement('td');

        if (clones.headerRow === false) clones.headerRow = template.querySelector('.table-header-row').cloneNode(true);

        if (clones.asideActionFirst === false) clones.asideActionFirst = template.querySelector('.table-aside-action-first').cloneNode(true);

        if (clones.headerCell === false) clones.headerCell = template.querySelector('th[contenteditable=true]').cloneNode(true);

        if (clones.asideAction === false) clones.asideAction = template.querySelector('.table-aside-action').cloneNode(true);

        if (clones.contentCell === false) clones.contentCell = template.querySelector('td[contenteditable=true]').cloneNode(true);

        if (clones.tableRow === false) clones.tableRow = template.querySelector('.table-row').cloneNode(true);
    },
    create: function create(identifier, element, resumeData) {

        var current = this;
        var contentElement = element.querySelector('div.table-box');
        var nameInput = element.querySelector('input[name=component_inline_table_name]');
        var clones = current.clones;
        var data = current.data;

        // Create template clones
        current.createTemplateClones(element);

        var table = document.createElement('table');
        var actionRow = clones.actionRow.cloneNode(true);
        var headerRow = clones.headerRow.cloneNode(true);
        var firstColumnID = Math.floor(Math.random() * (999999 - 100000)) + 100000;
        var firstRowID = Math.floor(Math.random() * (9999999 - 1000000)) + 1000000;
        var addRowElement = contentElement.querySelector('.table-add-button');

        current.allowHorizontalScrolling(contentElement);

        // Create table data
        data[identifier] = {

            title: '',
            table: {

                hidden: {
                    columns: [],
                    rows: []
                },

                header: {},
                rows: {},
                name: '',

                order: {
                    rows: [],
                    columns: []
                }

            },

            dimensions: [0, 0],
            disabled: 0

        };

        // Create events
        _Utils2.default.registerEvents([{
            // Serialize table name
            event: 'input',
            element: nameInput,
            content: function content(event) {
                data[identifier].table.name = event.target.value.trim();
            }
        }, {
            // Delegate click events
            event: 'click',
            element: table,
            content: function content(event) {

                var target = event.target;

                // Hide column
                if (target.matches('.table-hide-column')) {

                    var columnID = target.parentNode.getAttribute('data-column');

                    var hiddenIndex = void 0;
                    var isHidden = ~(hiddenIndex = data[identifier].table.hidden.columns.indexOf(columnID));

                    var rowsList = table.querySelectorAll('tr');
                    var rowSelector = '[data-column="' + columnID + '"]';

                    if (isHidden) {

                        rowsList.forEach(function (row) {

                            var rowID = row.getAttribute('data-row');
                            var rowColumn = row.querySelector(rowSelector);
                            var isHiddenRow = ~data[identifier].table.hidden.rows.indexOf(rowID);

                            if (isHiddenRow) return true;

                            if (rowColumn) rowColumn.classList.remove('hidden');
                        });

                        data[identifier].table.hidden.columns.splice(hiddenIndex, 1);
                    } else {

                        rowsList.forEach(function (row) {

                            var rowColumn = row.querySelector(rowSelector);

                            if (rowColumn) rowColumn.classList.add('hidden');
                        });

                        data[identifier].table.hidden.columns.push(columnID);
                    }
                }

                // Hide row
                else if (target.matches('.table-hide-row')) {

                        var rowID = target.parentNode.parentNode.getAttribute('data-row');

                        var _hiddenIndex = void 0;
                        var _isHidden = ~(_hiddenIndex = data[identifier].table.hidden.rows.indexOf(rowID));

                        var row = table.querySelector('[data-row="' + rowID + '"]');

                        if (_isHidden) {

                            var columnsList = row.querySelectorAll('[data-column]');
                            row.children[0].classList.remove('hidden');

                            columnsList.forEach(function (column) {

                                var columnID = column.getAttribute('data-column');
                                var isHiddenColumn = ~data[identifier].table.hidden.columns.indexOf(columnID);

                                if (isHiddenColumn) return true;

                                column.classList.remove('hidden');
                            });

                            data[identifier].table.hidden.rows.splice(_hiddenIndex, 1);
                        } else {

                            Array.from(row.children).forEach(function (column) {

                                column.classList.add('hidden');
                            });

                            data[identifier].table.hidden.rows.push(rowID);
                        }
                    }

                    // Add column
                    else if (target.matches('.table-new-column')) {

                            var _columnID2 = target.parentNode.getAttribute('data-column');
                            current.addColumn(table, identifier, _columnID2);
                        }

                        // Delete column
                        else if (target.matches('.table-delete-column')) {

                                var _columnID3 = target.parentNode.getAttribute('data-column');
                                var _rowsList = Array.from(table.querySelectorAll('tr'));
                                var columnCells = table.querySelectorAll('[data-column="' + _columnID3 + '"');
                                var _rowID = _rowsList[1].getAttribute('data-row');
                                var headerIdentifier = _columnID3 + '.' + _rowID;

                                Array.from(columnCells).forEach(function (cell, index) {

                                    _rowsList[index].removeChild(cell);
                                });

                                --data[identifier].dimensions[0];
                                delete data[identifier].table.header[headerIdentifier];

                                var _hiddenIndex2 = data[identifier].table.hidden.columns.indexOf(_columnID3);
                                if (~_hiddenIndex2) data[identifier].table.hidden.columns.splice(_hiddenIndex2, 1);

                                var orderIndex = data[identifier].table.order.columns.indexOf(parseInt(_columnID3));
                                if (~orderIndex) data[identifier].table.order.columns.splice(orderIndex, 1);

                                Object.keys(data[identifier].table.rows).forEach(function (rowID) {

                                    delete data[identifier].table.rows[rowID][_columnID3];
                                });
                            }

                            // Add row
                            else if (target.matches('.table-new-row')) {

                                    var eventRow = target.parentNode.parentNode;
                                    current.addRow(table, identifier, eventRow);
                                }

                                // Delete row
                                else if (target.matches('.table-delete-row')) {

                                        var parent = target.parentNode.parentNode;
                                        var _rowID2 = parent.getAttribute('data-row');
                                        var _columnID4 = parent.children[1].getAttribute('data-column');
                                        var _headerIdentifier = _columnID4 + '.' + _rowID2;
                                        var _hiddenIndex3 = data[identifier].table.hidden.rows.indexOf(_rowID2.toString());
                                        var _orderIndex = data[identifier].table.order.rows.indexOf(parseInt(_rowID2));

                                        if (~_hiddenIndex3) data[identifier].table.hidden.rows.splice(_hiddenIndex3, 1);

                                        if (~_orderIndex) data[identifier].table.order.rows.splice(_orderIndex, 1);

                                        delete data[identifier].table.rows[_rowID2];
                                        delete data[identifier].table.header[_headerIdentifier];
                                        --data[identifier].dimensions[1];

                                        parent.parentNode.removeChild(parent);
                                    }
            }
        }, {
            // Add new row at the end
            event: 'click',
            element: addRowElement,
            content: function content() {

                current.addRow(table, identifier);
            }
        }, {
            // Delegate input events
            event: 'input',
            element: table,
            content: function content(event) {

                var target = event.target;

                // Serialize table headers
                if (target.matches('th[contenteditable]')) {

                    var columnID = target.getAttribute('data-column');
                    var rowID = target.parentNode.getAttribute('data-row');
                    var headerIdentifier = columnID + '.' + rowID;

                    data[identifier].table.header[headerIdentifier] = target.innerText.trim();
                }

                // Serialize table cells
                else if (target.matches('td[contenteditable]')) {

                        var _columnID5 = target.getAttribute('data-column');
                        var _rowID3 = target.parentNode.getAttribute('data-row');

                        data[identifier].table.rows[_rowID3][_columnID5] = target.innerText.trim();
                    }
            }
        }]);

        // Render action row ___________________________________________________________________________________________
        // ACTION ROW PROTOTYPE: | empty cell | header action cell first |
        var emptyClone = clones.emptyCell.cloneNode(true);
        emptyClone.classList.add('table-aside-action');

        actionRow.appendChild(emptyClone);
        actionRow.appendChild(clones.headerActionFirst.cloneNode(true));

        // Save row identifier
        data[identifier].table.order.columns.push(firstColumnID);
        actionRow.children[1].setAttribute('data-column', firstColumnID.toString());

        // Render header row ___________________________________________________________________________________________
        // HEADER ROW PROTOTYPE: | aside action cell first | header cell |
        headerRow.appendChild(clones.asideActionFirst.cloneNode(true));
        headerRow.appendChild(clones.headerCell.cloneNode(true));

        // Save row identifier and data
        data[identifier].table.rows[firstRowID] = {};
        data[identifier].table.order.rows.push(firstRowID);
        headerRow.setAttribute('data-row', firstRowID.toString());
        headerRow.children[1].setAttribute('data-column', firstColumnID.toString());

        // Show complete table
        table.appendChild(actionRow);
        table.appendChild(headerRow);

        // Resume data
        if (resumeData !== undefined) {

            // Initialize table name
            nameInput.value = resumeData.table.name.trim();
            _Utils2.default.triggerEvent(nameInput, 'input');

            // Change table global header
            var firstRow = resumeData.table.order.rows[0];
            var firstColumn = resumeData.table.order.columns[0];
            var headerIdentifier = firstColumn + '.' + firstRow;

            if (resumeData.table.header) {
                headerRow.children[1].innerText = resumeData.table.header[headerIdentifier];
                _Utils2.default.triggerEvent(headerRow.children[1], 'input');
            }

            // Show / Hide first row and column
            if (resumeData.table.hidden) {

                if (resumeData.table.hidden.columns) {

                    if (resumeData.table.hidden.columns.indexOf(firstColumn) !== -1) _Utils2.default.triggerEvent(actionRow.children[1].children[0], 'click');
                }

                if (resumeData.table.hidden.rows) {

                    if (resumeData.table.hidden.rows.indexOf(firstRow) !== -1) _Utils2.default.triggerEvent(headerRow.children[0].children[0], 'click');
                }
            }

            // Render rest of the table
            // Create table rows
            for (var i = 0; i < resumeData.dimensions[1]; ++i) {

                var rowID = resumeData.table.order.rows[i + 1];
                var headerID = firstColumn + '.' + rowID;
                var rowData = {};

                if (resumeData.table.hidden) if (resumeData.table.hidden.rows) rowData.hidden = resumeData.table.hidden.rows.indexOf(rowID) !== -1;

                if (resumeData.table.header) rowData.header = resumeData.table.header[headerID];

                current.addRow(table, identifier, undefined, rowData);
            }

            // Create table columns

            var _loop = function _loop(_i) {

                var columnID = resumeData.table.order.columns[_i + 1];
                var headerID = columnID + '.' + firstRow;
                var columnData = {};

                if (resumeData.table.hidden) if (resumeData.table.hidden.columns) columnData.hidden = resumeData.table.hidden.columns.indexOf(columnID) !== -1;

                if (resumeData.table.header) columnData.header = resumeData.table.header[headerID];

                columnData.data = [];

                if (resumeData.table.rows) resumeData.table.order.rows.forEach(function (row) {

                    if (resumeData.table.rows[row] === undefined) return false;

                    if (resumeData.table.rows[row][columnID]) columnData.data.push(resumeData.table.rows[row][columnID]);
                });

                current.addColumn(table, identifier, undefined, columnData);
            };

            for (var _i = 0; _i < resumeData.dimensions[0]; ++_i) {
                _loop(_i);
            }
        } else {

            // Create table rows
            for (var _i2 = 0; _i2 < 4; ++_i2) {
                current.addRow(table, identifier);
            } // Create table columns
            for (var _i3 = 0; _i3 < 3; ++_i3) {
                current.addColumn(table, identifier);
            }
        }

        contentElement.appendChild(table);
    }
};

module.exports = table;

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var tags = {
    start: function start() {

        // Save elements
        tags.parentElement = document.querySelector('[data-component=tags]');
        tags.inputElement = tags.parentElement.querySelector('input');
        tags.listElement = tags.parentElement.querySelector('.tags-list');
        tags.templateElement = tags.parentElement.querySelector('#template_component_tags_item').childNodes[0];

        // Events
        _Utils2.default.registerEvents([{
            // Delegate click event
            event: 'click',
            element: tags.parentElement,
            content: function content(event) {

                // Remove tag
                if (event.target.matches('.tag-remove')) {

                    tags.listElement.removeChild(event.target.parentNode);
                    _Global2.default.packery.reloadItems();
                }
            }
        }, {
            // Add tags
            event: 'keyup',
            element: tags.inputElement,
            content: function content(event) {

                if (!event.keyCode || event.keyCode !== 13) return true;

                tags.addTag();
            }
        }]);
    },
    resume: function resume() {

        // Save current instance
        var data = this.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var tags = JSON.parse(data).tags;

        if (tags === null) return true;

        this.addTag(tags.join(','));
    },
    addTag: function addTag(list) {
        var _this = this;

        var tags = list || this.inputElement.value.trim();

        if (!_Utils2.default.validateTags(tags)) return true;

        var tagList = tags.split(',');

        tagList.map(function (tag) {

            tag = tag.trim();
            var currentTags = _this.serialize().tags;

            if (~currentTags.indexOf(tag)) return true;

            var template = _this.templateElement.cloneNode(true);
            template.innerHTML = '#' + tag + template.innerHTML;

            _this.inputElement.value = '';
            _this.listElement.appendChild(template);

            _Global2.default.packery.reloadItems();
        });
    },
    validate: function validate() {

        var tags = this.serialize().tags;

        return _Utils2.default.validateTags(tags);
    },
    serialize: function serialize() {

        var tagElements = tags.listElement.childNodes;

        var tagList = Array.from(tagElements).map(function (tagElement) {

            return tagElement.innerText.trim().replace('#', '');
        });

        return {

            tags: tagList

        };
    }
};

module.exports = tags;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var thumbnail = {
    start: function start() {

        // Save elements
        thumbnail.parentElement = document.querySelector('[data-component=thumbnail]');
        thumbnail.inputBox = thumbnail.parentElement.querySelector('.input-box');
        thumbnail.mediaButton = thumbnail.inputBox.querySelector('.image_manager');
        thumbnail.mediaInput = thumbnail.inputBox.querySelector('input');
        thumbnail.messageElement = thumbnail.inputBox.querySelector('.validate-message');
        thumbnail.templateElement = thumbnail.parentElement.querySelector('#template_component_thumbnail_image').childNodes[0];

        // Events
        _Utils2.default.registerEvents([{
            // Delegate click events
            event: 'click',
            element: thumbnail.parentElement,
            content: function content(event) {

                // Open MediaManager
                if (event.target.matches('.image_manager')) {

                    _Global2.default.managerActiveInstance = new _Global2.default.MediaManager({
                        manager: 'images',
                        onSelect: function onSelect(path) {

                            thumbnail.addNew(path, false);
                        }
                    });
                }

                // Remove thumbnail
                else if (event.target.matches('.thumbnail-remove')) {

                        thumbnail.inputBox.classList.remove('hide');

                        thumbnail.parentElement.removeChild(thumbnail.parentElement.querySelector('div.component-instance'));

                        _Global2.default.packery.reloadItems();
                    }
            }
        }, {
            // Enter custom URL to image
            event: 'keypress',
            element: thumbnail.mediaInput,
            content: function content(event) {

                if (!event.keyCode || event.keyCode !== 13) return false;

                var path = event.target.value.trim();

                thumbnail.validateInput(path, function () {

                    thumbnail.addNew(path, true);
                });
            }
        }, {
            // Real-time URL validation
            event: 'change keyup',
            element: thumbnail.mediaInput,
            content: function content(event) {

                thumbnail.validateInput(event.target.value.trim());
            }
        }]);
    },
    resume: function resume() {

        // Save current instance
        var data = thumbnail.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var thumb = JSON.parse(data).thumbnail;

        if (thumb === '') return true;

        thumbnail.addNew(thumb, !~thumb.indexOf('app/Data/Files/Images/'));
    },
    removeCurrent: function removeCurrent(parent) {

        if (parent.querySelector('div.thumbnail-image.component-instance')) parent.removeChild(parent.querySelector('div.thumbnail-image.component-instance'));
    },
    addNew: function addNew(path, outside) {

        path = path.replace('app/Data/Files/Images/', '');

        var text = path;
        var template = thumbnail.templateElement.cloneNode(true);

        thumbnail.removeCurrent(thumbnail.parentElement);
        thumbnail.inputBox.value = '';

        if (!outside) path = 'app/Data/Files/Images/' + path;

        template.setAttribute('data-path', path);
        template.classList.add('component-instance');

        template.childNodes[0].setAttribute('src', path);
        template.childNodes[0].setAttribute('alt', path);

        template.childNodes[1].innerText = text;

        thumbnail.parentElement.appendChild(template);

        thumbnail.inputBox.classList.add('hide');

        _Utils2.default.closeMediaManager();
        _Global2.default.packery.reloadItems();
    },
    validateInput: function validateInput(path, onSuccess, onError) {

        if (!_Utils2.default.validateUrl(path)) return _Utils2.default.showValidationResults(thumbnail.messageElement, 'COMPONENT_URL_INVALID', false, _Global2.default.packery.reloadItems);

        new Promise(function (resolve) {

            var image = new Image();

            image.onload = function () {
                resolve(true);
            };

            image.onerror = function () {
                resolve(false);
            };

            image.src = path;
        }).then(function (result) {

            if (result) {

                _Utils2.default.showValidationResults(thumbnail.messageElement, 'COMPONENT_URL_INVALID', true, _Global2.default.packery.reloadItems);

                if (onSuccess) onSuccess();
            } else {

                _Utils2.default.showValidationResults(thumbnail.messageElement, 'COMPONENT_URL_INVALID', false, _Global2.default.packery.reloadItems);

                if (onError) onError();
            }
        });
    },
    validate: function validate() {

        return true;
    },
    serialize: function serialize() {

        var instance = thumbnail.parentElement.querySelector('div.thumbnail-image.component-instance');
        var data = '';

        if (instance) data = instance.getAttribute('data-path');

        return {
            thumbnail: data
        };
    }
};

module.exports = thumbnail;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var title = {
    start: function start() {

        // Save elements
        title.parentElement = document.querySelector('[data-component=title]');
        title.inputElement = title.parentElement.querySelector('input');
        title.titleElement = document.querySelector('.mainline-heading');

        _Utils2.default.registerEvent({

            event: 'keydown keyup change',
            element: title.inputElement,
            content: function content(event) {

                var substring = event.target.value.trim().substr(0, 16);
                title.titleElement.innerText = substring.length === 16 ? substring + '...' : substring;
            }

        });
    },
    resume: function resume() {

        // Save current instance
        var data = title.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var object = JSON.parse(data);
        title.inputElement.value = object.title;

        _Utils2.default.triggerEvent(title.inputElement, 'change');
    },
    validate: function validate() {

        var data = title.serialize().title;

        return data.length < 101 && data.length > 0;
    },
    serialize: function serialize() {

        return {
            title: title.inputElement.value.trim()
        };
    }
};

module.exports = title;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

var _Ajax = __webpack_require__(2);

var _Ajax2 = _interopRequireDefault(_Ajax);

var _Router = __webpack_require__(3);

var _Router2 = _interopRequireDefault(_Router);

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var url = {
    isFree: function isFree() {

        var response = true;

        // Check if slug is in use
        _Ajax2.default.post(_Router2.default.createLink('api/articles.exists.url'), {
            api: {
                url: url.serialize().url,
                ignore: document.querySelector('div.content-wrapper').getAttribute('data-id')
            }
        }, function (data, status) {

            if (status === 'success' && data.success === true) response = !data.data.result;
        });

        return response;
    },
    start: function start() {

        // Save elements
        url.parentElement = document.querySelector('[data-component=url]');
        url.inputElement = url.parentElement.querySelector('input');
        url.messageElement = url.parentElement.querySelector('.validate-message');

        // Real-time url validation
        _Utils2.default.registerEvent({

            event: 'keyup change',
            element: url.inputElement,
            content: function content() {

                _Utils2.default.showValidationResults(url.messageElement, 'COMPONENT_URL_INVALID', url.validate(), _Global2.default.packery.reloadItems);
            }

        });
    },
    resume: function resume() {

        // Save current instance
        var data = url.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var object = JSON.parse(data);
        url.inputElement.value = object.url;

        _Utils2.default.triggerEvent(url.inputElement, 'change');
    },
    validate: function validate() {

        var data = url.serialize().url;

        if (!/^[a-z][a-z0-9\-]+[a-z]$/.test(data)) return false;

        if (data.length < 3 || data.length > 120) return false;

        return url.isFree();
    },
    serialize: function serialize() {

        return {
            url: url.inputElement.value.trim()
        };
    }
};

module.exports = url;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

var _Ajax = __webpack_require__(2);

var _Ajax2 = _interopRequireDefault(_Ajax);

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var video = {

    data: {},
    valid: {},

    YT_QUALITY: {
        'small': '240p (LQ)',
        'medium': '360p (SQ)',
        'large': '480p (HQ)',
        'hd720': '720p (HD)',
        'hd1080': '1080p (FullHD)',
        'highres': '1440p+ (QHD+)'
    },

    resumeInline: function resumeInline(identifier, element, resumeData) {

        var path = resumeData.video;
        video.create(identifier, element);

        video.onSelect(identifier, element, path, true, function (description, align) {

            var descriptionText = resumeData.video_description.trim();

            if (descriptionText === 'false') descriptionText = '';

            description.value = descriptionText;
            _Utils2.default.triggerEvent(description, 'change');

            align[resumeData.video_align].click();
        });
    },
    videoType: function videoType(path) {

        // Vimeo
        if (/^((?:https?:)?\/\/)?((?:www|m|player)\.)?((?:vimeo\.com))(?:$|\/|)(\S+)?$/gm.test(path)) return 1;

        // YouTube
        else if (/(https?:\/\/.*?youtube\.com)\/watch\?v=(.*)/igm.test(path)) return 0;

            // External videos
            else return -1;
    },
    registerEvents: function registerEvents(template, identifier, contentElement, callback) {

        var alignOptions = template.children[6].querySelectorAll('span');

        _Utils2.default.registerEvents([{
            // Serialize description
            event: 'change keyup',
            element: template.children[4].children[1],
            content: function content(event) {
                video.data[identifier].video_description = event.target.value.trim();
            }
        }, {
            // Serialize video position
            event: 'click',
            element: alignOptions,
            content: function content(event) {
                video.data[identifier].video_align = +event.target.getAttribute('data-value');
                alignOptions.forEach(function (item) {
                    item.classList.remove('active');
                });
                event.target.classList.add('active');
            }
        }]);

        template.children[5].addEventListener('click', function () {
            video.removeInstance(identifier, contentElement, template);
        });

        if (callback) callback(template.children[4].children[1], alignOptions);
    },
    loadExternalVideo: function loadExternalVideo(identifier, element, path, template, callback) {

        // Close media manager
        document.querySelector('div.media-manager span.close-manager').click();

        var current = this;
        var video = document.createElement('video');
        video.setAttribute('src', path);
        video.classList.add('item-player');
        video.setAttribute('controls', 'true');
        video.volume = .5;

        var contentElement = element.querySelector('div.component-element-content');
        contentElement.classList.add('no-padding');
        contentElement.querySelector('div.select-image').classList.add('hide');

        template.insertBefore(video, template.children[0]);
        contentElement.appendChild(template);

        template.children[1].innerText = path.replace('app/Data/Files/Videos/', '');
        video.addEventListener('loadedmetadata', function () {

            var duration = video.duration;
            var minutes = parseInt(duration / 60, 10);
            var seconds = duration % 60;
            var time = minutes + ':' + _Utils2.default.pad(Math.round(seconds), 2);
            var width = video.videoWidth;
            var height = video.videoHeight;
            var dimensions = width + 'x' + height;

            template.children[2].innerText = time;
            template.children[3].innerText = dimensions;
        });

        current.registerEvents(template, identifier, contentElement, callback);
    },
    loadYouTubeVideo: function loadYouTubeVideo(identifier, element, path, template, callback) {

        var tmp = void 0;
        var current = this;
        var video = document.createElement('div');
        var id = 'youtube-player-' + identifier;
        video.setAttribute('id', id);

        var contentElement = element.querySelector('div.component-element-content');
        contentElement.classList.add('no-padding');
        contentElement.querySelector('div.select-image').classList.add('hide');

        var container = document.createElement('div');
        container.classList.add('iframe-container');
        container.appendChild(video);

        template.insertBefore(container, template.children[0]);
        contentElement.appendChild(template);

        var videoId = path.split('v=')[1];
        var ampersandPosition = videoId.indexOf('&');
        if (ampersandPosition !== -1) videoId = videoId.substring(0, ampersandPosition);

        function createPlayer() {

            new YT.Player(id, {
                videoId: videoId,
                events: {
                    onReady: function onReady(event) {
                        tmp = event.target.getPlaylist();
                        template.children[1].innerText = event.target.getVideoData().title;
                        var duration = event.target.getDuration();
                        var minutes = parseInt(duration / 60, 10);
                        var seconds = duration % 60;
                        template.children[2].innerText = minutes + ':' + _Utils2.default.pad(Math.round(seconds), 2);
                        event.target.setPlaybackQuality('medium');
                    },
                    onStateChange: function onStateChange(event) {

                        template.children[3].innerText = event.target.getAvailableQualityLevels()[0] !== undefined ? current.YT_QUALITY[event.target.getAvailableQualityLevels()[0]] : '';
                    }
                }
            });
        }

        setTimeout(createPlayer);

        current.registerEvents(template, identifier, contentElement, callback);
    },
    loadVimeoVideo: function loadVimeoVideo(identifier, element, path, template, callback) {

        var video = _Ajax2.default.getJSON('https://vimeo.com/api/oembed.json?url=' + path);

        var contentElement = element.querySelector('div.component-element-content');
        contentElement.classList.add('no-padding');
        contentElement.querySelector('div.select-image').classList.add('hide');

        var container = document.createElement('div');
        container.classList.add('iframe-container');
        container.insertAdjacentHTML('afterbegin', video.html);

        template.insertBefore(container, template.children[0]);
        contentElement.appendChild(template);

        template.children[1].innerText = video.title;
        var duration = video.duration;
        var minutes = parseInt(duration / 60, 10);
        var seconds = duration % 60;
        template.children[2].innerText = minutes + ':' + _Utils2.default.pad(Math.round(seconds), 2);

        var channelURL = document.createElement('a');
        channelURL.setAttribute('href', video.author_url);
        channelURL.setAttribute('target', '_blank');
        channelURL.innerText = video.author_name;
        template.children[3].appendChild(channelURL);

        this.registerEvents(template, identifier, contentElement, callback);
    },
    removeInstance: function removeInstance(identifier, contentElement, template) {

        contentElement.querySelector('div.input-box.select-image').classList.remove('hide');
        contentElement.removeChild(template);
        contentElement.classList.remove('no-padding');
        delete video.data[identifier];
    },
    remove: function remove(element) {

        element.querySelectorAll('div.component-instance').forEach(function (item) {
            item.querySelector('span.item-remove').click();
        });
    },
    onSelect: function onSelect(identifier, element, path, outside, callback) {

        // Remove current video if any
        video.remove(element);

        // Create path
        if (!outside) path = 'app/Data/Files/Videos/' + path;

        // Save image path and create instance data
        video.data[identifier] = {
            video: path,
            video_description: false,
            video_align: 1
        };

        // Get video type
        var type = video.videoType(path);

        // Create template
        var template = element.querySelector('#template_component_content_video_item').children[0].cloneNode(true);
        template.setAttribute('data-path', path);

        // Load video by type
        switch (type) {
            case -1:
                video.loadExternalVideo(identifier, element, path, template, callback);
                break;
            case 0:
                video.loadYouTubeVideo(identifier, element, path, template, callback);
                break;
            case 1:
                video.loadVimeoVideo(identifier, element, path, template, callback);
                break;
            default:
                return false;
                break;
        }
    },
    create: function create(identifier, element) {

        video.data[identifier] = {
            title: '',
            disabled: 0
        };

        _Utils2.default.registerEvents([{
            // Open media manager
            event: 'click',
            element: element.querySelector('button.inline-image_manager'),
            content: function content() {
                _Global2.default.managerActiveInstance = new _Global2.default.MediaManager({
                    manager: 'videos',
                    onSelect: function onSelect(path) {
                        video.onSelect(identifier, element, path, false);
                    }
                });
            }
        }, {
            // Add external video with URL
            event: 'keyup',
            element: element.querySelector('input[name=component_inline_video_input]'),
            content: function content(event) {
                if (event.keyCode !== 13 || event.target.value.trim().length < 4) return false;
                video.onSelect(identifier, element, event.target.value.trim(), true);
            }
        }]);
    },
    validate: function validate() {
        return true;
    },
    serialize: function serialize() {
        return video.data;
    }
};

module.exports = video;

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _jquery = __webpack_require__(4);

var _jquery2 = _interopRequireDefault(_jquery);

var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

var _Csrf = __webpack_require__(5);

var _Csrf2 = _interopRequireDefault(_Csrf);

var _Translate = __webpack_require__(119);

var _Translate2 = _interopRequireDefault(_Translate);

var _Router = __webpack_require__(3);

var _Router2 = _interopRequireDefault(_Router);

var _mediaManager = __webpack_require__(120);

var _Slee = __webpack_require__(7);

var _Slee2 = _interopRequireDefault(_Slee);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_Slee2.default.prepare();
_Global2.default.Selector = __webpack_require__(121);
_Global2.default.MediaManager = _mediaManager.MediaManager;

// Load YouTube API
{

    if (!window['YT']) {
        var YT = { loading: 0, loaded: 0 };
    }if (!window['YTConfig']) {
        var _YTConfig = { 'host': 'http://www.youtube.com' };
    }if (!YT.loading) {
        YT.loading = 1;(function () {
            var l = [];YT.ready = function (f) {
                if (YT.loaded) {
                    f();
                } else {
                    l.push(f);
                }
            };window.onYTReady = function () {
                YT.loaded = 1;for (var i = 0; i < l.length; i += 1) {
                    try {
                        l[i]();
                    } catch (e) {}
                }
            };YT.setConfig = function (c) {
                for (var k in c) {
                    if (c.hasOwnProperty(k)) {
                        YTConfig[k] = c[k];
                    }
                }
            };var a = document.createElement('script');a.type = 'text/javascript';a.id = 'www-widgetapi-script';a.src = 'https://s.ytimg.com/yts/jsbin/www-widgetapi-vflWkV39n/www-widgetapi.js';a.async = false;var b = document.getElementsByTagName('script')[0];b.parentNode.insertBefore(a, b);
        })();
    }
}

// Translate page
{

    var translations = ['system', 'response', 'admin_header', 'admin_menu'];
    _Global2.default.translate = new _Translate2.default(translations, false);
}

// CSRF updater
_Csrf2.default.constructor();

// Anchor link box
_Global2.default.$html.on('mouseover', '[data-link]', function () {

    if ('ontouchstart' in document.documentElement) return false;

    var link = _Global2.default.routePrefix + _Global2.default.route + '/' + this.getAttribute('data-link');
    _Global2.default.anchorBox.addClass('show').text(link);
});
_Global2.default.$html.on('mouseleave', '[data-link]', function () {
    _Global2.default.anchorBox.removeClass('show').text('');
});

// Execute Router
_Global2.default.router = new _Router2.default();

// Delegate body click events
_Utils2.default.registerEvent(['click', _Global2.default.body, function (event) {

    var target = event.target;

    // Close elements on click outside
    _Global2.default.closer.closeElements(target);

    // Focus inputs
    if (target.matches('div.mainline-search div.input-box')) (0, _jquery2.default)(target).find('input').focus();

    // Show / Hide Password Fields
    else if (target.matches('.show-password, .password-show')) {

            var action = target.getAttribute('data-action');
            var input = document.querySelector('input[name=' + action + ']');

            if (input.getAttribute('type') === 'password') {
                input.setAttribute('type', 'text');
                target.classList.add('visible');
            } else {
                input.setAttribute('type', 'password');
                target.classList.remove('visible');
            }
        }

        // Logout
        else if (target.matches('.logout')) window.location.href = _Global2.default.URI + 'logout';

            // Link click event
            else if (target.matches('[data-link]') || (0, _jquery2.default)(target).parents('[data-link]').length > 0) {

                    var link = target.dataset.link;
                    var type = target.dataset.target;

                    if (!link) link = (0, _jquery2.default)(target).parents('[data-link]').data('link');

                    if (!type) type = false;

                    var linkAction = link.split('/')[0];
                    var menuLink = _Global2.default.nav.querySelector('[data-link="' + linkAction + '"]');
                    var activeLink = _Global2.default.nav.querySelector('.active[data-link]');

                    if (activeLink) activeLink.classList.remove('active');

                    if (menuLink) menuLink.classList.add('active');

                    _Global2.default.router.changeLocation(link, true, type);
                }
}]);

// Footer Open / Close
{

    var footer = (0, _jquery2.default)('footer');

    _Utils2.default.registerEvent(['click', document.querySelector('.footer-more'), function () {

        if (!footer.hasClass('open')) {
            footer.addClass('open');
            _Global2.default.closer.addElement(footer);
        } else footer.removeClass('open');
    }]);
}

// Account Menu Open / Close
{

    var dropdown = (0, _jquery2.default)('div.account-dropdown');

    _Utils2.default.registerEvent(['click', document.querySelector('.header-account'), function () {

        if (dropdown.hasClass('open')) return false;

        dropdown.addClass('open');
        _Global2.default.closer.addElement(dropdown);
    }]);
}

// Write Menu Open / Close
{

    var writeMenu = (0, _jquery2.default)('div.write-menu');

    _Utils2.default.registerEvents([['click', document.querySelector('div.header-write'), function () {
        writeMenu.addClass('open');
        _Global2.default.closer.addElement(writeMenu);
    }], ['click', document.querySelectorAll('div.write-menu span.header-close, div.write-menu div.tails-tail'), function () {
        return writeMenu.removeClass('open');
    }]]);
}

// Hide splash screen
_Utils2.default.hideSplash();

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _jquery = __webpack_require__(4);

var _jquery2 = _interopRequireDefault(_jquery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _class = function () {
    function _class() {
        _classCallCheck(this, _class);

        this.stack = [];
        this.counter = 0;
    }

    _createClass(_class, [{
        key: 'addElement',
        value: function addElement(element) {

            this.stack.push(element[0]);
            this.counter = 1;
        }
    }, {
        key: 'closeElements',
        value: function closeElements(target) {
            var _this = this;

            if (this.counter > 0) {
                this.counter = 0;
                return false;
            }

            this.stack.forEach(function (element) {

                if (!((0, _jquery2.default)(element).find(target).length > 0 || (0, _jquery2.default)(element).is((0, _jquery2.default)(target)))) {
                    (0, _jquery2.default)(element).removeClass('open');
                    _this.stack.splice(element, 1);
                }
            });
        }
    }]);

    return _class;
}();

exports.default = _class;

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
    initialize: function initialize(router) {

        window.onpopstate = function (event) {
            var link = event.state.link;
            router.changeLocation(link, false);
        };
    },
    createURL: function createURL(route) {
        return _Global2.default.routePrefix + _Global2.default.route + '/' + route.join('/');
    },
    push: function push(route) {
        history.pushState({ link: route }, '', this.createURL(route));
    },
    replace: function replace(route) {
        history.replaceState({ link: route }, '', this.createURL(route));
    }
};

/***/ }),
/* 102 */
/***/ (function(module, exports) {

module.exports = {"404":"Error","dashboard":"Dashboard","articles":"Articles","new":"New","category":"Category","settings":"Settings","sorting":"Sorting","write":"Write"}

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./Articles.js": 104,
	"./Dashboard.js": 105,
	"./Error.js": 106,
	"./Main.js": 6,
	"./Settings.js": 8,
	"./Settings/Account.js": 9,
	"./Settings/Appearance.js": 10,
	"./Write.js": 111
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number or string
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 103;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = {
    initialize: function initialize() {}
};

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

var _Main = __webpack_require__(6);

var _Main2 = _interopRequireDefault(_Main);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {

    LOCALES: ['admin_dashboard'],

    initialize: function initialize() {

        // Render content
        _Main2.default.createView(this.LOCALES);
    }
};

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Main = __webpack_require__(6);

var _Main2 = _interopRequireDefault(_Main);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
    initialize: function initialize(actions) {}
};

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){ true?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.Slee=t():e.Slee=t()}(this,function(){return function(e){function t(i){if(n[i])return n[i].exports;var o=n[i]={i:i,l:!1,exports:{}};return e[i].call(o.exports,o,o.exports,t),o.l=!0,o.exports}var n={};return t.m=e,t.c=n,t.d=function(e,n,i){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:i})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=9)}([function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default={data:{autoHide:!0,clickToHide:!0,hideDelay:4e3,type:"success",gap:12,position:"top right",animation:!1,action:!1,title:!1,description:!1,picture:!1,pointerEvents:!1},save:function(e){var t=this;Object.keys(e).forEach(function(n){t.data[n]=e[n]})}}},function(e,t,n){"use strict";n(2)},function(e,t,n){var i=n(3);"string"==typeof i&&(i=[[e.i,i,""]]);var o={};o.transform=void 0,n(5)(i,o),i.locals&&(e.exports=i.locals)},function(e,t,n){t=e.exports=n(4)(void 0),t.push([e.i,".slee-element{position:fixed;display:inline-block;width:360px;height:auto;z-index:9999999}.slee-element.top{top:18px}.slee-element.left{left:18px}.slee-element.bottom{bottom:18px}.slee-element.right{right:18px}.slee-element .slee-notification{position:relative;display:inline-block;overflow:hidden;width:100%;height:72px;transition:all .3s ease-in-out,height .1s ease-in-out .2s}.slee-element .slee-notification.hide{height:0;opacity:0;margin:0!important;visibility:hidden}.slee-element .slee-notification.hide.shrink{transform:scale(.7)}.slee-element .slee-notification.pointer-events:hover{opacity:.3;filter:blur(3px)}.slee-element .slee-notification .slee-notification-content{width:100%;height:72px;position:relative;display:inline-block;box-sizing:border-box;padding:12px 16px;border-radius:2px;box-shadow:0 0 16px rgba(0,0,0,.05);opacity:.9;border:2px solid;font-family:sans-serif}.slee-element .slee-notification .slee-notification-content .slee-title{display:inline-block;position:relative;width:100%;line-height:22px;font-weight:600;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.slee-element .slee-notification .slee-notification-content .slee-description{display:inline-block;position:relative;width:100%;line-height:16px;font-size:.92em;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.slee-element .slee-notification .slee-notification-content.slee-picture .slee-description,.slee-element .slee-notification .slee-notification-content.slee-picture .slee-title{width:calc(100% - 36px);margin-left:36px}.slee-element .slee-notification .slee-notification-content.slee-picture .slee-picture-wrapper{display:flex;position:absolute;top:0;left:8px;height:100%;width:36px;align-items:center;justify-content:center}.slee-element .slee-notification .slee-notification-content.slee-picture .slee-picture-wrapper img{display:block;width:30px}.slee-element .slee-notification.neutral div{background:#e4e4e4;border-color:#dbdbdb}.slee-element .slee-notification.success div{background:#7cfc00;border-color:#7af200}.slee-element .slee-notification.info div{background:#1e85f0;border-color:#1e78dc;color:#fff}.slee-element .slee-notification.warning div{background:#f18100;border-color:#df7700;color:#fff}.slee-element .slee-notification.error div{background:#ec1e26;border-color:#da1d25;color:#fff}",""])},function(e,t){function n(e,t){var n=e[1]||"",o=e[3];if(!o)return n;if(t&&"function"==typeof btoa){var r=i(o);return[n].concat(o.sources.map(function(e){return"/*# sourceURL="+o.sourceRoot+e+" */"})).concat([r]).join("\n")}return[n].join("\n")}function i(e){return"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(e))))+" */"}e.exports=function(e){var t=[];return t.toString=function(){return this.map(function(t){var i=n(t,e);return t[2]?"@media "+t[2]+"{"+i+"}":i}).join("")},t.i=function(e,n){"string"==typeof e&&(e=[[null,e,""]]);for(var i={},o=0;o<this.length;o++){var r=this[o][0];"number"==typeof r&&(i[r]=!0)}for(o=0;o<e.length;o++){var s=e[o];"number"==typeof s[0]&&i[s[0]]||(n&&!s[2]?s[2]=n:n&&(s[2]="("+s[2]+") and ("+n+")"),t.push(s))}},t}},function(e,t,n){function i(e,t){for(var n=0;n<e.length;n++){var i=e[n],o=h[i.id];if(o){o.refs++;for(var r=0;r<o.parts.length;r++)o.parts[r](i.parts[r]);for(;r<i.parts.length;r++)o.parts.push(f(i.parts[r],t))}else{for(var s=[],r=0;r<i.parts.length;r++)s.push(f(i.parts[r],t));h[i.id]={id:i.id,refs:1,parts:s}}}}function o(e,t){for(var n=[],i={},o=0;o<e.length;o++){var r=e[o],s=t.base?r[0]+t.base:r[0],a=r[1],c=r[2],l=r[3],f={css:a,media:c,sourceMap:l};i[s]?i[s].parts.push(f):n.push(i[s]={id:s,parts:[f]})}return n}function r(e,t){var n=m(e.insertInto);if(!n)throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");var i=y[y.length-1];if("top"===e.insertAt)i?i.nextSibling?n.insertBefore(t,i.nextSibling):n.appendChild(t):n.insertBefore(t,n.firstChild),y.push(t);else{if("bottom"!==e.insertAt)throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");n.appendChild(t)}}function s(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e);var t=y.indexOf(e);t>=0&&y.splice(t,1)}function a(e){var t=document.createElement("style");return e.attrs.type="text/css",l(t,e.attrs),r(e,t),t}function c(e){var t=document.createElement("link");return e.attrs.type="text/css",e.attrs.rel="stylesheet",l(t,e.attrs),r(e,t),t}function l(e,t){Object.keys(t).forEach(function(n){e.setAttribute(n,t[n])})}function f(e,t){var n,i,o,r;if(t.transform&&e.css){if(!(r=t.transform(e.css)))return function(){};e.css=r}if(t.singleton){var l=g++;n=b||(b=a(t)),i=u.bind(null,n,l,!1),o=u.bind(null,n,l,!0)}else e.sourceMap&&"function"==typeof URL&&"function"==typeof URL.createObjectURL&&"function"==typeof URL.revokeObjectURL&&"function"==typeof Blob&&"function"==typeof btoa?(n=c(t),i=p.bind(null,n,t),o=function(){s(n),n.href&&URL.revokeObjectURL(n.href)}):(n=a(t),i=d.bind(null,n),o=function(){s(n)});return i(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap)return;i(e=t)}else o()}}function u(e,t,n,i){var o=n?"":i.css;if(e.styleSheet)e.styleSheet.cssText=w(t,o);else{var r=document.createTextNode(o),s=e.childNodes;s[t]&&e.removeChild(s[t]),s.length?e.insertBefore(r,s[t]):e.appendChild(r)}}function d(e,t){var n=t.css,i=t.media;if(i&&e.setAttribute("media",i),e.styleSheet)e.styleSheet.cssText=n;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(n))}}function p(e,t,n){var i=n.css,o=n.sourceMap,r=void 0===t.convertToAbsoluteUrls&&o;(t.convertToAbsoluteUrls||r)&&(i=x(i)),o&&(i+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(o))))+" */");var s=new Blob([i],{type:"text/css"}),a=e.href;e.href=URL.createObjectURL(s),a&&URL.revokeObjectURL(a)}var h={},v=function(e){var t;return function(){return void 0===t&&(t=e.apply(this,arguments)),t}}(function(){return window&&document&&document.all&&!window.atob}),m=function(e){var t={};return function(n){return void 0===t[n]&&(t[n]=e.call(this,n)),t[n]}}(function(e){return document.querySelector(e)}),b=null,g=0,y=[],x=n(6);e.exports=function(e,t){if("undefined"!=typeof DEBUG&&DEBUG&&"object"!=typeof document)throw new Error("The style-loader cannot be used in a non-browser environment");t=t||{},t.attrs="object"==typeof t.attrs?t.attrs:{},t.singleton||(t.singleton=v()),t.insertInto||(t.insertInto="head"),t.insertAt||(t.insertAt="bottom");var n=o(e,t);return i(n,t),function(e){for(var r=[],s=0;s<n.length;s++){var a=n[s],c=h[a.id];c.refs--,r.push(c)}e&&i(o(e,t),t);for(var s=0;s<r.length;s++){var c=r[s];if(0===c.refs){for(var l=0;l<c.parts.length;l++)c.parts[l]();delete h[c.id]}}}};var w=function(){var e=[];return function(t,n){return e[t]=n,e.filter(Boolean).join("\n")}}()},function(e,t){e.exports=function(e){var t="undefined"!=typeof window&&window.location;if(!t)throw new Error("fixUrls requires window.location");if(!e||"string"!=typeof e)return e;var n=t.protocol+"//"+t.host,i=n+t.pathname.replace(/\/[^\/]*$/,"/");return e.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi,function(e,t){var o=t.trim().replace(/^"(.*)"$/,function(e,t){return t}).replace(/^'(.*)'$/,function(e,t){return t});if(/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(o))return e;var r;return r=0===o.indexOf("//")?o:0===o.indexOf("/")?n+o:i+o.replace(/^\.\//,""),"url("+JSON.stringify(r)+")"})}},function(e,t,n){"use strict";function i(e){return e&&e.__esModule?e:{default:e}}var o=n(0),r=i(o),s=n(8),a=i(s);e.exports={configure:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};r.default.save(e)},prepare:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};r.default.save(e),a.default.prepare()},success:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};a.default.pushNotification("success",e)},info:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};a.default.pushNotification("info",e)},warning:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};a.default.pushNotification("warning",e)},error:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};a.default.pushNotification("error",e)},neutral:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};a.default.pushNotification("neutral",e)},create:function(){a.default.pushNotification()}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var i=n(0),o=function(e){return e&&e.__esModule?e:{default:e}}(i);t.default={positions:["top left","top center","top right","bottom left","bottom center","bottom right"],elements:[],prepare:function(){var e=this;this.positions.forEach(function(t){var n=e.createElement("div",{class:"slee-element "+t});e.elements.push(n),document.body.appendChild(n)})},createElement:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],i=document.createElement(e);return Object.keys(t).forEach(function(e){i.setAttribute(e,t[e])}),n&&(i.innerText=n),i},pushNotification:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=o.default.data;e=e||n.type;var i=t.gap?t.gap:n.gap,r=t.position?t.position:n.position,s=t.pointerEvents?" pointer-events":n.pointerEvents?" pointer-events":"",a=void 0!==t.animation?t.animation?" "+t.animation:"":n.animation?" "+n.animation:"",c=this.createElement("div",{class:"slee-notification "+e+s+a,style:"margin-bottom: "+i+"px"}),l=this.createElement("div",{class:"slee-notification-content"}),f=t.title?t.title:n.title;if(f){var u=this.createElement("span",{class:"slee-title"},f);l.appendChild(u)}var d=t.description?t.description:n.description;if(d){var p=this.createElement("span",{class:"slee-description"},d);l.appendChild(p)}var h=void 0!==t.picture?t.picture:n.picture;if(h){l.classList.add("slee-picture");var v=this.createElement("div",{class:"slee-picture-wrapper"}),m=this.createElement("img",{src:h,alt:h});v.appendChild(m),l.appendChild(v)}var b=void 0!==t.autoHide?t.autoHide:n.autoHide,g=t.hideDelay?t.hideDelay:n.hideDelay?n.hideDelay:4e3;b&&this.hideNotification(c,g);var y=t.clickToHide?t.clickToHide:n.clickToHide,x=void 0!==t.action?t.action:n.action;y&&!x&&this.clickToHide(c),x&&this.createAction(c,x),c.appendChild(l),this.elements[this.positions.indexOf(r)].appendChild(c)},hideNotification:function(e,t){function n(){return setTimeout(function(){e.classList.add("hide"),setTimeout(function(){e.parentNode&&e.parentNode.removeChild(e),e.removeEventListener("mouseover",i),e.removeEventListener("mouseout",o)},300)},t)}function i(){clearInterval(r)}function o(){r=n()}var r=n();e.addEventListener("mouseover",i),e.addEventListener("mouseout",o)},clickToHide:function(e){function t(){e.classList.add("hide"),e.removeEventListener("click",t),setTimeout(function(){e.parentNode.removeChild(e)},300)}e.addEventListener("click",t)},createAction:function(e,t){var n=this,i=function i(){t(),e.removeEventListener("click",i),n.clickToHide(e),e.click()};e.addEventListener("click",i)}}},function(e,t,n){"use strict";n(1),e.exports=n(7)}])});

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./Account": 9,
	"./Account.js": 9,
	"./Appearance": 10,
	"./Appearance.js": 10
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number or string
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 108;

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = debounce;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(110)))

/***/ }),
/* 110 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

var _Main = __webpack_require__(6);

var _Main2 = _interopRequireDefault(_Main);

var _Counters = __webpack_require__(112);

var _Counters2 = _interopRequireDefault(_Counters);

var _Components = __webpack_require__(113);

var _Components2 = _interopRequireDefault(_Components);

var _Flatpickr = __webpack_require__(116);

var _Flatpickr2 = _interopRequireDefault(_Flatpickr);

var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

var _sortablejs = __webpack_require__(11);

var _sortablejs2 = _interopRequireDefault(_sortablejs);

var _Ajax = __webpack_require__(2);

var _Ajax2 = _interopRequireDefault(_Ajax);

var _Router = __webpack_require__(3);

var _Router2 = _interopRequireDefault(_Router);

var _Slee = __webpack_require__(7);

var _Slee2 = _interopRequireDefault(_Slee);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {

    LOCALES: ['system', 'response', 'admin_write', 'components'],
    components: [],

    initialize: function initialize() {
        var _this = this;

        // Render content
        _Main2.default.createView(this.LOCALES).then(function () {

            // Current route locale
            var contentType = document.querySelector('.content-content').dataset.type;
            _Global2.default.translate.addTranslation('admin_write/' + contentType);

            // Until Packery is broken else initialize Packery
            _Global2.default.packery = {};
            _Global2.default.packery.reloadItems = function () {};

            // Load and resume components
            _this.listComponents();
            _this.prepareComponents();

            // Enable libraries
            _this.enableLibraries();

            // Register events
            _this.registerEvents();
        });
    },
    listComponents: function listComponents() {

        var componentElements = document.querySelectorAll('.component-element');

        this.components = Array.from(componentElements).map(function (componentElement) {
            return componentElement.getAttribute('data-component');
        });
    },
    prepareComponents: function prepareComponents() {

        this.initializeComponents();
    },
    initializeComponents: function initializeComponents() {

        _Global2.default.componentsModule = new _Components2.default(this.components);
    },
    enableLibraries: function enableLibraries() {

        // Counters
        _Counters2.default.initialize();

        // Packery
        //const Packery = require('../../vendor/packery');
        /*Global.packery = new Packery('.content-settings', {
            itemSelector: '.component-element',
            gutter: 22
        });*/

        // Sortable
        var sortableElement = document.querySelector('div.content-builder-content');

        if (sortableElement) {

            _sortablejs2.default.create(sortableElement, {
                sort: true,
                animation: 200,
                scroll: true,
                draggable: '.component-element',
                handle: '.component-inline-drag',
                onChoose: function onChoose() {
                    var elements = document.querySelectorAll('div.component-placeholder');
                    elements.forEach(function (element) {
                        element.classList.remove('hide');
                    });
                },
                onStart: function onStart(event) {
                    var identifier = event.item.attributes['data-id'].value;
                    if (CKEDITOR.instances['editor_' + identifier]) CKEDITOR.instances['editor_' + identifier].destroy();
                },
                onEnd: function onEnd(event) {
                    var element = event.item;
                    var identifier = element.attributes['data-id'].value;
                    var component = element.attributes['data-component'].value;
                    if (component in _Global2.default.componentsModule.modules) {
                        if ('reload' in _Global2.default.componentsModule.modules[component]) _Global2.default.componentsModule.modules[component].reload(identifier);
                    }
                    var elements = document.querySelectorAll('div.component-placeholder');
                    elements.forEach(function (element) {
                        element.classList.add('hide');
                    });
                }
            });
        }

        _Utils2.default.triggerEvent(document, 'resize');

        // Flatpickr
        _Flatpickr2.default.initialize();
    },
    registerEvents: function registerEvents() {
        var _this2 = this;

        var contentSettings = document.querySelector('.content-settings');

        document.querySelector('.content-wrapper').addEventListener('click', function (event) {

            var target = event.target;

            // Open / Close Content Settings
            if (target.matches('.collapse-trigger *')) {
                contentSettings.classList.toggle('open');
                _Global2.default.packery.reloadItems();
            }

            // Add inline component
            else if (target.matches('.builder-tools .add-content')) {
                    var component = target.getAttribute('data-content');
                    _Global2.default.componentsModule.createComponent(component);
                }

                // Save article
                else if (target.matches('.save-content')) _this2.processAction(0);

                    // Save and publish article
                    else if (target.matches('.publish-content')) _this2.processAction(1);
        });
    },
    processAction: function processAction(actionType) {

        var componentsData = this.prepareComponentsData();

        if (!componentsData) return false;

        componentsData.action = actionType;

        _Ajax2.default.post(_Router2.default.createLink('write'), componentsData, this.actionResponse);
    },
    actionResponse: function actionResponse(response, status) {

        try {

            response = JSON.parse(response);

            if (status !== 'success') _Slee2.default.error('ERROR', 0);else if (response.code !== 200) _Slee2.default.error('ERROR', response.code);else {

                if (response.article_id) {
                    document.querySelector('.content-content').dataset.id = response.article_id;
                    _Slee2.default.success('SUCCESS', 'ARTICLE_SAVED');
                } else _Slee2.default.error('ERROR', 0);
            }
        } catch (e) {
            _Slee2.default.error('ERROR', 0);
        }
    },
    createComponentsOrder: function createComponentsOrder() {

        var componentsWrapper = document.querySelector('.content-builder-content');
        var order = [];

        Array.from(componentsWrapper.children).forEach(function (component) {

            if (!component.dataset.id) return false;

            order.push(component.dataset.id);
        });

        return order;
    },
    prepareComponentsData: function prepareComponentsData() {

        // Validate data
        if (!_Global2.default.componentsModule.validate()) {
            _Slee2.default.error('ERROR', 'EMPTY_INPUT');
            return false;
        }

        // Serialize data
        var serializedData = _Global2.default.componentsModule.serialize();

        // Create components order
        var componentsOrder = this.createComponentsOrder();

        // Prepare result data
        var contentElement = document.querySelector('.content-content');
        var resultData = {
            type: contentElement.dataset.type,
            order: componentsOrder,
            components: serializedData
        };

        // Get current article ID if any
        var articleID = contentElement.dataset.id;

        if (articleID !== '') resultData.articleID = articleID;

        return resultData;
    }
};

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
    initialize: function initialize() {

        var counterElements = document.querySelectorAll('.counter');

        counterElements.forEach(function (counterElement) {

            var maxLength = counterElement.getAttribute('data-length') || 0;
            var target = counterElement.getAttribute('data-input') || 'input';
            var inputElement = counterElement.parentNode.querySelector(target);

            counterElement.innerText = maxLength;
            inputElement.addEventListener('input', function () {

                var charactersLeft = +maxLength - inputElement.value.trim().length;
                counterElement.innerText = charactersLeft;

                if (charactersLeft < 0) counterElement.classList.add('minus');else counterElement.classList.remove('minus');
            });

            _Utils2.default.triggerEvent(inputElement, 'input');
        });
    }
};

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _class = function () {

    /*
     * COMPONENT INITIALIZATION
     */

    /**
     * Start the component system and prepare components for use
     */
    function _class(components) {
        _classCallCheck(this, _class);

        this.components = [];
        this.modules = {};

        this.components = components;
        this.initializeComponents();
        this.resumeComponents();
    }

    /**
     * Initialize single component with all events
     */


    _createClass(_class, [{
        key: "initializeComponent",
        value: function initializeComponent(component) {

            // Select component
            var componentData = __webpack_require__(114)("./" + component);

            if (componentData.start) componentData.start();

            if (componentData.resume) componentData.resume();

            this.modules[component] = componentData;

            if (!componentData.events) return false;

            var eventsData = componentData.events;
            _Utils2.default.registerEvents(eventsData);
        }

        /**
         * Initialize all components needed
         */

    }, {
        key: "initializeComponents",
        value: function initializeComponents() {
            var _this = this;

            this.components.forEach(function (component) {
                return _this.initializeComponent(component);
            });
        }

        /*
         * DATA MANIPULATION
         */

        /**
         * Validate data of all components
         */

    }, {
        key: "validate",
        value: function validate() {

            for (var component = 0; component < this.components.length; ++component) {
                if (!this.modules[this.components[component]].validate()) return false;
            }return true;
        }

        /**
         * Serialize data from all components
         */

    }, {
        key: "serialize",
        value: function serialize() {
            var _this2 = this;

            var result = {};

            this.components.forEach(function (component) {
                result[component] = _this2.modules[component].serialize();
            });

            return result;
        }

        /*
         * COMPONENT INSTANCES
         */

        /**
         * Create component element from template
         * @param componentName
         * @return {*}
         */

    }, {
        key: "createFromTemplate",
        value: function createFromTemplate(componentName) {

            var templateElement = document.querySelector('#component_' + componentName + '_template');

            if (!templateElement) return false;

            return templateElement.children[0].cloneNode(true);
        }

        /**
         * Create new component instance
         */

    }, {
        key: "createComponent",
        value: function createComponent(componentName) {

            var inlineElement = document.querySelector('div.content-builder-content');

            if (typeof inlineElement === 'undefined') return false;

            if (!(componentName in this.modules)) return false;

            if (!("create" in this.modules[componentName])) return false;

            var template = this.createFromTemplate(componentName);

            if (!template) return false;

            var identifier = +new Date();
            template.setAttribute('data-id', identifier);

            this.modules[componentName].create(identifier, template);
            this.registerEvents(componentName, identifier, template);
            inlineElement.appendChild(template);

            if ('onCreate' in this.modules[componentName]) this.modules[componentName].onCreate(identifier);
        }

        /**
         * Register default events for new component instance
         */

    }, {
        key: "registerEvents",
        value: function registerEvents(name, identifier, parentElement, data) {
            var _this3 = this;

            var headerElement = parentElement.querySelector('div.component-element-header');
            var contentElement = parentElement.querySelector('div.component-element-content');
            var titleElement = headerElement.children[1];
            var titleDefault = titleElement.innerText;

            if (data && data.title && data.title !== '') titleElement.innerText = data.title.trim();

            // Delegate default events
            _Utils2.default.registerEvents([{
                event: 'click',
                element: headerElement,
                content: function content(event) {

                    if (!event.target) return false;

                    var element = event.target;

                    // Select component title and focus
                    if (element.matches('.component-inline-label')) {
                        element.focus();
                        document.execCommand('selectAll', false, null);
                    }

                    // Collapse / Show component content
                    else if (element.matches('.component-inline-collapse')) contentElement.classList.toggle('hide');

                        // Disable / Enable component
                        else if (element.matches('.component-inline-disable')) {
                                parentElement.classList.toggle('disabled');
                                element.classList.toggle('icon-off');
                                _this3.modules[name].data[identifier].disabled ^= true;
                            }

                            // Remove component instance
                            else if (element.matches('.component-inline-remove')) {

                                    var componentName = headerElement.querySelector('.component-inline-label').innerText.trim();
                                    var actionText = _Global2.default.translate.locale.response['ACTION_CONFIRM_REMOVE_COMPONENT'].replace('%component%', componentName);

                                    _Utils2.default.confirmAction(actionText, function () {
                                        parentElement.parentNode.removeChild(parentElement);
                                        delete _this3.modules[name].data[identifier];
                                    });
                                }
                }
            }, {
                // Show placeholder when empty title
                event: 'blur',
                element: titleElement,
                content: function content() {
                    if (titleElement.innerText.trim() === '') titleElement.innerText = titleDefault;
                }
            }, {
                // Submit title on enter
                event: 'keypress',
                element: titleElement,
                content: function content(event) {

                    if (!event.keyCode || event.keyCode !== 13) return false;

                    titleElement.blur();
                    window.getSelection().removeAllRanges();
                    event.preventDefault();
                }
            }, {
                // Serialize component title
                event: 'keyup change',
                element: titleElement,
                content: function content(event) {
                    _this3.modules[name].data[identifier].title = event.target.innerText.trim();
                }
            }]);

            if (data && data.disabled !== 0) _Utils2.default.triggerEvent(headerElement.querySelector('.component-inline-disable'), 'click');
        }

        /*
         * RESUME MULTI INSTANCE COMPONENTS
         */

        /**
         * Resume multi instance components into content element
         */

    }, {
        key: "resumeComponents",
        value: function resumeComponents() {
            var _this4 = this;

            // Get components order
            var contentElement = document.querySelector('[data-order]');

            if (!contentElement) return true;

            var json = contentElement.getAttribute('data-order');

            if (!json || json === '') return false;

            var order = JSON.parse(contentElement.getAttribute('data-order'));

            if (!order || order === '') return true;

            // Save resume data
            var componentsResumeData = {};
            this.components.forEach(function (componentName) {

                var template = _this4.createFromTemplate(componentName);

                if (!template) return false;

                var resumeData = template.getAttribute('data-resume');

                if (!resumeData) return false;

                componentsResumeData[componentName] = {
                    template: template,
                    resume: JSON.parse(resumeData)
                };
            });

            // Resume each component
            if ((typeof order === "undefined" ? "undefined" : _typeof(order)) !== 'object') return true;

            order.forEach(function (componentID) {

                _this4.components.some(function (componentName) {

                    if (!componentsResumeData[componentName] || !componentsResumeData[componentName].template || !componentsResumeData[componentName].resume || !componentsResumeData[componentName].resume[componentID]) return false;

                    var current = _this4.modules[componentName];
                    var data = componentsResumeData[componentName];
                    var template = data.template.cloneNode(true);
                    var resumeData = data.resume[componentID];

                    template.setAttribute('data-id', componentID);

                    if (!current.resumeInline) return false;

                    current.resumeInline(componentID, template, resumeData);
                    _this4.registerEvents(componentName, componentID, template, resumeData);
                    contentElement.appendChild(template);

                    if (current.onCreate) current.onCreate(componentID);

                    return true;
                });
            });
        }
    }]);

    return _class;
}();

exports.default = _class;
;

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./accessibility": 59,
	"./accessibility.js": 59,
	"./analytics": 60,
	"./analytics.js": 60,
	"./attachments": 61,
	"./attachments.js": 61,
	"./audio": 62,
	"./audio.js": 62,
	"./author": 63,
	"./author.js": 63,
	"./categories": 64,
	"./categories.js": 64,
	"./code": 65,
	"./code.js": 65,
	"./comments": 66,
	"./comments.js": 66,
	"./copyright": 67,
	"./copyright.js": 67,
	"./created_at": 68,
	"./created_at.js": 68,
	"./custom_fields": 69,
	"./custom_fields.js": 69,
	"./excerpt": 70,
	"./excerpt.js": 70,
	"./gallery": 71,
	"./gallery.js": 71,
	"./header_image": 72,
	"./header_image.js": 72,
	"./heading": 73,
	"./heading.js": 73,
	"./languages": 74,
	"./languages.js": 74,
	"./last_update": 75,
	"./last_update.js": 75,
	"./link": 76,
	"./link.js": 76,
	"./list": 77,
	"./list.js": 77,
	"./menu_link": 78,
	"./menu_link.js": 78,
	"./meta": 79,
	"./meta.js": 79,
	"./mistakes": 80,
	"./mistakes.js": 80,
	"./note": 81,
	"./note.js": 81,
	"./perex": 82,
	"./perex.js": 82,
	"./picture": 83,
	"./picture.js": 83,
	"./pin": 84,
	"./pin.js": 84,
	"./planner": 85,
	"./planner.js": 85,
	"./poll": 86,
	"./poll.js": 86,
	"./quote": 87,
	"./quote.js": 87,
	"./rating": 88,
	"./rating.js": 88,
	"./revisions": 89,
	"./revisions.js": 89,
	"./rich_text": 90,
	"./rich_text.js": 90,
	"./sources": 91,
	"./sources.js": 91,
	"./status": 92,
	"./status.js": 92,
	"./table": 93,
	"./table.js": 93,
	"./tags": 94,
	"./tags.js": 94,
	"./thumbnail": 95,
	"./thumbnail.js": 95,
	"./title": 96,
	"./title.js": 96,
	"./url": 97,
	"./url.js": 97,
	"./video": 98,
	"./video.js": 98
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number or string
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 114;

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {

    // CKEditor config
    editor: {
        language: _Global2.default.$html.attr('lang'),
        uiColor: '#ffffff',
        extraPlugins: 'autogrow',
        autoGrow_minHeight: 150,
        autoGrow_maxHeight: 700,
        autoGrow_onStartup: true,
        toolbar: [{
            name: 'history',
            items: ['Undo', 'Redo']
        }, {
            name: 'clipboard',
            items: ['Cut', 'Copy', 'Paste', 'PasteFromWord']
        }, {
            name: 'basic',
            items: ['Bold', 'Italic', 'Underline', 'Strike', 'Subscript', 'Superscript']
        }, {
            name: 'lists',
            items: ['NumberedList', 'BulletedList', '-', 'Outdent', 'Indent']
        }, {
            name: 'justify',
            items: ['JustifyLeft', 'JustifyCenter', 'JustifyRight', 'JustifyBlock']
        }, {
            name: 'links',
            items: ['Link', 'Unlink']
        }, {
            name: 'advanced',
            items: ['HorizontalRule', 'Symbol', 'EqnEditor']
        }, {
            name: 'color',
            items: ['TextColor', 'BGColor']
        }]
    }

};

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _flatpickr = __webpack_require__(117);

var _flatpickr2 = _interopRequireDefault(_flatpickr);

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {

    locale: null,

    initialize: function initialize() {

        var lang = _Global2.default.translate.language;

        if (lang === 'en') lang = 'uk';

        this.locale = __webpack_require__(118)("./" + lang);

        this.dateTimePicker();
        this.dateTimePickerMin();
        this.dateTimePickerMax();
        this.datePicker();
        this.datePickerMax();
        this.datePickerMin();
    },
    dateTimePicker: function dateTimePicker() {

        (0, _flatpickr2.default)(".datetime-picker", {
            altFormat: true,
            dateFormat: 'd.m.Y H:i:s',
            enableTime: true,
            enableSeconds: true,
            locale: this.locale,
            disableMobile: true,
            time_24hr: true
        });
    },
    dateTimePickerMin: function dateTimePickerMin() {

        (0, _flatpickr2.default)(".datetime-picker-min", {
            altFormat: true,
            dateFormat: 'd.m.Y H:i:s',
            enableTime: true,
            enableSeconds: true,
            minDate: 'today',
            locale: this.locale,
            disableMobile: true,
            time_24hr: true
        });
    },
    dateTimePickerMax: function dateTimePickerMax() {

        (0, _flatpickr2.default)(".datetime-picker-max", {
            altFormat: true,
            dateFormat: 'd.m.Y H:i:s',
            enableTime: true,
            enableSeconds: true,
            maxDate: 'today',
            locale: this.locale,
            disableMobile: true,
            time_24hr: true
        });
    },
    datePicker: function datePicker() {

        (0, _flatpickr2.default)(".date-picker", {
            altFormat: true,
            dateFormat: 'd.m.Y',
            locale: this.locale,
            disableMobile: true
        });
    },
    datePickerMax: function datePickerMax() {

        (0, _flatpickr2.default)(".date-picker-max", {
            altFormat: true,
            dateFormat: 'd.m.Y',
            maxDate: 'today',
            locale: this.locale,
            disableMobile: true
        });
    },
    datePickerMin: function datePickerMin() {

        (0, _flatpickr2.default)(".date-picker-min", {
            altFormat: true,
            dateFormat: 'd.m.Y',
            minDate: 'today',
            locale: this.locale,
            disableMobile: true
        });
    }
};

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! flatpickr v3.0.6, @license MIT */
function FlatpickrInstance(element, config) {
	var self = this;

	self._ = {};
	self._.afterDayAnim = afterDayAnim;
	self._bind = bind;
	self._compareDates = compareDates;
	self._setHoursFromDate = setHoursFromDate;
	self.changeMonth = changeMonth;
	self.changeYear = changeYear;
	self.clear = clear;
	self.close = close;
	self._createElement = createElement;
	self.destroy = destroy;
	self.isEnabled = isEnabled;
	self.jumpToDate = jumpToDate;
	self.open = open;
	self.redraw = redraw;
	self.set = set;
	self.setDate = setDate;
	self.toggle = toggle;

	function init() {
		self.element = self.input = element;
		self.instanceConfig = config || {};
		self.parseDate = FlatpickrInstance.prototype.parseDate.bind(self);
		self.formatDate = FlatpickrInstance.prototype.formatDate.bind(self);

		setupFormats();
		parseConfig();
		setupLocale();
		setupInputs();
		setupDates();
		setupHelperFunctions();

		self.isOpen = false;

		self.isMobile = !self.config.disableMobile && !self.config.inline && self.config.mode === "single" && !self.config.disable.length && !self.config.enable.length && !self.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

		if (!self.isMobile) build();

		bindEvents();

		if (self.selectedDates.length || self.config.noCalendar) {
			if (self.config.enableTime) {
				setHoursFromDate(self.config.noCalendar ? self.latestSelectedDateObj || self.config.minDate : null);
			}
			updateValue(false);
		}

		self.showTimeInput = self.selectedDates.length > 0 || self.config.noCalendar;

		if (self.config.weekNumbers) {
			self.calendarContainer.style.width = self.daysContainer.offsetWidth + self.weekWrapper.offsetWidth + "px";
		}

		if (!self.isMobile) positionCalendar();

		triggerEvent("Ready");
	}

	/**
  * Binds a function to the current flatpickr instance
  * @param {Function} fn the function
  * @return {Function} the function bound to the instance
  */
	function bindToInstance(fn) {
		return fn.bind(self);
	}

	/**
  * The handler for all events targeting the time inputs
  * @param {Event} e the event - "input", "wheel", "increment", etc
  */
	function updateTime(e) {
		if (self.config.noCalendar && !self.selectedDates.length)
			// picking time only
			self.selectedDates = [self.now];

		timeWrapper(e);

		if (!self.selectedDates.length) return;

		if (!self.minDateHasTime || e.type !== "input" || e.target.value.length >= 2) {
			setHoursFromInputs();
			updateValue();
		} else {
			setTimeout(function () {
				setHoursFromInputs();
				updateValue();
			}, 1000);
		}
	}

	/**
  * Syncs the selected date object time with user's time input
  */
	function setHoursFromInputs() {
		if (!self.config.enableTime) return;

		var hours = (parseInt(self.hourElement.value, 10) || 0) % (self.amPM ? 12 : 24),
		    minutes = (parseInt(self.minuteElement.value, 10) || 0) % 60,
		    seconds = self.config.enableSeconds ? (parseInt(self.secondElement.value, 10) || 0) % 60 : 0;

		if (self.amPM !== undefined) hours = hours % 12 + 12 * (self.amPM.textContent === "PM");

		if (self.minDateHasTime && compareDates(self.latestSelectedDateObj, self.config.minDate) === 0) {

			hours = Math.max(hours, self.config.minDate.getHours());
			if (hours === self.config.minDate.getHours()) minutes = Math.max(minutes, self.config.minDate.getMinutes());
		}

		if (self.maxDateHasTime && compareDates(self.latestSelectedDateObj, self.config.maxDate) === 0) {
			hours = Math.min(hours, self.config.maxDate.getHours());
			if (hours === self.config.maxDate.getHours()) minutes = Math.min(minutes, self.config.maxDate.getMinutes());
		}

		setHours(hours, minutes, seconds);
	}

	/**
  * Syncs time input values with a date
  * @param {Date} dateObj the date to sync with
  */
	function setHoursFromDate(dateObj) {
		var date = dateObj || self.latestSelectedDateObj;

		if (date) setHours(date.getHours(), date.getMinutes(), date.getSeconds());
	}

	/**
  * Sets the hours, minutes, and optionally seconds
  * of the latest selected date object and the
  * corresponding time inputs
  * @param {Number} hours the hour. whether its military
  *                 or am-pm gets inferred from config
  * @param {Number} minutes the minutes
  * @param {Number} seconds the seconds (optional)
  */
	function setHours(hours, minutes, seconds) {
		if (self.selectedDates.length) {
			self.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
		}

		if (!self.config.enableTime || self.isMobile) return;

		self.hourElement.value = self.pad(!self.config.time_24hr ? (12 + hours) % 12 + 12 * (hours % 12 === 0) : hours);

		self.minuteElement.value = self.pad(minutes);

		if (!self.config.time_24hr) self.amPM.textContent = hours >= 12 ? "PM" : "AM";

		if (self.config.enableSeconds === true) self.secondElement.value = self.pad(seconds);
	}

	/**
  * Handles the year input and incrementing events
  * @param {Event} event the keyup or increment event
  */
	function onYearInput(event) {
		var year = event.target.value;
		if (event.delta) year = (parseInt(year) + event.delta).toString();

		if (year.length === 4 || event.key === "Enter") {
			self.currentYearElement.blur();
			if (!/[^\d]/.test(year)) changeYear(year);
		}
	}

	/**
  * Essentially addEventListener + tracking
  * @param {Element} element the element to addEventListener to
  * @param {String} event the event name
  * @param {Function} handler the event handler
  */
	function bind(element, event, handler) {
		if (event instanceof Array) return event.forEach(function (ev) {
			return bind(element, ev, handler);
		});

		if (element instanceof Array) return element.forEach(function (el) {
			return bind(el, event, handler);
		});

		element.addEventListener(event, handler);
		self._handlers.push({ element: element, event: event, handler: handler });
	}

	/**
  * A mousedown handler which mimics click.
  * Minimizes latency, since we don't need to wait for mouseup in most cases.
  * Also, avoids handling right clicks.
  *
  * @param {Function} handler the event handler
  */
	function onClick(handler) {
		return function (evt) {
			return evt.which === 1 && handler(evt);
		};
	}

	/**
  * Adds all the necessary event listeners
  */
	function bindEvents() {
		self._handlers = [];
		self._animationLoop = [];
		if (self.config.wrap) {
			["open", "close", "toggle", "clear"].forEach(function (evt) {
				Array.prototype.forEach.call(self.element.querySelectorAll("[data-" + evt + "]"), function (el) {
					return bind(el, "mousedown", onClick(self[evt]));
				});
			});
		}

		if (self.isMobile) return setupMobile();

		self.debouncedResize = debounce(onResize, 50);
		self.triggerChange = function () {
			triggerEvent("Change");
		};
		self.debouncedChange = debounce(self.triggerChange, 300);

		if (self.config.mode === "range" && self.daysContainer) bind(self.daysContainer, "mouseover", function (e) {
			return onMouseOver(e.target);
		});

		bind(window.document.body, "keydown", onKeyDown);

		if (!self.config.static) bind(self._input, "keydown", onKeyDown);

		if (!self.config.inline && !self.config.static) bind(window, "resize", self.debouncedResize);

		if (window.ontouchstart !== undefined) bind(window.document, "touchstart", documentClick);

		bind(window.document, "mousedown", onClick(documentClick));
		bind(self._input, "blur", documentClick);

		if (self.config.clickOpens === true) {
			bind(self._input, "focus", self.open);
			bind(self._input, "mousedown", onClick(self.open));
		}

		if (!self.config.noCalendar) {
			self.monthNav.addEventListener("wheel", function (e) {
				return e.preventDefault();
			});
			bind(self.monthNav, "wheel", debounce(onMonthNavScroll, 10));
			bind(self.monthNav, "mousedown", onClick(onMonthNavClick));

			bind(self.monthNav, ["keyup", "increment"], onYearInput);
			bind(self.daysContainer, "mousedown", onClick(selectDate));

			if (self.config.animate) {
				bind(self.daysContainer, ["webkitAnimationEnd", "animationend"], animateDays);
				bind(self.monthNav, ["webkitAnimationEnd", "animationend"], animateMonths);
			}
		}

		if (self.config.enableTime) {
			var selText = function selText(e) {
				return e.target.select();
			};
			bind(self.timeContainer, ["wheel", "input", "increment"], updateTime);
			bind(self.timeContainer, "mousedown", onClick(timeIncrement));

			bind(self.timeContainer, ["wheel", "increment"], self.debouncedChange);
			bind(self.timeContainer, "input", self.triggerChange);

			bind([self.hourElement, self.minuteElement], "focus", selText);

			if (self.secondElement !== undefined) bind(self.secondElement, "focus", function () {
				return self.secondElement.select();
			});

			if (self.amPM !== undefined) {
				bind(self.amPM, "mousedown", onClick(function (e) {
					updateTime(e);
					self.triggerChange(e);
				}));
			}
		}
	}

	function processPostDayAnimation() {
		for (var i = self._animationLoop.length; i--;) {
			self._animationLoop[i]();
			self._animationLoop.splice(i, 1);
		}
	}

	/**
  * Removes the day container that slided out of view
  * @param {Event} e the animation event
  */
	function animateDays(e) {
		if (self.daysContainer.childNodes.length > 1) {
			switch (e.animationName) {
				case "fpSlideLeft":
					self.daysContainer.lastChild.classList.remove("slideLeftNew");
					self.daysContainer.removeChild(self.daysContainer.firstChild);
					self.days = self.daysContainer.firstChild;
					processPostDayAnimation();

					break;

				case "fpSlideRight":
					self.daysContainer.firstChild.classList.remove("slideRightNew");
					self.daysContainer.removeChild(self.daysContainer.lastChild);
					self.days = self.daysContainer.firstChild;
					processPostDayAnimation();

					break;

				default:
					break;
			}
		}
	}

	/**
  * Removes the month element that animated out of view
  * @param {Event} e the animation event
  */
	function animateMonths(e) {
		switch (e.animationName) {
			case "fpSlideLeftNew":
			case "fpSlideRightNew":
				self.navigationCurrentMonth.classList.remove("slideLeftNew");
				self.navigationCurrentMonth.classList.remove("slideRightNew");
				var nav = self.navigationCurrentMonth;

				while (nav.nextSibling && /curr/.test(nav.nextSibling.className)) {
					self.monthNav.removeChild(nav.nextSibling);
				}while (nav.previousSibling && /curr/.test(nav.previousSibling.className)) {
					self.monthNav.removeChild(nav.previousSibling);
				}self.oldCurMonth = null;
				break;
		}
	}

	/**
  * Set the calendar view to a particular date.
  * @param {Date} jumpDate the date to set the view to
  */
	function jumpToDate(jumpDate) {
		jumpDate = jumpDate ? self.parseDate(jumpDate) : self.latestSelectedDateObj || (self.config.minDate > self.now ? self.config.minDate : self.config.maxDate && self.config.maxDate < self.now ? self.config.maxDate : self.now);

		try {
			self.currentYear = jumpDate.getFullYear();
			self.currentMonth = jumpDate.getMonth();
		} catch (e) {
			/* istanbul ignore next */
			console.error(e.stack);
			/* istanbul ignore next */
			console.warn("Invalid date supplied: " + jumpDate);
		}

		self.redraw();
	}

	/**
  * The up/down arrow handler for time inputs
  * @param {Event} e the click event
  */
	function timeIncrement(e) {
		if (~e.target.className.indexOf("arrow")) incrementNumInput(e, e.target.classList.contains("arrowUp") ? 1 : -1);
	}

	/**
  * Increments/decrements the value of input associ-
  * ated with the up/down arrow by dispatching an
  * "increment" event on the input.
  *
  * @param {Event} e the click event
  * @param {Number} delta the diff (usually 1 or -1)
  * @param {Element} inputElem the input element
  */
	function incrementNumInput(e, delta, inputElem) {
		var input = inputElem || e.target.parentNode.childNodes[0];
		var event = createEvent("increment");
		event.delta = delta;
		input.dispatchEvent(event);
	}

	function createNumberInput(inputClassName) {
		var wrapper = createElement("div", "numInputWrapper"),
		    numInput = createElement("input", "numInput " + inputClassName),
		    arrowUp = createElement("span", "arrowUp"),
		    arrowDown = createElement("span", "arrowDown");

		numInput.type = "text";
		numInput.pattern = "\\d*";

		wrapper.appendChild(numInput);
		wrapper.appendChild(arrowUp);
		wrapper.appendChild(arrowDown);

		return wrapper;
	}

	function build() {
		var fragment = window.document.createDocumentFragment();
		self.calendarContainer = createElement("div", "flatpickr-calendar");
		self.calendarContainer.tabIndex = -1;

		if (!self.config.noCalendar) {
			fragment.appendChild(buildMonthNav());
			self.innerContainer = createElement("div", "flatpickr-innerContainer");

			if (self.config.weekNumbers) self.innerContainer.appendChild(buildWeeks());

			self.rContainer = createElement("div", "flatpickr-rContainer");
			self.rContainer.appendChild(buildWeekdays());

			if (!self.daysContainer) {
				self.daysContainer = createElement("div", "flatpickr-days");
				self.daysContainer.tabIndex = -1;
			}

			buildDays();
			self.rContainer.appendChild(self.daysContainer);

			self.innerContainer.appendChild(self.rContainer);
			fragment.appendChild(self.innerContainer);
		}

		if (self.config.enableTime) fragment.appendChild(buildTime());

		toggleClass(self.calendarContainer, "rangeMode", self.config.mode === "range");
		toggleClass(self.calendarContainer, "animate", self.config.animate);

		self.calendarContainer.appendChild(fragment);

		var customAppend = self.config.appendTo && self.config.appendTo.nodeType;

		if (self.config.inline || self.config.static) {
			self.calendarContainer.classList.add(self.config.inline ? "inline" : "static");

			if (self.config.inline && !customAppend) {
				return self.element.parentNode.insertBefore(self.calendarContainer, self._input.nextSibling);
			}

			if (self.config.static) {
				var wrapper = createElement("div", "flatpickr-wrapper");
				self.element.parentNode.insertBefore(wrapper, self.element);
				wrapper.appendChild(self.element);

				if (self.altInput) wrapper.appendChild(self.altInput);

				wrapper.appendChild(self.calendarContainer);
				return;
			}
		}

		(customAppend ? self.config.appendTo : window.document.body).appendChild(self.calendarContainer);
	}

	function createDay(className, date, dayNumber, i) {
		var dateIsEnabled = isEnabled(date, true),
		    dayElement = createElement("span", "flatpickr-day " + className, date.getDate());

		dayElement.dateObj = date;
		dayElement.$i = i;
		dayElement.setAttribute("aria-label", self.formatDate(date, self.config.ariaDateFormat));

		if (compareDates(date, self.now) === 0) {
			self.todayDateElem = dayElement;
			dayElement.classList.add("today");
		}

		if (dateIsEnabled) {
			dayElement.tabIndex = -1;
			if (isDateSelected(date)) {
				dayElement.classList.add("selected");
				self.selectedDateElem = dayElement;
				if (self.config.mode === "range") {
					toggleClass(dayElement, "startRange", compareDates(date, self.selectedDates[0]) === 0);

					toggleClass(dayElement, "endRange", compareDates(date, self.selectedDates[1]) === 0);
				}
			}
		} else {
			dayElement.classList.add("disabled");
			if (self.selectedDates[0] && date > self.minRangeDate && date < self.selectedDates[0]) self.minRangeDate = date;else if (self.selectedDates[0] && date < self.maxRangeDate && date > self.selectedDates[0]) self.maxRangeDate = date;
		}

		if (self.config.mode === "range") {
			if (isDateInRange(date) && !isDateSelected(date)) dayElement.classList.add("inRange");

			if (self.selectedDates.length === 1 && (date < self.minRangeDate || date > self.maxRangeDate)) dayElement.classList.add("notAllowed");
		}

		if (self.config.weekNumbers && className !== "prevMonthDay" && dayNumber % 7 === 1) {
			self.weekNumbers.insertAdjacentHTML("beforeend", "<span class='disabled flatpickr-day'>" + self.config.getWeek(date) + "</span>");
		}

		triggerEvent("DayCreate", dayElement);

		return dayElement;
	}

	function focusOnDay(currentIndex, offset) {
		var newIndex = currentIndex + offset || 0,
		    targetNode = currentIndex !== undefined ? self.days.childNodes[newIndex] : self.selectedDateElem || self.todayDateElem || self.days.childNodes[0],
		    focus = function focus() {
			targetNode = targetNode || self.days.childNodes[newIndex];
			targetNode.focus();

			if (self.config.mode === "range") onMouseOver(targetNode);
		};

		if (targetNode === undefined && offset !== 0) {
			if (offset > 0) {
				self.changeMonth(1);
				newIndex = newIndex % 42;
			} else if (offset < 0) {
				self.changeMonth(-1);
				newIndex += 42;
			}

			return afterDayAnim(focus);
		}

		focus();
	}

	function afterDayAnim(fn) {
		if (self.config.animate === true) return self._animationLoop.push(fn);
		fn();
	}

	function buildDays(delta) {
		var firstOfMonth = (new Date(self.currentYear, self.currentMonth, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7,
		    isRangeMode = self.config.mode === "range";

		self.prevMonthDays = self.utils.getDaysinMonth((self.currentMonth - 1 + 12) % 12);
		self.selectedDateElem = undefined;
		self.todayDateElem = undefined;

		var daysInMonth = self.utils.getDaysinMonth(),
		    days = window.document.createDocumentFragment();

		var dayNumber = self.prevMonthDays + 1 - firstOfMonth,
		    dayIndex = 0;

		if (self.config.weekNumbers && self.weekNumbers.firstChild) self.weekNumbers.textContent = "";

		if (isRangeMode) {
			// const dateLimits = self.config.enable.length || self.config.disable.length || self.config.mixDate || self.config.maxDate;
			self.minRangeDate = new Date(self.currentYear, self.currentMonth - 1, dayNumber);
			self.maxRangeDate = new Date(self.currentYear, self.currentMonth + 1, (42 - firstOfMonth) % daysInMonth);
		}

		// prepend days from the ending of previous month
		for (; dayNumber <= self.prevMonthDays; dayNumber++, dayIndex++) {
			days.appendChild(createDay("prevMonthDay", new Date(self.currentYear, self.currentMonth - 1, dayNumber), dayNumber, dayIndex));
		}

		// Start at 1 since there is no 0th day
		for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
			days.appendChild(createDay("", new Date(self.currentYear, self.currentMonth, dayNumber), dayNumber, dayIndex));
		}

		// append days from the next month
		for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth; dayNum++, dayIndex++) {
			days.appendChild(createDay("nextMonthDay", new Date(self.currentYear, self.currentMonth + 1, dayNum % daysInMonth), dayNum, dayIndex));
		}

		if (isRangeMode && self.selectedDates.length === 1 && days.childNodes[0]) {
			self._hidePrevMonthArrow = self._hidePrevMonthArrow || self.minRangeDate > days.childNodes[0].dateObj;

			self._hideNextMonthArrow = self._hideNextMonthArrow || self.maxRangeDate < new Date(self.currentYear, self.currentMonth + 1, 1);
		} else updateNavigationCurrentMonth();

		var dayContainer = createElement("div", "dayContainer");
		dayContainer.appendChild(days);

		if (!self.config.animate || delta === undefined) clearNode(self.daysContainer);else {
			while (self.daysContainer.childNodes.length > 1) {
				self.daysContainer.removeChild(self.daysContainer.firstChild);
			}
		}

		if (delta >= 0) self.daysContainer.appendChild(dayContainer);else self.daysContainer.insertBefore(dayContainer, self.daysContainer.firstChild);

		self.days = self.daysContainer.firstChild;
		return self.daysContainer;
	}

	function clearNode(node) {
		while (node.firstChild) {
			node.removeChild(node.firstChild);
		}
	}

	function buildMonthNav() {
		var monthNavFragment = window.document.createDocumentFragment();
		self.monthNav = createElement("div", "flatpickr-month");

		self.prevMonthNav = createElement("span", "flatpickr-prev-month");
		self.prevMonthNav.innerHTML = self.config.prevArrow;

		self.currentMonthElement = createElement("span", "cur-month");
		self.currentMonthElement.title = self.l10n.scrollTitle;

		var yearInput = createNumberInput("cur-year");
		self.currentYearElement = yearInput.childNodes[0];
		self.currentYearElement.title = self.l10n.scrollTitle;

		if (self.config.minDate) self.currentYearElement.min = self.config.minDate.getFullYear();

		if (self.config.maxDate) {
			self.currentYearElement.max = self.config.maxDate.getFullYear();

			self.currentYearElement.disabled = self.config.minDate && self.config.minDate.getFullYear() === self.config.maxDate.getFullYear();
		}

		self.nextMonthNav = createElement("span", "flatpickr-next-month");
		self.nextMonthNav.innerHTML = self.config.nextArrow;

		self.navigationCurrentMonth = createElement("span", "flatpickr-current-month");
		self.navigationCurrentMonth.appendChild(self.currentMonthElement);
		self.navigationCurrentMonth.appendChild(yearInput);

		monthNavFragment.appendChild(self.prevMonthNav);
		monthNavFragment.appendChild(self.navigationCurrentMonth);
		monthNavFragment.appendChild(self.nextMonthNav);
		self.monthNav.appendChild(monthNavFragment);

		Object.defineProperty(self, "_hidePrevMonthArrow", {
			get: function get() {
				return this.__hidePrevMonthArrow;
			},
			set: function set(bool) {
				if (this.__hidePrevMonthArrow !== bool) self.prevMonthNav.style.display = bool ? "none" : "block";
				this.__hidePrevMonthArrow = bool;
			}
		});

		Object.defineProperty(self, "_hideNextMonthArrow", {
			get: function get() {
				return this.__hideNextMonthArrow;
			},
			set: function set(bool) {
				if (this.__hideNextMonthArrow !== bool) self.nextMonthNav.style.display = bool ? "none" : "block";
				this.__hideNextMonthArrow = bool;
			}
		});

		updateNavigationCurrentMonth();

		return self.monthNav;
	}

	function buildTime() {
		self.calendarContainer.classList.add("hasTime");
		if (self.config.noCalendar) self.calendarContainer.classList.add("noCalendar");
		self.timeContainer = createElement("div", "flatpickr-time");
		self.timeContainer.tabIndex = -1;
		var separator = createElement("span", "flatpickr-time-separator", ":");

		var hourInput = createNumberInput("flatpickr-hour");
		self.hourElement = hourInput.childNodes[0];

		var minuteInput = createNumberInput("flatpickr-minute");
		self.minuteElement = minuteInput.childNodes[0];

		self.hourElement.tabIndex = self.minuteElement.tabIndex = -1;

		self.hourElement.value = self.pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getHours() : self.config.defaultHour % (self.time_24hr ? 24 : 12));

		self.minuteElement.value = self.pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getMinutes() : self.config.defaultMinute);

		self.hourElement.step = self.config.hourIncrement;
		self.minuteElement.step = self.config.minuteIncrement;

		self.hourElement.min = self.config.time_24hr ? 0 : 1;
		self.hourElement.max = self.config.time_24hr ? 23 : 12;

		self.minuteElement.min = 0;
		self.minuteElement.max = 59;

		self.hourElement.title = self.minuteElement.title = self.l10n.scrollTitle;

		self.timeContainer.appendChild(hourInput);
		self.timeContainer.appendChild(separator);
		self.timeContainer.appendChild(minuteInput);

		if (self.config.time_24hr) self.timeContainer.classList.add("time24hr");

		if (self.config.enableSeconds) {
			self.timeContainer.classList.add("hasSeconds");

			var secondInput = createNumberInput("flatpickr-second");
			self.secondElement = secondInput.childNodes[0];

			self.secondElement.value = self.pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getSeconds() : self.config.defaultSeconds);

			self.secondElement.step = self.minuteElement.step;
			self.secondElement.min = self.minuteElement.min;
			self.secondElement.max = self.minuteElement.max;

			self.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
			self.timeContainer.appendChild(secondInput);
		}

		if (!self.config.time_24hr) {
			// add self.amPM if appropriate
			self.amPM = createElement("span", "flatpickr-am-pm", ["AM", "PM"][(self.latestSelectedDateObj ? self.hourElement.value : self.config.defaultHour) > 11 | 0]);
			self.amPM.title = self.l10n.toggleTitle;
			self.amPM.tabIndex = -1;
			self.timeContainer.appendChild(self.amPM);
		}

		return self.timeContainer;
	}

	function buildWeekdays() {
		if (!self.weekdayContainer) self.weekdayContainer = createElement("div", "flatpickr-weekdays");

		var firstDayOfWeek = self.l10n.firstDayOfWeek;
		var weekdays = self.l10n.weekdays.shorthand.slice();

		if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
			weekdays = [].concat(weekdays.splice(firstDayOfWeek, weekdays.length), weekdays.splice(0, firstDayOfWeek));
		}

		self.weekdayContainer.innerHTML = "\n\t\t<span class=flatpickr-weekday>\n\t\t\t" + weekdays.join("</span><span class=flatpickr-weekday>") + "\n\t\t</span>\n\t\t";

		return self.weekdayContainer;
	}

	/* istanbul ignore next */
	function buildWeeks() {
		self.calendarContainer.classList.add("hasWeeks");
		self.weekWrapper = createElement("div", "flatpickr-weekwrapper");
		self.weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self.l10n.weekAbbreviation));
		self.weekNumbers = createElement("div", "flatpickr-weeks");
		self.weekWrapper.appendChild(self.weekNumbers);

		return self.weekWrapper;
	}

	function changeMonth(value, is_offset, animate) {
		is_offset = is_offset === undefined || is_offset;
		var delta = is_offset ? value : value - self.currentMonth;
		var skipAnimations = !self.config.animate || animate === false;

		if (delta < 0 && self._hidePrevMonthArrow || delta > 0 && self._hideNextMonthArrow) return;

		self.currentMonth += delta;

		if (self.currentMonth < 0 || self.currentMonth > 11) {
			self.currentYear += self.currentMonth > 11 ? 1 : -1;
			self.currentMonth = (self.currentMonth + 12) % 12;

			triggerEvent("YearChange");
		}

		buildDays(!skipAnimations ? delta : undefined);

		if (skipAnimations) {
			triggerEvent("MonthChange");
			return updateNavigationCurrentMonth();
		}

		// remove possible remnants from clicking too fast
		var nav = self.navigationCurrentMonth;
		if (delta < 0) {
			while (nav.nextSibling && /curr/.test(nav.nextSibling.className)) {
				self.monthNav.removeChild(nav.nextSibling);
			}
		} else if (delta > 0) {
			while (nav.previousSibling && /curr/.test(nav.previousSibling.className)) {
				self.monthNav.removeChild(nav.previousSibling);
			}
		}

		self.oldCurMonth = self.navigationCurrentMonth;

		self.navigationCurrentMonth = self.monthNav.insertBefore(self.oldCurMonth.cloneNode(true), delta > 0 ? self.oldCurMonth.nextSibling : self.oldCurMonth);

		if (delta > 0) {
			self.daysContainer.firstChild.classList.add("slideLeft");
			self.daysContainer.lastChild.classList.add("slideLeftNew");

			self.oldCurMonth.classList.add("slideLeft");
			self.navigationCurrentMonth.classList.add("slideLeftNew");
		} else if (delta < 0) {
			self.daysContainer.firstChild.classList.add("slideRightNew");
			self.daysContainer.lastChild.classList.add("slideRight");

			self.oldCurMonth.classList.add("slideRight");
			self.navigationCurrentMonth.classList.add("slideRightNew");
		}

		self.currentMonthElement = self.navigationCurrentMonth.firstChild;
		self.currentYearElement = self.navigationCurrentMonth.lastChild.childNodes[0];

		updateNavigationCurrentMonth();
		self.oldCurMonth.firstChild.textContent = self.utils.monthToStr(self.currentMonth - delta);

		triggerEvent("MonthChange");

		if (document.activeElement && document.activeElement.$i) {
			var index = document.activeElement.$i;
			afterDayAnim(function () {
				focusOnDay(index, 0);
			});
		}
	}

	function clear(triggerChangeEvent) {
		self.input.value = "";

		if (self.altInput) self.altInput.value = "";

		if (self.mobileInput) self.mobileInput.value = "";

		self.selectedDates = [];
		self.latestSelectedDateObj = undefined;
		self.showTimeInput = false;

		self.redraw();

		if (triggerChangeEvent !== false)
			// triggerChangeEvent is true (default) or an Event
			triggerEvent("Change");
	}

	function close() {
		self.isOpen = false;

		if (!self.isMobile) {
			self.calendarContainer.classList.remove("open");
			self._input.classList.remove("active");
		}

		triggerEvent("Close");
	}

	function destroy() {
		if (self.config !== undefined) triggerEvent("Destroy");

		for (var i = self._handlers.length; i--;) {
			var h = self._handlers[i];
			h.element.removeEventListener(h.event, h.handler);
		}

		self._handlers = [];

		if (self.mobileInput) {
			if (self.mobileInput.parentNode) self.mobileInput.parentNode.removeChild(self.mobileInput);
			self.mobileInput = null;
		} else if (self.calendarContainer && self.calendarContainer.parentNode) self.calendarContainer.parentNode.removeChild(self.calendarContainer);

		if (self.altInput) {
			self.input.type = "text";
			if (self.altInput.parentNode) self.altInput.parentNode.removeChild(self.altInput);
			delete self.altInput;
		}

		if (self.input) {
			self.input.type = self.input._type;
			self.input.classList.remove("flatpickr-input");
			self.input.removeAttribute("readonly");
			self.input.value = "";
		}

		["_showTimeInput", "latestSelectedDateObj", "_hideNextMonthArrow", "_hidePrevMonthArrow", "__hideNextMonthArrow", "__hidePrevMonthArrow", "isMobile", "isOpen", "selectedDateElem", "minDateHasTime", "maxDateHasTime", "days", "daysContainer", "_input", "_positionElement", "innerContainer", "rContainer", "monthNav", "todayDateElem", "calendarContainer", "weekdayContainer", "prevMonthNav", "nextMonthNav", "currentMonthElement", "currentYearElement", "navigationCurrentMonth", "selectedDateElem", "config"].forEach(function (k) {
			try {
				delete self[k];
			} catch (e) {}
		});
	}

	function isCalendarElem(elem) {
		if (self.config.appendTo && self.config.appendTo.contains(elem)) return true;

		return self.calendarContainer.contains(elem);
	}

	function documentClick(e) {
		if (self.isOpen && !self.config.inline) {
			var isCalendarElement = isCalendarElem(e.target);
			var isInput = e.target === self.input || e.target === self.altInput || self.element.contains(e.target) ||
			// web components
			e.path && e.path.indexOf && (~e.path.indexOf(self.input) || ~e.path.indexOf(self.altInput));

			var lostFocus = e.type === "blur" ? isInput && e.relatedTarget && !isCalendarElem(e.relatedTarget) : !isInput && !isCalendarElement;

			if (lostFocus && self.config.ignoredFocusElements.indexOf(e.target) === -1) {
				self.close();

				if (self.config.mode === "range" && self.selectedDates.length === 1) {
					self.clear(false);
					self.redraw();
				}
			}
		}
	}

	function changeYear(newYear) {
		if (!newYear || self.currentYearElement.min && newYear < self.currentYearElement.min || self.currentYearElement.max && newYear > self.currentYearElement.max) return;

		var newYearNum = parseInt(newYear, 10),
		    isNewYear = self.currentYear !== newYearNum;

		self.currentYear = newYearNum || self.currentYear;

		if (self.config.maxDate && self.currentYear === self.config.maxDate.getFullYear()) {
			self.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth);
		} else if (self.config.minDate && self.currentYear === self.config.minDate.getFullYear()) {
			self.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth);
		}

		if (isNewYear) {
			self.redraw();
			triggerEvent("YearChange");
		}
	}

	function isEnabled(date, timeless) {
		if (self.config.minDate && compareDates(date, self.config.minDate, timeless !== undefined ? timeless : !self.minDateHasTime) < 0 || self.config.maxDate && compareDates(date, self.config.maxDate, timeless !== undefined ? timeless : !self.maxDateHasTime) > 0) return false;

		if (!self.config.enable.length && !self.config.disable.length) return true;

		var dateToCheck = self.parseDate(date, null, true); // timeless

		var bool = self.config.enable.length > 0,
		    array = bool ? self.config.enable : self.config.disable;

		for (var i = 0, d; i < array.length; i++) {
			d = array[i];

			if (d instanceof Function && d(dateToCheck)) // disabled by function
				return bool;else if (d instanceof Date && d.getTime() === dateToCheck.getTime())
				// disabled by date
				return bool;else if (typeof d === "string" && self.parseDate(d, null, true).getTime() === dateToCheck.getTime())
				// disabled by date string
				return bool;else if ( // disabled by range
			(typeof d === "undefined" ? "undefined" : _typeof(d)) === "object" && d.from && d.to && dateToCheck >= d.from && dateToCheck <= d.to) return bool;
		}

		return !bool;
	}

	function onKeyDown(e) {
		var isInput = e.target === self._input;
		var calendarElem = isCalendarElem(e.target);
		var allowInput = self.config.allowInput;
		var allowKeydown = self.isOpen && (!allowInput || !isInput);
		var allowInlineKeydown = self.config.inline && isInput && !allowInput;

		if (e.key === "Enter" && allowInput && isInput) {
			self.setDate(self._input.value, true, e.target === self.altInput ? self.config.altFormat : self.config.dateFormat);
			return e.target.blur();
		} else if (calendarElem || allowKeydown || allowInlineKeydown) {
			var isTimeObj = self.timeContainer && self.timeContainer.contains(e.target);
			switch (e.key) {
				case "Enter":
					if (isTimeObj) updateValue();else selectDate(e);

					break;

				case "Escape":
					// escape
					e.preventDefault();
					self.close();
					break;

				case "Backspace":
				case "Delete":
					if (!self.config.allowInput) self.clear();
					break;

				case "ArrowLeft":
				case "ArrowRight":
					if (!isTimeObj) {
						e.preventDefault();

						if (self.daysContainer) {
							var _delta = e.key === "ArrowRight" ? 1 : -1;

							if (!e.ctrlKey) focusOnDay(e.target.$i, _delta);else changeMonth(_delta, true);
						} else if (self.config.enableTime && !isTimeObj) self.hourElement.focus();
					}

					break;

				case "ArrowUp":
				case "ArrowDown":
					e.preventDefault();
					var delta = e.key === "ArrowDown" ? 1 : -1;

					if (self.daysContainer) {
						if (e.ctrlKey) {
							changeYear(self.currentYear - delta);
							focusOnDay(e.target.$i, 0);
						} else if (!isTimeObj) focusOnDay(e.target.$i, delta * 7);
					} else if (self.config.enableTime) {
						if (!isTimeObj) self.hourElement.focus();
						updateTime(e);
						self.debouncedChange();
					}

					break;

				case "Tab":
					if (e.target === self.hourElement) {
						e.preventDefault();
						self.minuteElement.select();
					} else if (e.target === self.minuteElement && (self.secondElement || self.amPM)) {
						e.preventDefault();
						(self.secondElement || self.amPM).focus();
					} else if (e.target === self.secondElement) {
						e.preventDefault();
						self.amPM.focus();
					}

					break;

				case "a":
					if (e.target === self.amPM) {
						self.amPM.textContent = "AM";
						setHoursFromInputs();
						updateValue();
					}
					break;

				case "p":
					if (e.target === self.amPM) {
						self.amPM.textContent = "PM";
						setHoursFromInputs();
						updateValue();
					}
					break;

				default:
					break;

			}

			triggerEvent("KeyDown", e);
		}
	}

	function onMouseOver(elem) {
		if (self.selectedDates.length !== 1 || !elem.classList.contains("flatpickr-day")) return;

		var hoverDate = elem.dateObj,
		    initialDate = self.parseDate(self.selectedDates[0], null, true),
		    rangeStartDate = Math.min(hoverDate.getTime(), self.selectedDates[0].getTime()),
		    rangeEndDate = Math.max(hoverDate.getTime(), self.selectedDates[0].getTime()),
		    containsDisabled = false;

		for (var t = rangeStartDate; t < rangeEndDate; t += self.utils.duration.DAY) {
			if (!isEnabled(new Date(t))) {
				containsDisabled = true;
				break;
			}
		}

		var _loop = function _loop(timestamp, i) {
			var outOfRange = timestamp < self.minRangeDate.getTime() || timestamp > self.maxRangeDate.getTime(),
			    dayElem = self.days.childNodes[i];

			if (outOfRange) {
				self.days.childNodes[i].classList.add("notAllowed");
				["inRange", "startRange", "endRange"].forEach(function (c) {
					dayElem.classList.remove(c);
				});
				return "continue";
			} else if (containsDisabled && !outOfRange) return "continue";

			["startRange", "inRange", "endRange", "notAllowed"].forEach(function (c) {
				dayElem.classList.remove(c);
			});

			var minRangeDate = Math.max(self.minRangeDate.getTime(), rangeStartDate),
			    maxRangeDate = Math.min(self.maxRangeDate.getTime(), rangeEndDate);

			elem.classList.add(hoverDate < self.selectedDates[0] ? "startRange" : "endRange");

			if (initialDate < hoverDate && timestamp === initialDate.getTime()) dayElem.classList.add("startRange");else if (initialDate > hoverDate && timestamp === initialDate.getTime()) dayElem.classList.add("endRange");

			if (timestamp >= minRangeDate && timestamp <= maxRangeDate) dayElem.classList.add("inRange");
		};

		for (var timestamp = self.days.childNodes[0].dateObj.getTime(), i = 0; i < 42; i++, timestamp += self.utils.duration.DAY) {
			var _ret = _loop(timestamp, i);

			if (_ret === "continue") continue;
		}
	}

	function onResize() {
		if (self.isOpen && !self.config.static && !self.config.inline) positionCalendar();
	}

	function open(e, positionElement) {
		if (self.isMobile) {
			if (e) {
				e.preventDefault();
				e.target.blur();
			}

			setTimeout(function () {
				self.mobileInput.click();
			}, 0);

			triggerEvent("Open");
			return;
		}

		if (self.isOpen || self._input.disabled || self.config.inline) return;

		self.isOpen = true;
		self.calendarContainer.classList.add("open");
		positionCalendar(positionElement);
		self._input.classList.add("active");

		triggerEvent("Open");
	}

	function minMaxDateSetter(type) {
		return function (date) {
			var dateObj = self.config["_" + type + "Date"] = self.parseDate(date);

			var inverseDateObj = self.config["_" + (type === "min" ? "max" : "min") + "Date"];
			var isValidDate = date && dateObj instanceof Date;

			if (isValidDate) {
				self[type + "DateHasTime"] = dateObj.getHours() || dateObj.getMinutes() || dateObj.getSeconds();
			}

			if (self.selectedDates) {
				self.selectedDates = self.selectedDates.filter(function (d) {
					return isEnabled(d);
				});
				if (!self.selectedDates.length && type === "min") setHoursFromDate(dateObj);
				updateValue();
			}

			if (self.daysContainer) {
				redraw();

				if (isValidDate) self.currentYearElement[type] = dateObj.getFullYear();else self.currentYearElement.removeAttribute(type);

				self.currentYearElement.disabled = inverseDateObj && dateObj && inverseDateObj.getFullYear() === dateObj.getFullYear();
			}
		};
	}

	function parseConfig() {
		var boolOpts = ["wrap", "weekNumbers", "allowInput", "clickOpens", "time_24hr", "enableTime", "noCalendar", "altInput", "shorthandCurrentMonth", "inline", "static", "enableSeconds", "disableMobile"];

		var hooks = ["onChange", "onClose", "onDayCreate", "onDestroy", "onKeyDown", "onMonthChange", "onOpen", "onParseConfig", "onReady", "onValueUpdate", "onYearChange"];

		self.config = Object.create(flatpickr.defaultConfig);

		var userConfig = _extends({}, self.instanceConfig, JSON.parse(JSON.stringify(self.element.dataset || {})));

		self.config.parseDate = userConfig.parseDate;
		self.config.formatDate = userConfig.formatDate;

		Object.defineProperty(self.config, "enable", {
			get: function get() {
				return self.config._enable || [];
			},
			set: function set(dates) {
				return self.config._enable = parseDateRules(dates);
			}
		});

		Object.defineProperty(self.config, "disable", {
			get: function get() {
				return self.config._disable || [];
			},
			set: function set(dates) {
				return self.config._disable = parseDateRules(dates);
			}
		});

		_extends(self.config, userConfig);

		if (!userConfig.dateFormat && userConfig.enableTime) {
			self.config.dateFormat = self.config.noCalendar ? "H:i" + (self.config.enableSeconds ? ":S" : "") : flatpickr.defaultConfig.dateFormat + " H:i" + (self.config.enableSeconds ? ":S" : "");
		}

		if (userConfig.altInput && userConfig.enableTime && !userConfig.altFormat) {
			self.config.altFormat = self.config.noCalendar ? "h:i" + (self.config.enableSeconds ? ":S K" : " K") : flatpickr.defaultConfig.altFormat + (" h:i" + (self.config.enableSeconds ? ":S" : "") + " K");
		}

		Object.defineProperty(self.config, "minDate", {
			get: function get() {
				return this._minDate;
			},
			set: minMaxDateSetter("min")
		});

		Object.defineProperty(self.config, "maxDate", {
			get: function get() {
				return this._maxDate;
			},
			set: minMaxDateSetter("max")
		});

		self.config.minDate = userConfig.minDate;
		self.config.maxDate = userConfig.maxDate;

		for (var i = 0; i < boolOpts.length; i++) {
			self.config[boolOpts[i]] = self.config[boolOpts[i]] === true || self.config[boolOpts[i]] === "true";
		}for (var _i = hooks.length; _i--;) {
			if (self.config[hooks[_i]] !== undefined) {
				self.config[hooks[_i]] = arrayify(self.config[hooks[_i]] || []).map(bindToInstance);
			}
		}

		for (var _i2 = 0; _i2 < self.config.plugins.length; _i2++) {
			var pluginConf = self.config.plugins[_i2](self) || {};
			for (var key in pluginConf) {

				if (self.config[key] instanceof Array || ~hooks.indexOf(key)) {
					self.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self.config[key]);
				} else if (typeof userConfig[key] === "undefined") self.config[key] = pluginConf[key];
			}
		}

		triggerEvent("ParseConfig");
	}

	function setupLocale() {
		if (_typeof(self.config.locale) !== "object" && typeof flatpickr.l10ns[self.config.locale] === "undefined") console.warn("flatpickr: invalid locale " + self.config.locale);

		self.l10n = _extends(Object.create(flatpickr.l10ns.default), _typeof(self.config.locale) === "object" ? self.config.locale : self.config.locale !== "default" ? flatpickr.l10ns[self.config.locale] || {} : {});
	}

	function positionCalendar() {
		var positionElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : self._positionElement;

		if (self.calendarContainer === undefined) return;

		var calendarHeight = self.calendarContainer.offsetHeight,
		    calendarWidth = self.calendarContainer.offsetWidth,
		    configPos = self.config.position,
		    inputBounds = positionElement.getBoundingClientRect(),
		    distanceFromBottom = window.innerHeight - inputBounds.bottom,
		    showOnTop = configPos === "above" || configPos !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;

		var top = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);

		toggleClass(self.calendarContainer, "arrowTop", !showOnTop);
		toggleClass(self.calendarContainer, "arrowBottom", showOnTop);

		if (self.config.inline) return;

		var left = window.pageXOffset + inputBounds.left;
		var right = window.document.body.offsetWidth - inputBounds.right;
		var rightMost = left + calendarWidth > window.document.body.offsetWidth;

		toggleClass(self.calendarContainer, "rightMost", rightMost);

		if (self.config.static) return;

		self.calendarContainer.style.top = top + "px";

		if (!rightMost) {
			self.calendarContainer.style.left = left + "px";
			self.calendarContainer.style.right = "auto";
		} else {
			self.calendarContainer.style.left = "auto";
			self.calendarContainer.style.right = right + "px";
		}
	}

	function redraw() {
		if (self.config.noCalendar || self.isMobile) return;

		buildWeekdays();
		updateNavigationCurrentMonth();
		buildDays();
	}

	function selectDate(e) {
		e.preventDefault();
		e.stopPropagation();

		if (!e.target.classList.contains("flatpickr-day") || e.target.classList.contains("disabled") || e.target.classList.contains("notAllowed")) return;

		var selectedDate = self.latestSelectedDateObj = new Date(e.target.dateObj.getTime());

		var shouldChangeMonth = selectedDate.getMonth() !== self.currentMonth && self.config.mode !== "range";

		self.selectedDateElem = e.target;

		if (self.config.mode === "single") self.selectedDates = [selectedDate];else if (self.config.mode === "multiple") {
			var selectedIndex = isDateSelected(selectedDate);
			if (selectedIndex) self.selectedDates.splice(selectedIndex, 1);else self.selectedDates.push(selectedDate);
		} else if (self.config.mode === "range") {
			if (self.selectedDates.length === 2) self.clear();

			self.selectedDates.push(selectedDate);

			// unless selecting same date twice, sort ascendingly
			if (compareDates(selectedDate, self.selectedDates[0], true) !== 0) self.selectedDates.sort(function (a, b) {
				return a.getTime() - b.getTime();
			});
		}

		setHoursFromInputs();

		if (shouldChangeMonth) {
			var isNewYear = self.currentYear !== selectedDate.getFullYear();
			self.currentYear = selectedDate.getFullYear();
			self.currentMonth = selectedDate.getMonth();

			if (isNewYear) triggerEvent("YearChange");

			triggerEvent("MonthChange");
		}

		buildDays();

		if (self.minDateHasTime && self.config.enableTime && compareDates(selectedDate, self.config.minDate) === 0) setHoursFromDate(self.config.minDate);

		updateValue();

		if (self.config.enableTime) setTimeout(function () {
			return self.showTimeInput = true;
		}, 50);

		if (self.config.mode === "range") {
			if (self.selectedDates.length === 1) {
				onMouseOver(e.target);

				self._hidePrevMonthArrow = self._hidePrevMonthArrow || self.minRangeDate > self.days.childNodes[0].dateObj;

				self._hideNextMonthArrow = self._hideNextMonthArrow || self.maxRangeDate < new Date(self.currentYear, self.currentMonth + 1, 1);
			} else updateNavigationCurrentMonth();
		}

		triggerEvent("Change");

		// maintain focus
		if (!shouldChangeMonth) focusOnDay(e.target.$i, 0);else afterDayAnim(function () {
			return self.selectedDateElem && self.selectedDateElem.focus();
		});

		if (self.config.enableTime) setTimeout(function () {
			return self.hourElement.select();
		}, 451);

		if (self.config.closeOnSelect) {
			var single = self.config.mode === "single" && !self.config.enableTime;
			var range = self.config.mode === "range" && self.selectedDates.length === 2 && !self.config.enableTime;

			if (single || range) self.close();
		}
	}

	function set(option, value) {
		if (option !== null && (typeof option === "undefined" ? "undefined" : _typeof(option)) === "object") _extends(self.config, option);else self.config[option] = value;

		self.redraw();
		jumpToDate();
	}

	function setSelectedDate(inputDate, format) {
		if (inputDate instanceof Array) self.selectedDates = inputDate.map(function (d) {
			return self.parseDate(d, format);
		});else if (inputDate instanceof Date || !isNaN(inputDate)) self.selectedDates = [self.parseDate(inputDate, format)];else if (inputDate && inputDate.substring) {
			switch (self.config.mode) {
				case "single":
					self.selectedDates = [self.parseDate(inputDate, format)];
					break;

				case "multiple":
					self.selectedDates = inputDate.split("; ").map(function (date) {
						return self.parseDate(date, format);
					});
					break;

				case "range":
					self.selectedDates = inputDate.split(self.l10n.rangeSeparator).map(function (date) {
						return self.parseDate(date, format);
					});

					break;

				default:
					break;
			}
		}

		self.selectedDates = self.selectedDates.filter(function (d) {
			return d instanceof Date && isEnabled(d, false);
		});

		self.selectedDates.sort(function (a, b) {
			return a.getTime() - b.getTime();
		});
	}

	function setDate(date, triggerChange, format) {
		if (date !== 0 && !date) return self.clear(triggerChange);

		setSelectedDate(date, format);

		self.showTimeInput = self.selectedDates.length > 0;
		self.latestSelectedDateObj = self.selectedDates[0];

		self.redraw();
		jumpToDate();

		setHoursFromDate();
		updateValue(triggerChange);

		if (triggerChange) triggerEvent("Change");
	}

	function parseDateRules(arr) {
		for (var i = arr.length; i--;) {
			if (typeof arr[i] === "string" || +arr[i]) arr[i] = self.parseDate(arr[i], null, true);else if (arr[i] && arr[i].from && arr[i].to) {
				arr[i].from = self.parseDate(arr[i].from);
				arr[i].to = self.parseDate(arr[i].to);
			}
		}

		return arr.filter(function (x) {
			return x;
		}); // remove falsy values
	}

	function setupDates() {
		self.selectedDates = [];
		self.now = new Date();

		var preloadedDate = self.config.defaultDate || self.input.value;
		if (preloadedDate) setSelectedDate(preloadedDate, self.config.dateFormat);

		var initialDate = self.selectedDates.length ? self.selectedDates[0] : self.config.minDate && self.config.minDate.getTime() > self.now ? self.config.minDate : self.config.maxDate && self.config.maxDate.getTime() < self.now ? self.config.maxDate : self.now;

		self.currentYear = initialDate.getFullYear();
		self.currentMonth = initialDate.getMonth();

		if (self.selectedDates.length) self.latestSelectedDateObj = self.selectedDates[0];

		self.minDateHasTime = self.config.minDate && (self.config.minDate.getHours() || self.config.minDate.getMinutes() || self.config.minDate.getSeconds());

		self.maxDateHasTime = self.config.maxDate && (self.config.maxDate.getHours() || self.config.maxDate.getMinutes() || self.config.maxDate.getSeconds());

		Object.defineProperty(self, "latestSelectedDateObj", {
			get: function get() {
				return self._selectedDateObj || self.selectedDates[self.selectedDates.length - 1];
			},
			set: function set(date) {
				self._selectedDateObj = date;
			}
		});

		if (!self.isMobile) {
			Object.defineProperty(self, "showTimeInput", {
				get: function get() {
					return self._showTimeInput;
				},
				set: function set(bool) {
					self._showTimeInput = bool;
					if (self.calendarContainer) toggleClass(self.calendarContainer, "showTimeInput", bool);
					positionCalendar();
				}
			});
		}
	}

	function setupHelperFunctions() {
		self.utils = {
			duration: {
				DAY: 86400000
			},
			getDaysinMonth: function getDaysinMonth(month, yr) {
				month = typeof month === "undefined" ? self.currentMonth : month;

				yr = typeof yr === "undefined" ? self.currentYear : yr;

				if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0)) return 29;

				return self.l10n.daysInMonth[month];
			},
			monthToStr: function monthToStr(monthNumber, shorthand) {
				shorthand = typeof shorthand === "undefined" ? self.config.shorthandCurrentMonth : shorthand;

				return self.l10n.months[(shorthand ? "short" : "long") + "hand"][monthNumber];
			}
		};
	}

	/* istanbul ignore next */
	function setupFormats() {
		self.formats = Object.create(FlatpickrInstance.prototype.formats);
		["D", "F", "J", "M", "W", "l"].forEach(function (f) {
			self.formats[f] = FlatpickrInstance.prototype.formats[f].bind(self);
		});

		self.revFormat.F = FlatpickrInstance.prototype.revFormat.F.bind(self);
		self.revFormat.M = FlatpickrInstance.prototype.revFormat.M.bind(self);
	}

	function setupInputs() {
		self.input = self.config.wrap ? self.element.querySelector("[data-input]") : self.element;

		/* istanbul ignore next */
		if (!self.input) return console.warn("Error: invalid input element specified", self.input);

		self.input._type = self.input.type;
		self.input.type = "text";

		self.input.classList.add("flatpickr-input");
		self._input = self.input;

		if (self.config.altInput) {
			// replicate self.element
			self.altInput = createElement(self.input.nodeName, self.input.className + " " + self.config.altInputClass);
			self._input = self.altInput;
			self.altInput.placeholder = self.input.placeholder;
			self.altInput.disabled = self.input.disabled;
			self.altInput.required = self.input.required;
			self.altInput.type = "text";
			self.input.type = "hidden";

			if (!self.config.static && self.input.parentNode) self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);
		}

		if (!self.config.allowInput) self._input.setAttribute("readonly", "readonly");

		self._positionElement = self.config.positionElement || self._input;
	}

	function setupMobile() {
		var inputType = self.config.enableTime ? self.config.noCalendar ? "time" : "datetime-local" : "date";

		self.mobileInput = createElement("input", self.input.className + " flatpickr-mobile");
		self.mobileInput.step = self.input.getAttribute("step") || "any";
		self.mobileInput.tabIndex = 1;
		self.mobileInput.type = inputType;
		self.mobileInput.disabled = self.input.disabled;
		self.mobileInput.placeholder = self.input.placeholder;

		self.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";

		if (self.selectedDates.length) {
			self.mobileInput.defaultValue = self.mobileInput.value = self.formatDate(self.selectedDates[0], self.mobileFormatStr);
		}

		if (self.config.minDate) self.mobileInput.min = self.formatDate(self.config.minDate, "Y-m-d");

		if (self.config.maxDate) self.mobileInput.max = self.formatDate(self.config.maxDate, "Y-m-d");

		self.input.type = "hidden";
		if (self.config.altInput) self.altInput.type = "hidden";

		try {
			self.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);
		} catch (e) {
			//
		}

		self.mobileInput.addEventListener("change", function (e) {
			self.setDate(e.target.value, false, self.mobileFormatStr);
			triggerEvent("Change");
			triggerEvent("Close");
		});
	}

	function toggle() {
		if (self.isOpen) return self.close();
		self.open();
	}

	function triggerEvent(event, data) {
		var hooks = self.config["on" + event];

		if (hooks !== undefined && hooks.length > 0) {
			for (var i = 0; hooks[i] && i < hooks.length; i++) {
				hooks[i](self.selectedDates, self.input.value, self, data);
			}
		}

		if (event === "Change") {
			self.input.dispatchEvent(createEvent("change"));

			// many front-end frameworks bind to the input event
			self.input.dispatchEvent(createEvent("input"));
		}
	}

	/**
  * Creates an Event, normalized across browsers
  * @param {String} name the event name, e.g. "click"
  * @return {Event} the created event
  */
	function createEvent(name) {
		if (self._supportsEvents) return new Event(name, { bubbles: true });

		self._[name + "Event"] = document.createEvent("Event");
		self._[name + "Event"].initEvent(name, true, true);
		return self._[name + "Event"];
	}

	function isDateSelected(date) {
		for (var i = 0; i < self.selectedDates.length; i++) {
			if (compareDates(self.selectedDates[i], date) === 0) return "" + i;
		}

		return false;
	}

	function isDateInRange(date) {
		if (self.config.mode !== "range" || self.selectedDates.length < 2) return false;
		return compareDates(date, self.selectedDates[0]) >= 0 && compareDates(date, self.selectedDates[1]) <= 0;
	}

	function updateNavigationCurrentMonth() {
		if (self.config.noCalendar || self.isMobile || !self.monthNav) return;

		self.currentMonthElement.textContent = self.utils.monthToStr(self.currentMonth) + " ";
		self.currentYearElement.value = self.currentYear;

		self._hidePrevMonthArrow = self.config.minDate && (self.currentYear === self.config.minDate.getFullYear() ? self.currentMonth <= self.config.minDate.getMonth() : self.currentYear < self.config.minDate.getFullYear());

		self._hideNextMonthArrow = self.config.maxDate && (self.currentYear === self.config.maxDate.getFullYear() ? self.currentMonth + 1 > self.config.maxDate.getMonth() : self.currentYear > self.config.maxDate.getFullYear());
	}

	/**
  * Updates the values of inputs associated with the calendar
  * @return {void}
  */
	function updateValue(triggerChange) {
		if (!self.selectedDates.length) return self.clear(triggerChange);

		if (self.isMobile) {
			self.mobileInput.value = self.selectedDates.length ? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr) : "";
		}

		var joinChar = self.config.mode !== "range" ? "; " : self.l10n.rangeSeparator;

		self.input.value = self.selectedDates.map(function (dObj) {
			return self.formatDate(dObj, self.config.dateFormat);
		}).join(joinChar);

		if (self.config.altInput) {
			self.altInput.value = self.selectedDates.map(function (dObj) {
				return self.formatDate(dObj, self.config.altFormat);
			}).join(joinChar);
		}

		if (triggerChange !== false) triggerEvent("ValueUpdate");
	}

	function mouseDelta(e) {
		return Math.max(-1, Math.min(1, e.wheelDelta || -e.deltaY));
	}

	function onMonthNavScroll(e) {
		e.preventDefault();
		var isYear = self.currentYearElement.parentNode.contains(e.target);

		if (e.target === self.currentMonthElement || isYear) {

			var delta = mouseDelta(e);

			if (isYear) {
				changeYear(self.currentYear + delta);
				e.target.value = self.currentYear;
			} else self.changeMonth(delta, true, false);
		}
	}

	function onMonthNavClick(e) {
		var isPrevMonth = self.prevMonthNav.contains(e.target);
		var isNextMonth = self.nextMonthNav.contains(e.target);

		if (isPrevMonth || isNextMonth) changeMonth(isPrevMonth ? -1 : 1);else if (e.target === self.currentYearElement) {
			e.preventDefault();
			self.currentYearElement.select();
		} else if (e.target.className === "arrowUp") self.changeYear(self.currentYear + 1);else if (e.target.className === "arrowDown") self.changeYear(self.currentYear - 1);
	}

	/**
  * Creates an HTMLElement with given tag, class, and textual content
  * @param {String} tag the HTML tag
  * @param {String} className the new element's class name
  * @param {String} content The new element's text content
  * @return {HTMLElement} the created HTML element
  */
	function createElement(tag, className, content) {
		var e = window.document.createElement(tag);
		className = className || "";
		content = content || "";

		e.className = className;

		if (content !== undefined) e.textContent = content;

		return e;
	}

	function arrayify(obj) {
		if (obj instanceof Array) return obj;
		return [obj];
	}

	function toggleClass(elem, className, bool) {
		if (bool) return elem.classList.add(className);
		elem.classList.remove(className);
	}

	/* istanbul ignore next */
	function debounce(func, wait, immediate) {
		var timeout = void 0;
		return function () {
			var context = this,
			    args = arguments;
			clearTimeout(timeout);
			timeout = setTimeout(function () {
				timeout = null;
				if (!immediate) func.apply(context, args);
			}, wait);
			if (immediate && !timeout) func.apply(context, args);
		};
	}

	/**
  * Compute the difference in dates, measured in ms
  * @param {Date} date1
  * @param {Date} date2
  * @param {Boolean} timeless whether to reset times of both dates to 00:00
  * @return {Number} the difference in ms
  */
	function compareDates(date1, date2, timeless) {
		if (!(date1 instanceof Date) || !(date2 instanceof Date)) return false;

		if (timeless !== false) {
			return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
		}

		return date1.getTime() - date2.getTime();
	}

	function timeWrapper(e) {
		e.preventDefault();

		var isKeyDown = e.type === "keydown",
		    isWheel = e.type === "wheel",
		    isIncrement = e.type === "increment",
		    input = e.target;

		if (self.amPM && e.target === self.amPM) return e.target.textContent = ["AM", "PM"][e.target.textContent === "AM" | 0];

		var min = Number(input.min),
		    max = Number(input.max),
		    step = Number(input.step),
		    curValue = parseInt(input.value, 10),
		    delta = e.delta || (!isKeyDown ? Math.max(-1, Math.min(1, e.wheelDelta || -e.deltaY)) || 0 : e.which === 38 ? 1 : -1);

		var newValue = curValue + step * delta;

		if (typeof input.value !== "undefined" && input.value.length === 2) {
			var isHourElem = input === self.hourElement,
			    isMinuteElem = input === self.minuteElement;

			if (newValue < min) {
				newValue = max + newValue + !isHourElem + (isHourElem && !self.amPM);

				if (isMinuteElem) incrementNumInput(null, -1, self.hourElement);
			} else if (newValue > max) {
				newValue = input === self.hourElement ? newValue - max - !self.amPM : min;

				if (isMinuteElem) incrementNumInput(null, 1, self.hourElement);
			}

			if (self.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) self.amPM.textContent = self.amPM.textContent === "PM" ? "AM" : "PM";

			input.value = self.pad(newValue);
		}
	}

	init();
	return self;
}

FlatpickrInstance.prototype = {
	formats: {
		// get the date in UTC
		Z: function Z(date) {
			return date.toISOString();
		},

		// weekday name, short, e.g. Thu
		D: function D(date) {
			return this.l10n.weekdays.shorthand[this.formats.w(date)];
		},

		// full month name e.g. January
		F: function F(date) {
			return this.utils.monthToStr(this.formats.n(date) - 1, false);
		},

		// padded hour 1-12
		G: function G(date) {
			return FlatpickrInstance.prototype.pad(FlatpickrInstance.prototype.formats.h(date));
		},

		// hours with leading zero e.g. 03
		H: function H(date) {
			return FlatpickrInstance.prototype.pad(date.getHours());
		},

		// day (1-30) with ordinal suffix e.g. 1st, 2nd
		J: function J(date) {
			return date.getDate() + this.l10n.ordinal(date.getDate());
		},

		// AM/PM
		K: function K(date) {
			return date.getHours() > 11 ? "PM" : "AM";
		},

		// shorthand month e.g. Jan, Sep, Oct, etc
		M: function M(date) {
			return this.utils.monthToStr(date.getMonth(), true);
		},

		// seconds 00-59
		S: function S(date) {
			return FlatpickrInstance.prototype.pad(date.getSeconds());
		},

		// unix timestamp
		U: function U(date) {
			return date.getTime() / 1000;
		},

		W: function W(date) {
			return this.config.getWeek(date);
		},

		// full year e.g. 2016
		Y: function Y(date) {
			return date.getFullYear();
		},

		// day in month, padded (01-30)
		d: function d(date) {
			return FlatpickrInstance.prototype.pad(date.getDate());
		},

		// hour from 1-12 (am/pm)
		h: function h(date) {
			return date.getHours() % 12 ? date.getHours() % 12 : 12;
		},

		// minutes, padded with leading zero e.g. 09
		i: function i(date) {
			return FlatpickrInstance.prototype.pad(date.getMinutes());
		},

		// day in month (1-30)
		j: function j(date) {
			return date.getDate();
		},

		// weekday name, full, e.g. Thursday
		l: function l(date) {
			return this.l10n.weekdays.longhand[date.getDay()];
		},

		// padded month number (01-12)
		m: function m(date) {
			return FlatpickrInstance.prototype.pad(date.getMonth() + 1);
		},

		// the month number (1-12)
		n: function n(date) {
			return date.getMonth() + 1;
		},

		// seconds 0-59
		s: function s(date) {
			return date.getSeconds();
		},

		// number of the day of the week
		w: function w(date) {
			return date.getDay();
		},

		// last two digits of year e.g. 16 for 2016
		y: function y(date) {
			return String(date.getFullYear()).substring(2);
		}
	},

	/**
  * Formats a given Date object into a string based on supplied format
  * @param {Date} dateObj the date object
  * @param {String} frmt a string composed of formatting tokens e.g. "Y-m-d"
  * @return {String} The textual representation of the date e.g. 2017-02-03
  */
	formatDate: function formatDate(dateObj, frmt) {
		var _this = this;

		if (this.config !== undefined && this.config.formatDate !== undefined) return this.config.formatDate(dateObj, frmt);

		return frmt.split("").map(function (c, i, arr) {
			return _this.formats[c] && arr[i - 1] !== "\\" ? _this.formats[c](dateObj) : c !== "\\" ? c : "";
		}).join("");
	},


	revFormat: {
		D: function D() {},
		F: function F(dateObj, monthName) {
			dateObj.setMonth(this.l10n.months.longhand.indexOf(monthName));
		},
		G: function G(dateObj, hour) {
			dateObj.setHours(parseFloat(hour));
		},
		H: function H(dateObj, hour) {
			dateObj.setHours(parseFloat(hour));
		},
		J: function J(dateObj, day) {
			dateObj.setDate(parseFloat(day));
		},
		K: function K(dateObj, amPM) {
			var hours = dateObj.getHours();

			if (hours !== 12) dateObj.setHours(hours % 12 + 12 * /pm/i.test(amPM));
		},
		M: function M(dateObj, shortMonth) {
			dateObj.setMonth(this.l10n.months.shorthand.indexOf(shortMonth));
		},
		S: function S(dateObj, seconds) {
			dateObj.setSeconds(seconds);
		},
		U: function U(dateObj, unixSeconds) {
			return new Date(parseFloat(unixSeconds) * 1000);
		},

		W: function W(dateObj, weekNumber) {
			weekNumber = parseInt(weekNumber);
			return new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0, 0);
		},
		Y: function Y(dateObj, year) {
			dateObj.setFullYear(year);
		},
		Z: function Z(dateObj, ISODate) {
			return new Date(ISODate);
		},

		d: function d(dateObj, day) {
			dateObj.setDate(parseFloat(day));
		},
		h: function h(dateObj, hour) {
			dateObj.setHours(parseFloat(hour));
		},
		i: function i(dateObj, minutes) {
			dateObj.setMinutes(parseFloat(minutes));
		},
		j: function j(dateObj, day) {
			dateObj.setDate(parseFloat(day));
		},
		l: function l() {},
		m: function m(dateObj, month) {
			dateObj.setMonth(parseFloat(month) - 1);
		},
		n: function n(dateObj, month) {
			dateObj.setMonth(parseFloat(month) - 1);
		},
		s: function s(dateObj, seconds) {
			dateObj.setSeconds(parseFloat(seconds));
		},
		w: function w() {},
		y: function y(dateObj, year) {
			dateObj.setFullYear(2000 + parseFloat(year));
		}
	},

	tokenRegex: {
		D: "(\\w+)",
		F: "(\\w+)",
		G: "(\\d\\d|\\d)",
		H: "(\\d\\d|\\d)",
		J: "(\\d\\d|\\d)\\w+",
		K: "(am|AM|Am|aM|pm|PM|Pm|pM)",
		M: "(\\w+)",
		S: "(\\d\\d|\\d)",
		U: "(.+)",
		W: "(\\d\\d|\\d)",
		Y: "(\\d{4})",
		Z: "(.+)",
		d: "(\\d\\d|\\d)",
		h: "(\\d\\d|\\d)",
		i: "(\\d\\d|\\d)",
		j: "(\\d\\d|\\d)",
		l: "(\\w+)",
		m: "(\\d\\d|\\d)",
		n: "(\\d\\d|\\d)",
		s: "(\\d\\d|\\d)",
		w: "(\\d\\d|\\d)",
		y: "(\\d{2})"
	},

	pad: function pad(number) {
		return ("0" + number).slice(-2);
	},

	/**
  * Parses a date(+time) string into a Date object
  * @param {String} date the date string, e.g. 2017-02-03 14:45
  * @param {String} givenFormat the date format, e.g. Y-m-d H:i
  * @param {Boolean} timeless whether to reset the time of Date object
  * @return {Date} the parsed Date object
  */
	parseDate: function parseDate(date, givenFormat, timeless) {
		var _this2 = this;

		if (date !== 0 && !date) return null;

		var date_orig = date;

		if (date instanceof Date) date = new Date(date.getTime()); // create a copy

		else if (date.toFixed !== undefined) // timestamp
				date = new Date(date);else {
				// date string
				var format = givenFormat || (this.config || flatpickr.defaultConfig).dateFormat;
				date = String(date).trim();

				if (date === "today") {
					date = new Date();
					timeless = true;
				} else if (/Z$/.test(date) || /GMT$/.test(date)) // datestrings w/ timezone
					date = new Date(date);else if (this.config && this.config.parseDate) date = this.config.parseDate(date, format);else {
					(function () {
						var parsedDate = !_this2.config || !_this2.config.noCalendar ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0) : new Date(new Date().setHours(0, 0, 0, 0));

						var matched = void 0,
						    ops = [];

						for (var i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {
							var token = format[i];
							var isBackSlash = token === "\\";
							var escaped = format[i - 1] === "\\" || isBackSlash;

							if (_this2.tokenRegex[token] && !escaped) {
								regexStr += _this2.tokenRegex[token];
								var match = new RegExp(regexStr).exec(date);
								if (match && (matched = true)) {
									ops[token !== "Y" ? "push" : "unshift"]({
										fn: _this2.revFormat[token],
										val: match[++matchIndex]
									});
								}
							} else if (!isBackSlash) regexStr += "."; // don't really care

							ops.forEach(function (_ref) {
								var fn = _ref.fn,
								    val = _ref.val;
								return parsedDate = fn(parsedDate, val) || parsedDate;
							});
						}

						date = matched ? parsedDate : null;
					})();
				}
			}

		/* istanbul ignore next */
		if (!(date instanceof Date)) {
			console.warn("flatpickr: invalid date " + date_orig);
			console.info(this.element);
			return null;
		}

		if (timeless === true) date.setHours(0, 0, 0, 0);

		return date;
	}
};

/* istanbul ignore next */
function _flatpickr(nodeList, config) {
	var nodes = Array.prototype.slice.call(nodeList); // static list
	var instances = [];
	for (var i = 0; i < nodes.length; i++) {
		try {
			if (nodes[i].getAttribute("data-fp-omit") !== null) continue;

			if (nodes[i]._flatpickr) {
				nodes[i]._flatpickr.destroy();
				nodes[i]._flatpickr = null;
			}

			nodes[i]._flatpickr = new FlatpickrInstance(nodes[i], config || {});
			instances.push(nodes[i]._flatpickr);
		} catch (e) {
			console.warn(e, e.stack);
		}
	}

	return instances.length === 1 ? instances[0] : instances;
}

/* istanbul ignore next */
if (typeof HTMLElement !== "undefined") {
	// browser env
	HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function (config) {
		return _flatpickr(this, config);
	};

	HTMLElement.prototype.flatpickr = function (config) {
		return _flatpickr([this], config);
	};
}

/* istanbul ignore next */
function flatpickr(selector, config) {
	if (selector instanceof NodeList) return _flatpickr(selector, config);else if (!(selector instanceof HTMLElement)) return _flatpickr(window.document.querySelectorAll(selector), config);

	return _flatpickr([selector], config);
}

/* istanbul ignore next */
flatpickr.defaultConfig = FlatpickrInstance.defaultConfig = {
	mode: "single",

	position: "auto",

	animate: typeof window !== "undefined" && window.navigator.userAgent.indexOf("MSIE") === -1,

	// wrap: see https://chmln.github.io/flatpickr/examples/#flatpickr-external-elements
	wrap: false,

	// enables week numbers
	weekNumbers: false,

	// allow manual datetime input
	allowInput: false,

	/*
 	clicking on input opens the date(time)picker.
 	disable if you wish to open the calendar manually with .open()
 */
	clickOpens: true,

	/*
 	closes calendar after date selection,
 	unless 'mode' is 'multiple' or enableTime is true
 */
	closeOnSelect: true,

	// display time picker in 24 hour mode
	time_24hr: false,

	// enables the time picker functionality
	enableTime: false,

	// noCalendar: true will hide the calendar. use for a time picker along w/ enableTime
	noCalendar: false,

	// more date format chars at https://chmln.github.io/flatpickr/#dateformat
	dateFormat: "Y-m-d",

	// date format used in aria-label for days
	ariaDateFormat: "F j, Y",

	// altInput - see https://chmln.github.io/flatpickr/#altinput
	altInput: false,

	// the created altInput element will have this class.
	altInputClass: "form-control input",

	// same as dateFormat, but for altInput
	altFormat: "F j, Y", // defaults to e.g. June 10, 2016

	// defaultDate - either a datestring or a date object. used for datetimepicker"s initial value
	defaultDate: null,

	// the minimum date that user can pick (inclusive)
	minDate: null,

	// the maximum date that user can pick (inclusive)
	maxDate: null,

	// dateparser that transforms a given string to a date object
	parseDate: null,

	// dateformatter that transforms a given date object to a string, according to passed format
	formatDate: null,

	getWeek: function getWeek(givenDate) {
		var date = new Date(givenDate.getTime());
		var onejan = new Date(date.getFullYear(), 0, 1);
		return Math.ceil(((date - onejan) / 86400000 + onejan.getDay() + 1) / 7);
	},


	// see https://chmln.github.io/flatpickr/#disable
	enable: [],

	// see https://chmln.github.io/flatpickr/#disable
	disable: [],

	// display the short version of month names - e.g. Sep instead of September
	shorthandCurrentMonth: false,

	// displays calendar inline. see https://chmln.github.io/flatpickr/#inline-calendar
	inline: false,

	// position calendar inside wrapper and next to the input element
	// leave at false unless you know what you"re doing
	"static": false,

	// DOM node to append the calendar to in *static* mode
	appendTo: null,

	// code for previous/next icons. this is where you put your custom icon code e.g. fontawesome
	prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
	nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",

	// enables seconds in the time picker
	enableSeconds: false,

	// step size used when scrolling/incrementing the hour element
	hourIncrement: 1,

	// step size used when scrolling/incrementing the minute element
	minuteIncrement: 5,

	// initial value in the hour element
	defaultHour: 12,

	// initial value in the minute element
	defaultMinute: 0,

	// initial value in the seconds element
	defaultSeconds: 0,

	// disable native mobile datetime input support
	disableMobile: false,

	// default locale
	locale: "default",

	plugins: [],

	ignoredFocusElements: [],

	// called every time calendar is closed
	onClose: undefined, // function (dateObj, dateStr) {}

	// onChange callback when user selects a date or time
	onChange: undefined, // function (dateObj, dateStr) {}

	// called for every day element
	onDayCreate: undefined,

	// called every time the month is changed
	onMonthChange: undefined,

	// called every time calendar is opened
	onOpen: undefined, // function (dateObj, dateStr) {}

	// called after the configuration has been parsed
	onParseConfig: undefined,

	// called after calendar is ready
	onReady: undefined, // function (dateObj, dateStr) {}

	// called after input value updated
	onValueUpdate: undefined,

	// called every time the year is changed
	onYearChange: undefined,

	onKeyDown: undefined,

	onDestroy: undefined
};

/* istanbul ignore next */
flatpickr.l10ns = {
	en: {
		weekdays: {
			shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
			longhand: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
		},
		months: {
			shorthand: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
			longhand: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
		},
		daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
		firstDayOfWeek: 0,
		ordinal: function ordinal(nth) {
			var s = nth % 100;
			if (s > 3 && s < 21) return "th";
			switch (s % 10) {
				case 1:
					return "st";
				case 2:
					return "nd";
				case 3:
					return "rd";
				default:
					return "th";
			}
		},
		rangeSeparator: " to ",
		weekAbbreviation: "Wk",
		scrollTitle: "Scroll to increment",
		toggleTitle: "Click to toggle"
	}
};

flatpickr.l10ns.default = Object.create(flatpickr.l10ns.en);
flatpickr.localize = function (l10n) {
	return _extends(flatpickr.l10ns.default, l10n || {});
};
flatpickr.setDefaults = function (config) {
	return _extends(flatpickr.defaultConfig, config || {});
};

/* istanbul ignore next */
if (typeof jQuery !== "undefined") {
	jQuery.fn.flatpickr = function (config) {
		return _flatpickr(this, config);
	};
}

Date.prototype.fp_incr = function (days) {
	return new Date(this.getFullYear(), this.getMonth(), this.getDate() + parseInt(days, 10));
};

if (true) module.exports = flatpickr;

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./": 12,
	"./ar": 13,
	"./ar.js": 13,
	"./bg": 14,
	"./bg.js": 14,
	"./bn": 15,
	"./bn.js": 15,
	"./cat": 16,
	"./cat.js": 16,
	"./cs": 17,
	"./cs.js": 17,
	"./cy": 18,
	"./cy.js": 18,
	"./da": 19,
	"./da.js": 19,
	"./de": 20,
	"./de.js": 20,
	"./eo": 21,
	"./eo.js": 21,
	"./es": 22,
	"./es.js": 22,
	"./et": 23,
	"./et.js": 23,
	"./fa": 24,
	"./fa.js": 24,
	"./fi": 25,
	"./fi.js": 25,
	"./fr": 26,
	"./fr.js": 26,
	"./gr": 27,
	"./gr.js": 27,
	"./he": 28,
	"./he.js": 28,
	"./hi": 29,
	"./hi.js": 29,
	"./hr": 30,
	"./hr.js": 30,
	"./hu": 31,
	"./hu.js": 31,
	"./id": 32,
	"./id.js": 32,
	"./index": 12,
	"./index.js": 12,
	"./it": 33,
	"./it.js": 33,
	"./ja": 34,
	"./ja.js": 34,
	"./ko": 35,
	"./ko.js": 35,
	"./lt": 36,
	"./lt.js": 36,
	"./lv": 37,
	"./lv.js": 37,
	"./mk": 38,
	"./mk.js": 38,
	"./ms": 39,
	"./ms.js": 39,
	"./my": 40,
	"./my.js": 40,
	"./nl": 41,
	"./nl.js": 41,
	"./no": 42,
	"./no.js": 42,
	"./pa": 43,
	"./pa.js": 43,
	"./pl": 44,
	"./pl.js": 44,
	"./pt": 45,
	"./pt.js": 45,
	"./ro": 46,
	"./ro.js": 46,
	"./ru": 47,
	"./ru.js": 47,
	"./si": 48,
	"./si.js": 48,
	"./sk": 49,
	"./sk.js": 49,
	"./sl": 50,
	"./sl.js": 50,
	"./sq": 51,
	"./sq.js": 51,
	"./sr": 52,
	"./sr.js": 52,
	"./sv": 53,
	"./sv.js": 53,
	"./th": 54,
	"./th.js": 54,
	"./tr": 55,
	"./tr.js": 55,
	"./uk": 56,
	"./uk.js": 56,
	"./vn": 57,
	"./vn.js": 57,
	"./zh": 58,
	"./zh.js": 58
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number or string
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 118;

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Ajax = __webpack_require__(2);

var _Ajax2 = _interopRequireDefault(_Ajax);

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

var _jquery = __webpack_require__(4);

var _jquery2 = _interopRequireDefault(_jquery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _class = function () {
    function _class(domains, local) {
        var _this = this;

        _classCallCheck(this, _class);

        this.domains = domains;
        this.locale = {};
        var language = void 0;

        if (local !== false) this.local = local;

        if (localStorage.getItem('locale_' + this.local) && local !== false) language = localStorage.getItem('locale_' + this.local);else language = _Global2.default.html.getAttribute('lang');

        this.language = language;

        domains.forEach(function (domain) {

            _this.locale[domain] = _Ajax2.default.getJSON("app/Data/Locale/" + language + "/" + domain + ".json", false);
            _this.changeLanguage(language, _this.locale[domain]);
        });
    }

    _createClass(_class, [{
        key: 'getLanguage',
        value: function getLanguage() {
            return this.language;
        }
    }, {
        key: 'getLocale',
        value: function getLocale() {
            return this.locale;
        }
    }, {
        key: 'changeLanguage',
        value: function changeLanguage(language, locale) {

            // Change local storage
            if (this.local) localStorage.setItem('locale_' + this.local, language);

            // Change html element lang
            _Global2.default.html.setAttribute('lang', locale['LOCALE']);

            // Translate website
            (0, _jquery2.default)('[data-locale]').each(function () {

                var phrase = (0, _jquery2.default)(this).data('locale');
                (0, _jquery2.default)(this).html(locale[phrase]);
            });

            // Translate placeholders
            (0, _jquery2.default)('[data-placeholder]').each(function () {

                var phrase = (0, _jquery2.default)(this).data('placeholder');
                (0, _jquery2.default)('[data-placeholder="' + phrase + '"]').attr('placeholder', locale[phrase]);
            });

            // Translate title attributes
            (0, _jquery2.default)('[data-title]').each(function () {

                var phrase = (0, _jquery2.default)(this).data('title');
                (0, _jquery2.default)('[data-title="' + phrase + '"]').attr('title', locale[phrase]);
            });

            (0, _jquery2.default)('[data-sublocale]').each(function () {

                var phrase = (0, _jquery2.default)(this).data('sublocale');
                (0, _jquery2.default)('[data-sublocale="' + phrase + '"]').html(locale[phrase]);
            });
        }
    }, {
        key: 'translateLocales',
        value: function translateLocales(locales) {
            var _this2 = this;

            locales.forEach(function (locale) {
                _this2.addTranslation(locale);
            });
        }
    }, {
        key: 'addTranslation',
        value: function addTranslation(locale) {

            if (this.locale[locale]) {
                this.changeLanguage(this.language, this.locale[locale]);
                return true;
            }

            this.domains.push(locale);
            this.locale[locale] = _Ajax2.default.getJSON("app/Data/Locale/" + this.language + "/" + locale + ".json", false);
            this.changeLanguage(this.language, this.locale[locale]);
        }
    }, {
        key: 'switchLanguage',
        value: function switchLanguage(language) {
            var _this3 = this;

            if (language === this.language) return false;

            _Global2.default.html.setAttribute('lang', language);
            this.language = language;

            this.domains.forEach(function (domain) {

                _this3.locale[domain] = _Ajax2.default.getJSON("app/Data/Locale/" + language + "/" + domain + ".json", false);
                _this3.changeLanguage(language, _this3.locale[domain]);
            });
        }
    }]);

    return _class;
}();

exports.default = _class;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MediaManager = undefined;

var _jquery = __webpack_require__(4);

var _jquery2 = _interopRequireDefault(_jquery);

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

var _Router = __webpack_require__(3);

var _Router2 = _interopRequireDefault(_Router);

var _Csrf = __webpack_require__(5);

var _Csrf2 = _interopRequireDefault(_Csrf);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function MediaManager(parameters) {

    // Files
    this.files = [];

    // Manager default settings
    this.config = {
        manager: 'images'
    };

    // Save given parameters
    this.parameters = parameters;

    this.applyParameters();

    this.start();
}

MediaManager.prototype.applyParameters = function () {

    var allowedParameters = ['manager', 'callback', 'onSelect'];
    for (var i in this.parameters) {
        if (allowedParameters.indexOf(i) === -1) continue;
        this.config[i] = this.parameters[i];
    }
};

MediaManager.prototype.start = function () {

    // Show manager
    (0, _jquery2.default)('div.media-manager').addClass('show');

    // On Select
    if ('onSelect' in this.config) {

        var mediaManagerElement = (0, _jquery2.default)('div.media-manager');
        var selectEvent = function (event) {
            mediaManagerElement.off('click', 'li.item-file input');
            if (event.target.parentNode.getAttribute('data-type') !== this.config.manager) return false;
            var name = event.target.parentNode.innerText;
            this.config.onSelect(name.trim());
        }.bind(this);

        mediaManagerElement.on('click', 'li.item-file input', selectEvent);
    }
};

MediaManager.prototype.addFile = function (file) {

    document.querySelector('div.manager-queue').classList.add('show');

    var newFile = {
        name: file.name,
        size: file.size,
        type: file.type
    };

    var type = file.type.split('/')[0];

    var formData = new FormData();
    formData.append("file", file);
    newFile['data'] = formData;

    // Push item into list
    var itemElement = document.createElement('div');
    itemElement.classList.add('queue-item');
    var iconElement = document.createElement('div');
    iconElement.classList.add('type-icon');
    iconElement.classList.add('icon-' + type + '_white');
    var nameElement = document.createElement('p');
    nameElement.classList.add('item-name');
    nameElement.innerText = newFile.name;
    var removeElement = document.createElement('span');
    removeElement.classList.add('remove-item');
    removeElement.classList.add('icon-close_white');
    var uploadElement = document.createElement('span');
    uploadElement.classList.add('upload-item');
    uploadElement.setAttribute('data-locale', 'UPLOAD');
    uploadElement.innerText = _Global2.default.translate.locale.admin_header.UPLOAD;

    itemElement.appendChild(iconElement);
    itemElement.appendChild(nameElement);
    itemElement.appendChild(removeElement);
    itemElement.appendChild(uploadElement);
    document.querySelector('div.manager-queue-list').appendChild(itemElement);
    document.querySelector('div.manager-queue').classList.remove('minimize');

    this.files.push(newFile);
};

MediaManager.prototype.removeFile = function (file) {

    var pos = -1;
    for (var i = 0; i < this.files.length; ++i) {
        if (this.files[i].name == file) pos = i;
    }

    this.files.splice(pos, 1);
};

MediaManager.prototype.uploadFile = function (file) {
    var _this = this;

    var pos = -1;
    for (var i = 0; i < this.files.length; ++i) {
        if (this.files[i].name == file) pos = i;
    }

    var fileData = this.files[pos];
    var result = false;

    _jquery2.default.ajax({
        method: "POST",
        url: _Router2.default.createLink('mediaManager/upload&csrf_token=' + _Csrf2.default.getToken()),
        async: false,
        data: fileData.data,
        cache: false,
        processData: false,
        contentType: false,
        success: function success() {
            _this.files.splice(pos, 1);
            result = true;
        },
        error: function error() {
            result = false;
        }
    });

    setTimeout(function () {
        _Global2.default.managerActiveInstance.updateFiles();
    }, 500);

    return result;
};

MediaManager.prototype.updateFiles = function () {

    _jquery2.default.ajax({
        method: "POST",
        url: '?route=' + (0, _jquery2.default)('meta[name=route]').attr('content') + '/mediaManager/filelist',
        async: true,
        data: {
            csrf_token: document.querySelector('meta[name=csrf_token]').getAttribute('content')
        },
        success: function success(response) {
            (0, _jquery2.default)('div.manager-content').html(response);
        }
    });
};

// Load media manager GUI
_jquery2.default.ajax({
    method: "GET",
    url: '?route=' + (0, _jquery2.default)('meta[name=route]').attr('content') + '/mediaManager&csrf_token=' + document.querySelector('meta[name=csrf_token]').getAttribute('content'),
    async: false,
    success: function success(result) {

        document.querySelector('body').insertAdjacentHTML('beforeend', result);

        // Events
        (0, _jquery2.default)('button.manager-upload-image').click(function () {
            (0, _jquery2.default)('input[name=media_manager_input_image]').click();
        });

        (0, _jquery2.default)('button.manager-upload-video').click(function () {
            (0, _jquery2.default)('input[name=media_manager_input_video]').click();
        });

        (0, _jquery2.default)('button.manager-upload-audio').click(function () {
            (0, _jquery2.default)('input[name=media_manager_input_audio]').click();
        });

        (0, _jquery2.default)('button.manager-upload-file').click(function () {
            (0, _jquery2.default)('input[name=media_manager_input_file]').click();
        });

        (0, _jquery2.default)('input[name=media_manager_input_image]').change(function (event) {
            _Global2.default.managerActiveInstance.addFile(event.target.files[0]);
        });

        (0, _jquery2.default)('input[name=media_manager_input_video]').change(function (event) {
            _Global2.default.managerActiveInstance.addFile(event.target.files[0]);
        });

        (0, _jquery2.default)('input[name=media_manager_input_audio]').change(function (event) {
            _Global2.default.managerActiveInstance.addFile(event.target.files[0]);
        });

        (0, _jquery2.default)('input[name=media_manager_input_file]').change(function (event) {
            _Global2.default.managerActiveInstance.addFile(event.target.files[0]);
        });

        // Close manager with button
        (0, _jquery2.default)('div.media-manager span.close-manager').click(function () {
            var mediaManagerElement = (0, _jquery2.default)('div.media-manager');
            mediaManagerElement.removeClass('show');
            mediaManagerElement.off('click', 'li.item-file input');
        });

        // Minimize manager queue
        (0, _jquery2.default)('div.manager-queue-header').click(function () {
            (0, _jquery2.default)('div.manager-queue').toggleClass('minimize');
        });

        // Remove item on remove click
        var html = (0, _jquery2.default)('html');
        html.on('click', 'div.queue-item span.remove-item', function (event) {
            var fileName = event.target.parentNode.querySelector('p').innerText;
            _Global2.default.managerActiveInstance.removeFile(fileName);
            var element = event.target.parentNode;
            element.parentNode.removeChild(element);
        });

        // Upload item on click
        html.on('click', 'div.queue-item span.upload-item', function (event) {

            document.querySelector('div.manager-queue').classList.add('loading');
            var fileName = event.target.parentNode.querySelector('p').innerText;

            if (_Global2.default.managerActiveInstance.uploadFile(fileName)) {
                var element = event.target.parentNode;
                element.parentNode.removeChild(element);
            }

            setTimeout(function () {
                document.querySelector('div.manager-queue').classList.remove('loading');
            }, 600);
        });
    }
});

exports.MediaManager = MediaManager;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){ true?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.Selector=t():e.Selector=t()}(this,function(){return function(e){function t(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}var n={};return t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=14)}([function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0});var o=n(13),i=r(o);r(n(1)),t.default={parentTemplate:void 0,selectedTemplate:void 0,groupTemplate:void 0,optionsTemplate:void 0,optionTemplate:void 0,filterTemplate:void 0,constructor:function(e,t){this.Settings=t,this.element=e,this.createElements();var n=new i.default(e,t);n.renderParent(),n.renderContent(),n.renderSelected(),n.show()},isFilterType:function(){return"filter"===this.Settings.type||(this.element.getAttribute("data-type")||"").match(/(search)|(find)/)},createElement:function(e,t){var n=document.createElement(e);return Object.keys(t).forEach(function(e){n.setAttribute(e,t[e])}),n},createElements:function(){this.createParentElement(),this.createSelectedElement(),this.createGroupElement(),this.createOptionsElement(),this.createOptionElement(),this.parentTemplate.appendChild(this.selectedTemplate),this.parentTemplate.appendChild(this.optionsTemplate)},createParentElement:function(){this.parentTemplate=this.createElement("div",{class:"selector-element","data-reference":"","data-type":"",id:""})},createSelectedElement:function(){this.selectedTemplate=this.createElement("div",{class:"selector-selected"}),this.selectedTemplate.appendChild(this.createElement("p",{class:"selected-text"}))},createGroupElement:function(){this.groupTemplate=this.createElement("div",{class:"selector-group","data-group":""}),this.groupTemplate.appendChild(this.createElement("span",{class:"group-text"}))},createOptionsElement:function(){this.optionsTemplate=this.createElement("div",{class:"selector-options"})},createOptionElement:function(){this.optionTemplate=this.createElement("div",{class:"selector-option show","data-item":""}),this.optionTemplate.appendChild(this.createElement("span",{class:"option-text"}))},createFilterElement:function(){this.filterTemplate=this.createElement("div",{class:"selector-filter"}),this.filterTemplate.appendChild(this.createElement("input",{class:"selector-filter-input",type:"search","data-placeholder":"SELECTOR_FILTER_PLACEHOLDER",placeholder:"Filter options"})),this.filterTemplate.appendChild(this.createElement("span",{class:"selector-filter-clear"}))}}},function(e,t,n){"use strict";function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var o=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),i=n(0),s=function(e){return e&&e.__esModule?e:{default:e}}(i),a=function(){function e(t){r(this,e),this.Settings=t}return o(e,[{key:"showOptions",value:function(e,t){var n=this.Settings.data,r=s.default.isFilterType(),o=t.matches("[data-disabled]");t.querySelector(".selector-selected").addEventListener("click",function(){if(o)return!1;if(e.classList.toggle("visible"),r){var i=t.querySelector("input");i.focus(),i.value="",i.oninput()}e.classList.contains("visible")?n.closed?n.closed():n.onClose&&n.onClose():n.opened?n.opened():n.onOpen&&n.onOpen()})}},{key:"clearFilter",value:function(e,t){e.addEventListener("click",function(){t.value="",t.oninput()})}},{key:"filterOptions",value:function(e,t){var n=e.querySelector("input"),r=t.querySelector(".selector-options");this.clearFilter(e.querySelector("span"),n),this.createIndex(r),n.oninput=function(){var e=n.value.trim().toLowerCase(),t=r.querySelectorAll(".selector-option");JSON.parse(r.dataset.index).forEach(function(n,r){-1!==n[0].indexOf(e)||-1!==n[1].indexOf(e)?t[r].classList.add("show"):t[r].classList.remove("show")})},n.onkeyup=function(e){if(e.keyCode&&13===e.keyCode){var n=t.querySelectorAll(".selector-option.show");if(1!==n.length)return!1;n[0].click()}}}},{key:"createIndex",value:function(e){var t=Array.from(e.querySelectorAll(".selector-option")).map(function(e){return[e.children[0].innerText.toLowerCase(),e.dataset.item.toLowerCase()]});e.dataset.index=JSON.stringify(t)}},{key:"select",value:function(e){var t=e.querySelector(".selector-selected"),n=this.Settings.data,r=document.querySelector('select[name="'+e.dataset.reference+'"]');e.querySelector(".selector-options").addEventListener("click",function(o){var i=o.target,s=".selector-option";if(i.matches(s)||i.parentNode.matches(s)){if(i.matches(s)||(i=i.parentNode),i.dataset.disabled||i.dataset.selected||i.parentNode.matches("[data-disabled]"))return!1;var a=e.querySelector("[data-selected]"),l=i.dataset.item;n.beforeSelect&&n.beforeSelect(e,l),delete a.dataset.selected,i.dataset.selected="",t.dataset.item=l,t.children[0].innerText=i.children[0].innerText,t.click(),r.querySelector("[selected]").removeAttribute("selected"),r.querySelector('[value="'+i.dataset.item+'"]').setAttribute("selected","true"),n.selected?n.selected(e,i.dataset.item):n.onSelect&&n.onSelect(e,i)}})}}],[{key:"closeSelector",value:function(){document.addEventListener("click",function(e){document.querySelectorAll(".selector-element").forEach(function(t){e.target===t||t.contains(e.target)||t.querySelector(".selector-options").classList.remove("visible")})})}}]),e}();t.default=a},function(e,t,n){"use strict";n(3)},function(e,t,n){var r=n(4);"string"==typeof r&&(r=[[e.i,r,""]]);var o={};o.transform=void 0,n(8)(r,o),r.locals&&(e.exports=r.locals)},function(e,t,n){t=e.exports=n(5)(void 0),t.push([e.i,'div.selector-element{position:relative;display:inline-block;width:320px;height:38px;background:#fff;box-shadow:0 1px 2px rgba(0,0,0,.05);box-sizing:border-box;border:1px solid silver;border-radius:3px;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,sans-serif;font-size:.92rem;transition:.2s ease-in-out}div.selector-element:hover{box-shadow:0 2px 4px rgba(0,0,0,.1)}div.selector-element div.selector-selected{position:relative;display:inline-block;width:100%;height:36px;cursor:pointer;background:#fff;box-sizing:border-box;padding:0 28px 0 11px;transition:.2s ease-in-out}div.selector-element div.selector-selected:hover{background:#fbfbfb}div.selector-element div.selector-selected:after{content:"";position:absolute;right:12px;top:50%;transform:translateY(-50%);border-top:6px solid silver;border-left:6px solid transparent;border-right:6px solid transparent}div.selector-element div.selector-selected p{display:inline-block;width:100%;height:100%;line-height:36px;margin:0;white-space:nowrap;text-overflow:ellipsis;overflow:hidden}div.selector-element div.selector-options{position:absolute;top:100%;left:-1px;display:none;width:100%;height:auto;max-height:210px;overflow:auto;z-index:99;border:1px solid silver;background:#fff;box-shadow:0 2px 4px rgba(0,0,0,.1);border-bottom-left-radius:3px;border-bottom-right-radius:3px}div.selector-element div.selector-options.visible{display:inline-block}div.selector-element div.selector-options div.selector-filter{position:-webkit-sticky;position:sticky;top:0;width:100%;height:32px;border-bottom:1px solid silver;z-index:2}div.selector-element div.selector-options div.selector-filter input{width:100%;height:100%;outline:none;border:none;background:#fff url('+n(6)+") left 11px center no-repeat;background-size:18px;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,sans-serif;font-size:.8rem;box-sizing:border-box;padding:0 36px}div.selector-element div.selector-options div.selector-filter .selector-filter-clear{position:absolute;right:9px;height:18px;width:18px;top:50%;transform:translateY(-50%);background:url("+n(7)+") 50% no-repeat;background-size:18px;opacity:.7;cursor:pointer}div.selector-element div.selector-options div.selector-filter .selector-filter-clear:hover{opacity:1}div.selector-element div.selector-options div.selector-group{display:inline-block;position:relative;float:left;width:100%;border-bottom:3px solid silver}div.selector-element div.selector-options div.selector-group span.group-text{display:inline-block;position:-webkit-sticky;position:sticky;top:0;float:left;width:100%;line-height:32px;text-transform:uppercase;font-size:.75rem;font-weight:600;background:#fbfbfb;color:#6b6b6b;box-sizing:border-box;padding:0 11px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;z-index:1}div.selector-element div.selector-options div.selector-group[data-disabled],div.selector-element div.selector-options div.selector-group[data-disabled] div.selector-option{opacity:.6;cursor:not-allowed}div.selector-element div.selector-options div.selector-option{position:relative;display:none;width:100%;height:32px;background:#fff;border-bottom:1px solid #ddd;cursor:pointer;box-sizing:border-box;transition:.2s ease-in-out}div.selector-element div.selector-options div.selector-option:hover{background:#f5f5f5}div.selector-element div.selector-options div.selector-option[data-selected]{background:#f2f2f2;font-weight:600}div.selector-element div.selector-options div.selector-option.show{display:inline-block}div.selector-element div.selector-options div.selector-option span.option-text{display:inline-block;width:100%;line-height:32px;font-size:.85rem;box-sizing:border-box;padding:0 11px}div.selector-element div.selector-options div.selector-option:last-of-type{border-bottom:none}div.selector-element div.selector-options div.selector-option[data-disabled]{opacity:.6;cursor:not-allowed}div.selector-element[data-type=find] span.group-text,div.selector-element[data-type=search] span.group-text{top:33px!important}div.selector-element[data-disabled]{opacity:.6;cursor:not-allowed}div.selector-element[data-disabled]:hover{box-shadow:inherit}div.selector-element[data-disabled] div.selector-selected{cursor:not-allowed}div.selector-element[data-disabled] div.selector-selected:hover{background:#fff}",""])},function(e,t){function n(e,t){var n=e[1]||"",o=e[3];if(!o)return n;if(t&&"function"==typeof btoa){var i=r(o);return[n].concat(o.sources.map(function(e){return"/*# sourceURL="+o.sourceRoot+e+" */"})).concat([i]).join("\n")}return[n].join("\n")}function r(e){return"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(e))))+" */"}e.exports=function(e){var t=[];return t.toString=function(){return this.map(function(t){var r=n(t,e);return t[2]?"@media "+t[2]+"{"+r+"}":r}).join("")},t.i=function(e,n){"string"==typeof e&&(e=[[null,e,""]]);for(var r={},o=0;o<this.length;o++){var i=this[o][0];"number"==typeof i&&(r[i]=!0)}for(o=0;o<e.length;o++){var s=e[o];"number"==typeof s[0]&&r[s[0]]||(n&&!s[2]?s[2]=n:n&&(s[2]="("+s[2]+") and ("+n+")"),t.push(s))}},t}},function(e,t){e.exports="\"data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8' standalone='no'?%3E %3Csvg xmlns:dc='http://purl.org/dc/elements/1.1/' xmlns:cc='http://creativecommons.org/ns%23' xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns%23' xmlns:svg='http://www.w3.org/2000/svg' xmlns='http://www.w3.org/2000/svg' xmlns:sodipodi='http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd' xmlns:inkscape='http://www.inkscape.org/namespaces/inkscape' width='24' height='24' viewBox='0 0 24 24' id='svg2' version='1.1' inkscape:version='0.91 r13725' sodipodi:docname='search.svg'%3E %3Cmetadata id='metadata10'%3E %3Crdf:RDF%3E %3Ccc:Work rdf:about=''%3E %3Cdc:format%3Eimage/svg+xml%3C/dc:format%3E %3Cdc:type rdf:resource='http://purl.org/dc/dcmitype/StillImage' /%3E %3C/cc:Work%3E %3C/rdf:RDF%3E %3C/metadata%3E %3Cdefs id='defs8' /%3E %3Csodipodi:namedview pagecolor='%23ffffff' bordercolor='%23666666' borderopacity='1' objecttolerance='10' gridtolerance='10' guidetolerance='10' inkscape:pageopacity='0' inkscape:pageshadow='2' inkscape:window-width='764' inkscape:window-height='480' id='namedview6' showgrid='false' inkscape:zoom='9.8333333' inkscape:cx='12' inkscape:cy='12' inkscape:window-x='59' inkscape:window-y='24' inkscape:window-maximized='0' inkscape:current-layer='svg2' /%3E %3Cpath d='M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z' id='path4' style='fill:%234d4d4d' /%3E %3C/svg%3E\""},function(e,t){e.exports="\"data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8' standalone='no'?%3E %3Csvg xmlns:dc='http://purl.org/dc/elements/1.1/' xmlns:cc='http://creativecommons.org/ns%23' xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns%23' xmlns:svg='http://www.w3.org/2000/svg' xmlns='http://www.w3.org/2000/svg' xmlns:sodipodi='http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd' xmlns:inkscape='http://www.inkscape.org/namespaces/inkscape' width='24' height='24' viewBox='0 0 24 24' id='svg2' version='1.1' inkscape:version='0.91 r13725' sodipodi:docname='clear.svg'%3E %3Cmetadata id='metadata10'%3E %3Crdf:RDF%3E %3Ccc:Work rdf:about=''%3E %3Cdc:format%3Eimage/svg+xml%3C/dc:format%3E %3Cdc:type rdf:resource='http://purl.org/dc/dcmitype/StillImage' /%3E %3C/cc:Work%3E %3C/rdf:RDF%3E %3C/metadata%3E %3Cdefs id='defs8' /%3E %3Csodipodi:namedview pagecolor='%23ffffff' bordercolor='%23666666' borderopacity='1' objecttolerance='10' gridtolerance='10' guidetolerance='10' inkscape:pageopacity='0' inkscape:pageshadow='2' inkscape:window-width='764' inkscape:window-height='480' id='namedview6' showgrid='false' inkscape:zoom='9.8333333' inkscape:cx='12' inkscape:cy='12' inkscape:window-x='59' inkscape:window-y='24' inkscape:window-maximized='0' inkscape:current-layer='svg2' /%3E %3Cpath d='M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z' id='path4' style='fill:%234d4d4d' /%3E %3C/svg%3E\""},function(e,t,n){function r(e,t){for(var n=0;n<e.length;n++){var r=e[n],o=h[r.id];if(o){o.refs++;for(var i=0;i<o.parts.length;i++)o.parts[i](r.parts[i]);for(;i<r.parts.length;i++)o.parts.push(d(r.parts[i],t))}else{for(var s=[],i=0;i<r.parts.length;i++)s.push(d(r.parts[i],t));h[r.id]={id:r.id,refs:1,parts:s}}}}function o(e,t){for(var n=[],r={},o=0;o<e.length;o++){var i=e[o],s=t.base?i[0]+t.base:i[0],a=i[1],l=i[2],c=i[3],d={css:a,media:l,sourceMap:c};r[s]?r[s].parts.push(d):n.push(r[s]={id:s,parts:[d]})}return n}function i(e,t){var n=m(e.insertInto);if(!n)throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");var r=y[y.length-1];if("top"===e.insertAt)r?r.nextSibling?n.insertBefore(t,r.nextSibling):n.appendChild(t):n.insertBefore(t,n.firstChild),y.push(t);else{if("bottom"!==e.insertAt)throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");n.appendChild(t)}}function s(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e);var t=y.indexOf(e);t>=0&&y.splice(t,1)}function a(e){var t=document.createElement("style");return e.attrs.type="text/css",c(t,e.attrs),i(e,t),t}function l(e){var t=document.createElement("link");return e.attrs.type="text/css",e.attrs.rel="stylesheet",c(t,e.attrs),i(e,t),t}function c(e,t){Object.keys(t).forEach(function(n){e.setAttribute(n,t[n])})}function d(e,t){var n,r,o,i;if(t.transform&&e.css){if(!(i=t.transform(e.css)))return function(){};e.css=i}if(t.singleton){var c=g++;n=b||(b=a(t)),r=u.bind(null,n,c,!1),o=u.bind(null,n,c,!0)}else e.sourceMap&&"function"==typeof URL&&"function"==typeof URL.createObjectURL&&"function"==typeof URL.revokeObjectURL&&"function"==typeof Blob&&"function"==typeof btoa?(n=l(t),r=f.bind(null,n,t),o=function(){s(n),n.href&&URL.revokeObjectURL(n.href)}):(n=a(t),r=p.bind(null,n),o=function(){s(n)});return r(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap)return;r(e=t)}else o()}}function u(e,t,n,r){var o=n?"":r.css;if(e.styleSheet)e.styleSheet.cssText=w(t,o);else{var i=document.createTextNode(o),s=e.childNodes;s[t]&&e.removeChild(s[t]),s.length?e.insertBefore(i,s[t]):e.appendChild(i)}}function p(e,t){var n=t.css,r=t.media;if(r&&e.setAttribute("media",r),e.styleSheet)e.styleSheet.cssText=n;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(n))}}function f(e,t,n){var r=n.css,o=n.sourceMap,i=void 0===t.convertToAbsoluteUrls&&o;(t.convertToAbsoluteUrls||i)&&(r=x(r)),o&&(r+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(o))))+" */");var s=new Blob([r],{type:"text/css"}),a=e.href;e.href=URL.createObjectURL(s),a&&URL.revokeObjectURL(a)}var h={},v=function(e){var t;return function(){return void 0===t&&(t=e.apply(this,arguments)),t}}(function(){return window&&document&&document.all&&!window.atob}),m=function(e){var t={};return function(n){return void 0===t[n]&&(t[n]=e.call(this,n)),t[n]}}(function(e){return document.querySelector(e)}),b=null,g=0,y=[],x=n(9);e.exports=function(e,t){if("undefined"!=typeof DEBUG&&DEBUG&&"object"!=typeof document)throw new Error("The style-loader cannot be used in a non-browser environment");t=t||{},t.attrs="object"==typeof t.attrs?t.attrs:{},t.singleton||(t.singleton=v()),t.insertInto||(t.insertInto="head"),t.insertAt||(t.insertAt="bottom");var n=o(e,t);return r(n,t),function(e){for(var i=[],s=0;s<n.length;s++){var a=n[s],l=h[a.id];l.refs--,i.push(l)}e&&r(o(e,t),t);for(var s=0;s<i.length;s++){var l=i[s];if(0===l.refs){for(var c=0;c<l.parts.length;c++)l.parts[c]();delete h[l.id]}}}};var w=function(){var e=[];return function(t,n){return e[t]=n,e.filter(Boolean).join("\n")}}()},function(e,t){e.exports=function(e){var t="undefined"!=typeof window&&window.location;if(!t)throw new Error("fixUrls requires window.location");if(!e||"string"!=typeof e)return e;var n=t.protocol+"//"+t.host,r=n+t.pathname.replace(/\/[^\/]*$/,"/");return e.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi,function(e,t){var o=t.trim().replace(/^"(.*)"$/,function(e,t){return t}).replace(/^'(.*)'$/,function(e,t){return t});if(/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(o))return e;var i;return i=0===o.indexOf("//")?o:0===o.indexOf("/")?n+o:r+o.replace(/^\.\//,""),"url("+JSON.stringify(i)+")"})}},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}var i=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),s=n(11),a=r(s),l=n(12),c=r(l);e.exports=function(){function e(t){o(this,e),this.Settings=new a.default(t),c.default.constructor(this.Settings)}return i(e,[{key:"destroy",value:function(){c.default.destroy()}}]),e}()},function(e,t,n){"use strict";function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var o=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),i=function(){function e(t){var n=this;r(this,e),this.data={selector:null,callback:null,onOpen:null,onClose:null,onSelect:null,destroy:null,element:null,created:null,opened:null,closed:null,selected:null,beforeCreate:null,beforeSelect:null,beforeDestroy:null,destroyed:null,label:null,type:null},Object.keys(t).forEach(function(e){n.data[e]=t[e]})}return o(e,[{key:"set",value:function(e,t){this.data[e]=t}}]),e}();t.default=i},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0});var o=n(0),i=r(o),s=n(1),a=r(s);t.default={constructor:function(e){this.Settings=e,this.prepareElements(),this.render()},prepareElements:function(){var e=this.Settings.data.element;if("string"==typeof e){if(e=document.querySelectorAll(e),0===e.length)throw new DOMException;this.Settings.set("element",e)}},render:function(){var e=this;this.Settings.data.element.forEach(function(t){if(!e.checkElement(t))return!1;i.default.constructor(t,e.Settings)}),a.default.closeSelector()},checkElement:function(e){return!!e.nodeType&&"SELECT"===e.tagName},destroy:function(){var e=this.Settings.data;e.beforeDestroy&&e.beforeDestroy(),e.element.forEach(function(e){var t=e.parentNode;t.removeChild(t.querySelector('[data-reference="'+e.name+'"]')),e.style.display=""}),e.destroyed&&e.destroyed()}}},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var i=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),s=n(0),a=r(s),l=n(1),c=r(l),d=function(){function e(t,n){o(this,e),this.Settings=n,this.Events=new c.default(n),this._element=t,this.hideOrigin(),this._render=null}return i(e,[{key:"hideOrigin",value:function(){this._element.style.display="none"}},{key:"renderParent",value:function(){var e=a.default.parentTemplate.cloneNode(!0);e.id=this._element.id,e.dataset.reference=this._element.name,e.dataset.type=this.Settings.type||this._element.dataset.type||"default",this._element.disabled&&(e.dataset.disabled=!0),this._render=e}},{key:"renderContent",value:function(){var e=this,t=void 0,n=this._render.querySelector(".selector-options");if(this.Events.showOptions(n,this._render),a.default.isFilterType()){var r=this.renderSearch();n.appendChild(r),this.Events.filterOptions(r,this._render)}Array.from(this._element.children).forEach(function(r){var o=r.tagName;if("OPTGROUP"===o)t=e.renderGroup(r);else{if("OPTION"!==o)return!0;t=e.renderOption(r)}n.appendChild(t)}),a.default.isFilterType()&&this.Events.createIndex(n),this.Events.select(this._render)}},{key:"renderSearch",value:function(){return void 0===a.default.filterTemplate&&a.default.createFilterElement(),a.default.filterTemplate.cloneNode(!0)}},{key:"renderGroup",value:function(e){var t=this,n=a.default.groupTemplate.cloneNode(!0);return n.dataset.group=n.children[0].innerText=e.label,e.disabled&&(n.dataset.disabled=!0),Array.from(e.children).forEach(function(e){n.appendChild(t.renderOption(e))}),n}},{key:"renderOption",value:function(e){var t=a.default.optionTemplate.cloneNode(!0);return Object.keys(e.dataset).forEach(function(n){t.dataset[n]=e.dataset[n]}),t.dataset.item=e.value,t.children[0].innerText=e.innerText,e.disabled&&(t.dataset.disabled=!0),e.selected&&(t.dataset.selected=!0),t}},{key:"renderSelected",value:function(){var e=this._render.querySelector(".selector-selected");this.Settings.label?e.children[0].innerText=this.Settings.label:this._element.dataset.label&&(e.children[0].innerText=this._element.dataset.label);var t=this._element.querySelector("[selected]");t?(e.dataset.item=t.value,e.children[0].innerText=t.innerText):(e.dataset.item=void 0,e.children[0].innerText="---")}},{key:"show",value:function(){var e=this.Settings.data;e.beforeCreate&&e.beforeCreate(),this._element.parentNode.insertBefore(this._render,this._element.nextSibling),e.created?e.created():e.callback&&e.callback()}}]),e}();t.default=d},function(e,t,n){"use strict";n(2),e.exports=n(10)}])});

/***/ })
/******/ ]);