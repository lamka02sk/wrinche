/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 89);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Closer = __webpack_require__(90);

var _Closer2 = _interopRequireDefault(_Closer);

var _jquery = __webpack_require__(2);

var _jquery2 = _interopRequireDefault(_jquery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var baseURI = '?route=';
var route = document.querySelector('meta[name=route]').getAttribute('content');

exports.default = {

    body: document.body,
    html: document.body.parentNode,
    $html: (0, _jquery2.default)('html'),
    nav: document.querySelector('nav'),
    anchorBox: (0, _jquery2.default)('div.anchor-hover'),

    baseURI: baseURI,
    route: route,
    URI: baseURI + route + '/',

    routePrefix: null,
    routeAction: null,

    translate: null,
    closer: new _Closer2.default(),
    router: null,
    packery: null,
    componentsModule: null

};

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _jquery = __webpack_require__(2);

var _jquery2 = _interopRequireDefault(_jquery);

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var confirmationElement = (0, _jquery2.default)('div.confirmation-menu');

exports.default = {
    pad: function (_pad) {
        function pad(_x, _x2) {
            return _pad.apply(this, arguments);
        }

        pad.toString = function () {
            return _pad.toString();
        };

        return pad;
    }(function (number, positions) {

        number = '' + number;
        return number.length < positions ? pad("0" + number, positions) : number;
    }),
    validateUrl: function validateUrl(url) {

        return (/[(http(s)?):\/\/(www.)?a-zA-Z0-9@:%._+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_+.~#?&//=]*)/.test(url)
        );
    },
    validateTags: function validateTags(tags) {

        if ((typeof tags === 'undefined' ? 'undefined' : _typeof(tags)) === 'object') if (tags.length === 0) return true;

        return (/^[a-zA-Z]([a-zA-Z0-9_\s,]+)?[a-zA-Z0-9]$/.test(tags) && tags !== ''
        );
    },
    triggerEvent: function triggerEvent(element, event) {

        element.dispatchEvent(new MouseEvent(event, {
            view: window,
            cancelable: true,
            bubbles: true
        }));
    },
    registerEvent: function registerEvent(event) {

        // [events, elements, function] || { event, elements, content() }

        event = Object.values(event);
        var eventsList = event[0].split(' ');

        eventsList.forEach(function (eventName) {
            if (!event[1].length) event[1].addEventListener(eventName, event[2]);else event[1].forEach(function (element) {
                element.addEventListener(eventName, event[2]);
            });
        });
    },
    registerEvents: function registerEvents(events) {

        events.forEach(this.registerEvent);
    },
    capitalizeFirst: function capitalizeFirst(string) {

        string = string.toString();
        return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
    },
    showValidationResults: function showValidationResults(element, locale, hide, callback) {

        callback = callback || function () {};
        var messageBox = element.parentNode.querySelector('.validate-message');

        if (hide === true) {

            if (messageBox.innerText === '') return true;

            messageBox.innerText = '';
            messageBox.removeAttribute('data-locale');

            callback();
            return true;
        }

        if (messageBox.getAttribute('data-locale') === locale) {

            callback();
            return true;
        }

        messageBox.setAttribute('data-locale', locale);
        var loopBreak = false;

        for (var i in _Global2.default.translate.locale) {

            for (var j in _Global2.default.translate.locale[i]) {

                if (j === locale) {

                    messageBox.innerText = _Global2.default.translate.locale[i][j];
                    loopBreak = true;

                    break;
                }
            }

            if (loopBreak) break;
        }

        callback();
    },


    _confirmationElement: confirmationElement,
    _confirmationMessage: confirmationElement.find('.confirmation-action-message'),
    _confirmationProceed: confirmationElement.find('.confirmation-action-proceed'),
    _confirmationDismiss: confirmationElement.find('.confirmation-action-dismiss'),

    confirmAction: function confirmAction(action, callback) {

        callback = callback || function () {};
        this._confirmationElement.css({ display: 'table' }).animate({ opacity: 1 }, 150).addClass('open');
        this._confirmationMessage.innerHTML = action;

        function clearEvents() {

            this._confirmationProceed.off('click');
            this._confirmationDismiss.off('click');
        }

        function hidePopup() {

            this._confirmationElement.animate({ opacity: 0 }, 150).removeClass('open').delay(100).queue(function () {
                (0, _jquery2.default)(this).css({ display: 'none' }).dequeue();
            });
        }

        // Proceed
        this._confirmationProceed.click(function () {

            callback();
            clearEvents();
            hidePopup();
        });

        // Dismiss
        this._confirmationDismiss.click(function () {

            clearEvents();
            hidePopup();
        });
    },


    _loadingBox: document.querySelector('.loading-box'),
    _responseBox: document.querySelector('.response-box'),

    showLoading: function showLoading() {
        var translate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;


        this._loadingBox.classList.add('open');

        if (translate) this._loadingBox.querySelector('span.message-content').innerHTML = _Global2.default.translate['locale']['admin_header']['HEADER_LOADING'];
    },
    hideLoading: function hideLoading() {
        var _this = this;

        setTimeout(function () {

            _this._loadingBox.classList.remove('open');
            _this._loadingBox.querySelector('span.message-content').innerHTML = '';
        }, 400);
    },
    hideSplash: function hideSplash() {
        document.querySelector('.splash').classList.add('done');
    }
};

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.2.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2017-03-20T18:59Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};



	function DOMEval( code, doc ) {
		doc = doc || document;

		var script = doc.createElement( "script" );

		script.text = code;
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.2.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && Array.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type( obj ) === "function";
	},

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {

		// As of jQuery 3.0, isNumeric is limited to
		// strings and numbers (primitives or objects)
		// that can be coerced to finite numbers (gh-2662)
		var type = jQuery.type( obj );
		return ( type === "number" || type === "string" ) &&

			// parseFloat NaNs numeric-cast false positives ("")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			!isNaN( obj - parseFloat( obj ) );
	},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {

		/* eslint-disable no-unused-vars */
		// See https://github.com/eslint/eslint/issues/6125
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}

		// Support: Android <=2.3 only (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call( obj ) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		DOMEval( code );
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE <=9 - 11, Edge 12 - 13
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	disabledAncestor = addCombinator(
		function( elem ) {
			return elem.disabled === true && ("form" in elem || "label" in elem);
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						disabledAncestor( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Simple selector that can be filtered directly, removing non-Elements
	if ( risSimple.test( qualifier ) ) {
		return jQuery.filter( qualifier, elements, not );
	}

	// Complex selector, compare the two sets, removing non-Elements
	qualifier = jQuery.filter( qualifier, elements );
	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) > -1 ) !== not && elem.nodeType === 1;
	} );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
        if ( nodeName( elem, "iframe" ) ) {
            return elem.contentDocument;
        }

        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
        // Treat the template element as a regular one in browsers that
        // don't support it.
        if ( nodeName( elem, "template" ) ) {
            elem = elem.content || elem;
        }

        return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( jQuery.isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && jQuery.isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && jQuery.isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = jQuery.isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( jQuery.isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								jQuery.isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				jQuery.isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ jQuery.camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ jQuery.camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ jQuery.camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( jQuery.camelCase );
			} else {
				key = jQuery.camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			jQuery.contains( elem.ownerDocument, elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted,
		scale = 1,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		do {

			// If previous iteration zeroed out, double until we get *something*.
			// Use string for doubling so we don't accidentally see scale as unchanged below
			scale = scale || ".5";

			// Adjust and apply
			initialInUnit = initialInUnit / scale;
			jQuery.style( elem, prop, initialInUnit + unit );

		// Update scale, tolerating zero or NaN from tween.cur()
		// Break the loop if scale is unchanged or perfect, or if we've just had enough.
		} while (
			scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
		);
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

var rscriptType = ( /^$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( jQuery.type( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();
var documentElement = document.documentElement;



var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 only
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: jQuery.isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( ">tbody", elem )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		isFunction = jQuery.isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( isFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( isFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rmargin = ( /^margin/ );

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		div.style.cssText =
			"box-sizing:border-box;" +
			"position:relative;display:block;" +
			"margin:auto;border:1px;padding:1px;" +
			"top:1%;width:50%";
		div.innerHTML = "";
		documentElement.appendChild( container );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = divStyle.marginLeft === "2px";
		boxSizingReliableVal = divStyle.width === "4px";

		// Support: Android 4.0 - 4.3 only
		// Some styles come back with percentage values, even though they shouldn't
		div.style.marginRight = "50%";
		pixelMarginRightVal = divStyle.marginRight === "4px";

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
		"padding:0;margin-top:1px;position:absolute";
	container.appendChild( div );

	jQuery.extend( support, {
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelMarginRight: function() {
			computeStyleTests();
			return pixelMarginRightVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a property mapped along what jQuery.cssProps suggests or to
// a vendor prefixed property.
function finalPropName( name ) {
	var ret = jQuery.cssProps[ name ];
	if ( !ret ) {
		ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
	}
	return ret;
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i,
		val = 0;

	// If we already have the right measurement, avoid augmentation
	if ( extra === ( isBorderBox ? "border" : "content" ) ) {
		i = 4;

	// Otherwise initialize for horizontal or vertical properties
	} else {
		i = name === "width" ? 1 : 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {

			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {

			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with computed style
	var valueIsBorderBox,
		styles = getStyles( elem ),
		val = curCSS( elem, name, styles ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Computed unit is not pixels. Stop here and return.
	if ( rnumnonpx.test( val ) ) {
		return val;
	}

	// Check for style in case a browser which returns unreliable values
	// for getComputedStyle silently falls back to the reliable elem.style
	valueIsBorderBox = isBorderBox &&
		( support.boxSizingReliable() || val === elem.style[ name ] );

	// Fall back to offsetWidth/Height when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	if ( val === "auto" ) {
		val = elem[ "offset" + name[ 0 ].toUpperCase() + name.slice( 1 ) ];
	}

	// Normalize "", auto, and prepare for extra
	val = parseFloat( val ) || 0;

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, name, extra );
						} ) :
						getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = extra && getStyles( elem ),
				subtract = extra && augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				);

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ name ] = value;
				value = jQuery.css( elem, name );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 13
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( jQuery.isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					jQuery.proxy( result.stop, result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnothtmlwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnothtmlwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( type === "string" ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = value.match( rnothtmlwhite ) || [];

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




support.focusin = "onfocusin" in window;


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = jQuery.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = jQuery.isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( jQuery.isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 13
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( jQuery.isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var doc, docElem, rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		rect = elem.getBoundingClientRect();

		doc = elem.ownerDocument;
		docElem = doc.documentElement;
		win = doc.defaultView;

		return {
			top: rect.top + win.pageYOffset - docElem.clientTop,
			left: rect.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
		// because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {

			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset = {
				top: parentOffset.top + jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ),
				left: parentOffset.left + jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true )
			};
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( jQuery.isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
		return jQuery;
	}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Ajax = __webpack_require__(4);

var _Ajax2 = _interopRequireDefault(_Ajax);

var _Router = __webpack_require__(8);

var _Router2 = _interopRequireDefault(_Router);

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {

    viewHTML: null,
    LOCALES: [],

    createView: function createView() {
        var _this = this;

        var locales = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];


        return new Promise(function (resolve) {

            _this.LOCALES = locales;
            _this.fetchViewHTML(resolve);
        });
    },
    fetchViewHTML: function fetchViewHTML(resolve) {
        var _this2 = this;

        var url = _Router2.default.createLink(_Global2.default.routeAction.join('/'));

        _Ajax2.default.get(url, function (response) {
            _this2.viewHTML = response;
            _this2.replaceViewHTML(_this2);
            resolve();
        }, function (response) {
            // Handle error event
            resolve();
        });
    },
    replaceViewHTML: function replaceViewHTML(parent) {

        var contentWrapper = document.querySelector('.content-wrapper');

        contentWrapper ? parent.showView(contentWrapper) : parent.createContentWrapper(true);
    },
    createContentWrapper: function createContentWrapper() {
        var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;


        var contentWrapper = document.createElement('div');
        contentWrapper.classList.add('content-wrapper');

        _Global2.default.body.appendChild(contentWrapper);

        if (show) this.showView(contentWrapper);
    },
    showView: function showView(contentWrapper) {

        contentWrapper.innerHTML = this.viewHTML;
        this.translate();
    },
    translate: function translate() {

        _Global2.default.translate.translateLocales(this.LOCALES);
    }
};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _jquery = __webpack_require__(2);

var _jquery2 = _interopRequireDefault(_jquery);

var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

var _Csrf = __webpack_require__(7);

var _Csrf2 = _interopRequireDefault(_Csrf);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
    post: function post(url, data, callback) {

        _Utils2.default.showLoading();
        data['csrf_token'] = _Csrf2.default.getToken();

        _jquery2.default.ajax({
            url: url,
            method: 'POST',
            data: data,
            success: function success(response) {
                callback(response, 'success');
                _Utils2.default.hideLoading();
            },
            error: function error(response) {
                callback(response, 'error');
                _Utils2.default.hideLoading();
            }
        });
    },
    get: function get(url, _success, _error) {

        _Utils2.default.showLoading();
        var csrf_token = _Csrf2.default.getToken();

        _jquery2.default.ajax({
            url: url + '&csrf_token=' + csrf_token,
            method: 'GET',
            success: function success(response) {
                _success(response);
                _Utils2.default.hideLoading();
            },
            error: function error(response) {
                _error(response);
                _Utils2.default.hideLoading();
            }
        });
    },
    getFile: function getFile(url) {
        var translate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;


        _Utils2.default.showLoading(translate);

        return _jquery2.default.ajax({
            type: 'GET',
            url: url,
            global: false,
            async: false,
            cache: true,
            success: function success(data) {
                _Utils2.default.hideLoading();
                return data;
            },
            error: function error() {
                return _Utils2.default.hideLoading();
            }
        }).responseText;
    },
    getJSON: function getJSON(url) {
        var translate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;


        _Utils2.default.showLoading(translate);

        return JSON.parse(_jquery2.default.ajax({
            type: 'GET',
            url: url,
            dataType: 'json',
            global: false,
            async: false,
            cache: true,
            success: function success(data) {
                _Utils2.default.hideLoading();
                return data;
            },
            error: function error() {
                return _Utils2.default.hideLoading();
            }
        }).responseText);
    }
};

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * getSize v2.0.2
 * measure size of elements
 * MIT license
 */

/*jshint browser: true, strict: true, undef: true, unused: true */
/*global define: false, module: false, console: false */

( function( window, factory ) {
  'use strict';

  if ( true ) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
      return factory();
    }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS
    module.exports = factory();
  } else {
    // browser global
    window.getSize = factory();
  }

})( window, function factory() {
'use strict';

// -------------------------- helpers -------------------------- //

// get a number from a string, not a percentage
function getStyleSize( value ) {
  var num = parseFloat( value );
  // not a percent like '100%', and a number
  var isValid = value.indexOf('%') == -1 && !isNaN( num );
  return isValid && num;
}

function noop() {}

var logError = typeof console == 'undefined' ? noop :
  function( message ) {
    console.error( message );
  };

// -------------------------- measurements -------------------------- //

var measurements = [
  'paddingLeft',
  'paddingRight',
  'paddingTop',
  'paddingBottom',
  'marginLeft',
  'marginRight',
  'marginTop',
  'marginBottom',
  'borderLeftWidth',
  'borderRightWidth',
  'borderTopWidth',
  'borderBottomWidth'
];

var measurementsLength = measurements.length;

function getZeroSize() {
  var size = {
    width: 0,
    height: 0,
    innerWidth: 0,
    innerHeight: 0,
    outerWidth: 0,
    outerHeight: 0
  };
  for ( var i=0; i < measurementsLength; i++ ) {
    var measurement = measurements[i];
    size[ measurement ] = 0;
  }
  return size;
}

// -------------------------- getStyle -------------------------- //

/**
 * getStyle, get style of element, check for Firefox bug
 * https://bugzilla.mozilla.org/show_bug.cgi?id=548397
 */
function getStyle( elem ) {
  var style = getComputedStyle( elem );
  if ( !style ) {
    logError( 'Style returned ' + style +
      '. Are you running this code in a hidden iframe on Firefox? ' +
      'See http://bit.ly/getsizebug1' );
  }
  return style;
}

// -------------------------- setup -------------------------- //

var isSetup = false;

var isBoxSizeOuter;

/**
 * setup
 * check isBoxSizerOuter
 * do on first getSize() rather than on page load for Firefox bug
 */
function setup() {
  // setup once
  if ( isSetup ) {
    return;
  }
  isSetup = true;

  // -------------------------- box sizing -------------------------- //

  /**
   * WebKit measures the outer-width on style.width on border-box elems
   * IE & Firefox<29 measures the inner-width
   */
  var div = document.createElement('div');
  div.style.width = '200px';
  div.style.padding = '1px 2px 3px 4px';
  div.style.borderStyle = 'solid';
  div.style.borderWidth = '1px 2px 3px 4px';
  div.style.boxSizing = 'border-box';

  var body = document.body || document.documentElement;
  body.appendChild( div );
  var style = getStyle( div );

  getSize.isBoxSizeOuter = isBoxSizeOuter = getStyleSize( style.width ) == 200;
  body.removeChild( div );

}

// -------------------------- getSize -------------------------- //

function getSize( elem ) {
  setup();

  // use querySeletor if elem is string
  if ( typeof elem == 'string' ) {
    elem = document.querySelector( elem );
  }

  // do not proceed on non-objects
  if ( !elem || typeof elem != 'object' || !elem.nodeType ) {
    return;
  }

  var style = getStyle( elem );

  // if hidden, everything is 0
  if ( style.display == 'none' ) {
    return getZeroSize();
  }

  var size = {};
  size.width = elem.offsetWidth;
  size.height = elem.offsetHeight;

  var isBorderBox = size.isBorderBox = style.boxSizing == 'border-box';

  // get all measurements
  for ( var i=0; i < measurementsLength; i++ ) {
    var measurement = measurements[i];
    var value = style[ measurement ];
    var num = parseFloat( value );
    // any 'auto', 'medium' value will be 0
    size[ measurement ] = !isNaN( num ) ? num : 0;
  }

  var paddingWidth = size.paddingLeft + size.paddingRight;
  var paddingHeight = size.paddingTop + size.paddingBottom;
  var marginWidth = size.marginLeft + size.marginRight;
  var marginHeight = size.marginTop + size.marginBottom;
  var borderWidth = size.borderLeftWidth + size.borderRightWidth;
  var borderHeight = size.borderTopWidth + size.borderBottomWidth;

  var isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter;

  // overwrite width and height if we can get it from style
  var styleWidth = getStyleSize( style.width );
  if ( styleWidth !== false ) {
    size.width = styleWidth +
      // add padding and border unless it's already including it
      ( isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth );
  }

  var styleHeight = getStyleSize( style.height );
  if ( styleHeight !== false ) {
    size.height = styleHeight +
      // add padding and border unless it's already including it
      ( isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight );
  }

  size.innerWidth = size.width - ( paddingWidth + borderWidth );
  size.innerHeight = size.height - ( paddingHeight + borderHeight );

  size.outerWidth = size.width + marginWidth;
  size.outerHeight = size.height + marginHeight;

  return size;
}

return getSize;

});


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * Rect
 * low-level utility class for basic geometry
 */

( function( window, factory ) {
  // universal module definition
  /* jshint strict: false */ /* globals define, module */
  if ( true ) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS
    module.exports = factory();
  } else {
    // browser global
    window.Packery = window.Packery || {};
    window.Packery.Rect = factory();
  }

}( window, function factory() {
'use strict';

// -------------------------- Rect -------------------------- //

function Rect( props ) {
  // extend properties from defaults
  for ( var prop in Rect.defaults ) {
    this[ prop ] = Rect.defaults[ prop ];
  }

  for ( prop in props ) {
    this[ prop ] = props[ prop ];
  }

}

Rect.defaults = {
  x: 0,
  y: 0,
  width: 0,
  height: 0
};

var proto = Rect.prototype;

/**
 * Determines whether or not this rectangle wholly encloses another rectangle or point.
 * @param {Rect} rect
 * @returns {Boolean}
**/
proto.contains = function( rect ) {
  // points don't have width or height
  var otherWidth = rect.width || 0;
  var otherHeight = rect.height || 0;
  return this.x <= rect.x &&
    this.y <= rect.y &&
    this.x + this.width >= rect.x + otherWidth &&
    this.y + this.height >= rect.y + otherHeight;
};

/**
 * Determines whether or not the rectangle intersects with another.
 * @param {Rect} rect
 * @returns {Boolean}
**/
proto.overlaps = function( rect ) {
  var thisRight = this.x + this.width;
  var thisBottom = this.y + this.height;
  var rectRight = rect.x + rect.width;
  var rectBottom = rect.y + rect.height;

  // http://stackoverflow.com/a/306332
  return this.x < rectRight &&
    thisRight > rect.x &&
    this.y < rectBottom &&
    thisBottom > rect.y;
};

/**
 * @param {Rect} rect - the overlapping rect
 * @returns {Array} freeRects - rects representing the area around the rect
**/
proto.getMaximalFreeRects = function( rect ) {

  // if no intersection, return false
  if ( !this.overlaps( rect ) ) {
    return false;
  }

  var freeRects = [];
  var freeRect;

  var thisRight = this.x + this.width;
  var thisBottom = this.y + this.height;
  var rectRight = rect.x + rect.width;
  var rectBottom = rect.y + rect.height;

  // top
  if ( this.y < rect.y ) {
    freeRect = new Rect({
      x: this.x,
      y: this.y,
      width: this.width,
      height: rect.y - this.y
    });
    freeRects.push( freeRect );
  }

  // right
  if ( thisRight > rectRight ) {
    freeRect = new Rect({
      x: rectRight,
      y: this.y,
      width: thisRight - rectRight,
      height: this.height
    });
    freeRects.push( freeRect );
  }

  // bottom
  if ( thisBottom > rectBottom ) {
    freeRect = new Rect({
      x: this.x,
      y: rectBottom,
      width: this.width,
      height: thisBottom - rectBottom
    });
    freeRects.push( freeRect );
  }

  // left
  if ( this.x < rect.x ) {
    freeRect = new Rect({
      x: this.x,
      y: this.y,
      width: rect.x - this.x,
      height: this.height
    });
    freeRects.push( freeRect );
  }

  return freeRects;
};

proto.canFit = function( rect ) {
  return this.width >= rect.width && this.height >= rect.height;
};

return Rect;

}));


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Ajax = __webpack_require__(4);

var _Ajax2 = _interopRequireDefault(_Ajax);

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var tokenElement = document.querySelector('meta[name=csrf_token]');

exports.default = {

    _tokenElement: tokenElement,
    _csrfToken: undefined,

    constructor: function constructor() {

        this._csrfToken = this._tokenElement.getAttribute('content');
        this.register();
    },
    register: function register() {
        var _this = this;

        setInterval(function () {

            _Ajax2.default.get(_Global2.default.baseURI + 'api/system.auth.refresh.token', function (response) {
                _this._csrfToken = response.data;
                _this._tokenElement.setAttribute('content', _this._csrfToken);
            }, function () {
                confirmAction(
                // TODO: translate.locale.response['ACTION_CONFIRM_RELOAD_PAGE'],
                '', function () {
                    return window.location.reload();
                });
            });
        }, 1200000);
    },
    getToken: function getToken() {

        return this._csrfToken;
    }
};

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

var _History = __webpack_require__(92);

var _History2 = _interopRequireDefault(_History);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var routes = __webpack_require__(93);

var _class = function () {
    function _class() {
        _classCallCheck(this, _class);

        this.route = _Global2.default.route;
        this.parseLocation();
        this.views = {};

        _History2.default.initialize(this);
        this.findRoute();
    }

    _createClass(_class, [{
        key: 'saveActions',
        value: function saveActions(action) {

            var actions = action.toString().split('/').filter(function (item) {
                if (item.trim() !== '') return item.trim();
            });

            if (actions.length < 1) actions.push('dashboard');

            _Global2.default.routeAction = actions;
        }
    }, {
        key: 'changeLocation',
        value: function changeLocation(link) {
            var push = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;


            this.saveActions(link);
            this.findRoute(push);
        }
    }, {
        key: 'parseLocation',
        value: function parseLocation() {

            var location = window.location.href;
            var locationParts = location.split(this.route);

            _Global2.default.routePrefix = locationParts[0];
            var action = locationParts[1];

            this.saveActions(action);
        }
    }, {
        key: 'findRoute',
        value: function findRoute() {
            var push = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;


            if (!routes[_Global2.default.routeAction[0]]) {
                this.changeLocation(404);
                return false;
            }

            if (push) _History2.default.push(_Global2.default.routeAction);

            this.executeRoute();
        }
    }, {
        key: 'executeRoute',
        value: function executeRoute() {

            var View = __webpack_require__(94)("./" + routes[_Global2.default.routeAction[0]] + '.js').default;
            View.initialize(this);
        }
    }], [{
        key: 'getHash',
        value: function getHash() {
            return window.location.hash;
        }
    }, {
        key: 'createLink',
        value: function createLink(action) {
            var route = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;


            route = route ? '/' + route : _Global2.default.route;
            return _Global2.default.routePrefix + route + '/' + action;
        }
    }]);

    return _class;
}();

exports.default = _class;
;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * Outlayer v2.1.1
 * the brains and guts of a layout library
 * MIT license
 */

( function( window, factory ) {
  'use strict';
  // universal module definition
  /* jshint strict: false */ /* globals define, module, require */
  if ( true ) {
    // AMD - RequireJS
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(10),
        __webpack_require__(5),
        __webpack_require__(101),
        __webpack_require__(103)
      ], __WEBPACK_AMD_DEFINE_RESULT__ = function( EvEmitter, getSize, utils, Item ) {
        return factory( window, EvEmitter, getSize, utils, Item);
      }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS - Browserify, Webpack
    module.exports = factory(
      window,
      require('ev-emitter'),
      require('get-size'),
      require('fizzy-ui-utils'),
      require('./item')
    );
  } else {
    // browser global
    window.Outlayer = factory(
      window,
      window.EvEmitter,
      window.getSize,
      window.fizzyUIUtils,
      window.Outlayer.Item
    );
  }

}( window, function factory( window, EvEmitter, getSize, utils, Item ) {
'use strict';

// ----- vars ----- //

var console = window.console;
var jQuery = window.jQuery;
var noop = function() {};

// -------------------------- Outlayer -------------------------- //

// globally unique identifiers
var GUID = 0;
// internal store of all Outlayer intances
var instances = {};


/**
 * @param {Element, String} element
 * @param {Object} options
 * @constructor
 */
function Outlayer( element, options ) {
  var queryElement = utils.getQueryElement( element );
  if ( !queryElement ) {
    if ( console ) {
      console.error( 'Bad element for ' + this.constructor.namespace +
        ': ' + ( queryElement || element ) );
    }
    return;
  }
  this.element = queryElement;
  // add jQuery
  if ( jQuery ) {
    this.$element = jQuery( this.element );
  }

  // options
  this.options = utils.extend( {}, this.constructor.defaults );
  this.option( options );

  // add id for Outlayer.getFromElement
  var id = ++GUID;
  this.element.outlayerGUID = id; // expando
  instances[ id ] = this; // associate via id

  // kick it off
  this._create();

  var isInitLayout = this._getOption('initLayout');
  if ( isInitLayout ) {
    this.layout();
  }
}

// settings are for internal use only
Outlayer.namespace = 'outlayer';
Outlayer.Item = Item;

// default options
Outlayer.defaults = {
  containerStyle: {
    position: 'relative'
  },
  initLayout: true,
  originLeft: true,
  originTop: true,
  resize: true,
  resizeContainer: true,
  // item options
  transitionDuration: '0.4s',
  hiddenStyle: {
    opacity: 0,
    transform: 'scale(0.001)'
  },
  visibleStyle: {
    opacity: 1,
    transform: 'scale(1)'
  }
};

var proto = Outlayer.prototype;
// inherit EvEmitter
utils.extend( proto, EvEmitter.prototype );

/**
 * set options
 * @param {Object} opts
 */
proto.option = function( opts ) {
  utils.extend( this.options, opts );
};

/**
 * get backwards compatible option value, check old name
 */
proto._getOption = function( option ) {
  var oldOption = this.constructor.compatOptions[ option ];
  return oldOption && this.options[ oldOption ] !== undefined ?
    this.options[ oldOption ] : this.options[ option ];
};

Outlayer.compatOptions = {
  // currentName: oldName
  initLayout: 'isInitLayout',
  horizontal: 'isHorizontal',
  layoutInstant: 'isLayoutInstant',
  originLeft: 'isOriginLeft',
  originTop: 'isOriginTop',
  resize: 'isResizeBound',
  resizeContainer: 'isResizingContainer'
};

proto._create = function() {
  // get items from children
  this.reloadItems();
  // elements that affect layout, but are not laid out
  this.stamps = [];
  this.stamp( this.options.stamp );
  // set container style
  utils.extend( this.element.style, this.options.containerStyle );

  // bind resize method
  var canBindResize = this._getOption('resize');
  if ( canBindResize ) {
    this.bindResize();
  }
};

// goes through all children again and gets bricks in proper order
proto.reloadItems = function() {
  // collection of item elements
  this.items = this._itemize( this.element.children );
};


/**
 * turn elements into Outlayer.Items to be used in layout
 * @param {Array or NodeList or HTMLElement} elems
 * @returns {Array} items - collection of new Outlayer Items
 */
proto._itemize = function( elems ) {

  var itemElems = this._filterFindItemElements( elems );
  var Item = this.constructor.Item;

  // create new Outlayer Items for collection
  var items = [];
  for ( var i=0; i < itemElems.length; i++ ) {
    var elem = itemElems[i];
    var item = new Item( elem, this );
    items.push( item );
  }

  return items;
};

/**
 * get item elements to be used in layout
 * @param {Array or NodeList or HTMLElement} elems
 * @returns {Array} items - item elements
 */
proto._filterFindItemElements = function( elems ) {
  return utils.filterFindElements( elems, this.options.itemSelector );
};

/**
 * getter method for getting item elements
 * @returns {Array} elems - collection of item elements
 */
proto.getItemElements = function() {
  return this.items.map( function( item ) {
    return item.element;
  });
};

// ----- init & layout ----- //

/**
 * lays out all items
 */
proto.layout = function() {
  this._resetLayout();
  this._manageStamps();

  // don't animate first layout
  var layoutInstant = this._getOption('layoutInstant');
  var isInstant = layoutInstant !== undefined ?
    layoutInstant : !this._isLayoutInited;
  this.layoutItems( this.items, isInstant );

  // flag for initalized
  this._isLayoutInited = true;
};

// _init is alias for layout
proto._init = proto.layout;

/**
 * logic before any new layout
 */
proto._resetLayout = function() {
  this.getSize();
};


proto.getSize = function() {
  this.size = getSize( this.element );
};

/**
 * get measurement from option, for columnWidth, rowHeight, gutter
 * if option is String -> get element from selector string, & get size of element
 * if option is Element -> get size of element
 * else use option as a number
 *
 * @param {String} measurement
 * @param {String} size - width or height
 * @private
 */
proto._getMeasurement = function( measurement, size ) {
  var option = this.options[ measurement ];
  var elem;
  if ( !option ) {
    // default to 0
    this[ measurement ] = 0;
  } else {
    // use option as an element
    if ( typeof option == 'string' ) {
      elem = this.element.querySelector( option );
    } else if ( option instanceof HTMLElement ) {
      elem = option;
    }
    // use size of element, if element
    this[ measurement ] = elem ? getSize( elem )[ size ] : option;
  }
};

/**
 * layout a collection of item elements
 * @api public
 */
proto.layoutItems = function( items, isInstant ) {
  items = this._getItemsForLayout( items );

  this._layoutItems( items, isInstant );

  this._postLayout();
};

/**
 * get the items to be laid out
 * you may want to skip over some items
 * @param {Array} items
 * @returns {Array} items
 */
proto._getItemsForLayout = function( items ) {
  return items.filter( function( item ) {
    return !item.isIgnored;
  });
};

/**
 * layout items
 * @param {Array} items
 * @param {Boolean} isInstant
 */
proto._layoutItems = function( items, isInstant ) {
  this._emitCompleteOnItems( 'layout', items );

  if ( !items || !items.length ) {
    // no items, emit event with empty array
    return;
  }

  var queue = [];

  items.forEach( function( item ) {
    // get x/y object from method
    var position = this._getItemLayoutPosition( item );
    // enqueue
    position.item = item;
    position.isInstant = isInstant || item.isLayoutInstant;
    queue.push( position );
  }, this );

  this._processLayoutQueue( queue );
};

/**
 * get item layout position
 * @param {Outlayer.Item} item
 * @returns {Object} x and y position
 */
proto._getItemLayoutPosition = function( /* item */ ) {
  return {
    x: 0,
    y: 0
  };
};

/**
 * iterate over array and position each item
 * Reason being - separating this logic prevents 'layout invalidation'
 * thx @paul_irish
 * @param {Array} queue
 */
proto._processLayoutQueue = function( queue ) {
  this.updateStagger();
  queue.forEach( function( obj, i ) {
    this._positionItem( obj.item, obj.x, obj.y, obj.isInstant, i );
  }, this );
};

// set stagger from option in milliseconds number
proto.updateStagger = function() {
  var stagger = this.options.stagger;
  if ( stagger === null || stagger === undefined ) {
    this.stagger = 0;
    return;
  }
  this.stagger = getMilliseconds( stagger );
  return this.stagger;
};

/**
 * Sets position of item in DOM
 * @param {Outlayer.Item} item
 * @param {Number} x - horizontal position
 * @param {Number} y - vertical position
 * @param {Boolean} isInstant - disables transitions
 */
proto._positionItem = function( item, x, y, isInstant, i ) {
  if ( isInstant ) {
    // if not transition, just set CSS
    item.goTo( x, y );
  } else {
    item.stagger( i * this.stagger );
    item.moveTo( x, y );
  }
};

/**
 * Any logic you want to do after each layout,
 * i.e. size the container
 */
proto._postLayout = function() {
  this.resizeContainer();
};

proto.resizeContainer = function() {
  var isResizingContainer = this._getOption('resizeContainer');
  if ( !isResizingContainer ) {
    return;
  }
  var size = this._getContainerSize();
  if ( size ) {
    this._setContainerMeasure( size.width, true );
    this._setContainerMeasure( size.height, false );
  }
};

/**
 * Sets width or height of container if returned
 * @returns {Object} size
 *   @param {Number} width
 *   @param {Number} height
 */
proto._getContainerSize = noop;

/**
 * @param {Number} measure - size of width or height
 * @param {Boolean} isWidth
 */
proto._setContainerMeasure = function( measure, isWidth ) {
  if ( measure === undefined ) {
    return;
  }

  var elemSize = this.size;
  // add padding and border width if border box
  if ( elemSize.isBorderBox ) {
    measure += isWidth ? elemSize.paddingLeft + elemSize.paddingRight +
      elemSize.borderLeftWidth + elemSize.borderRightWidth :
      elemSize.paddingBottom + elemSize.paddingTop +
      elemSize.borderTopWidth + elemSize.borderBottomWidth;
  }

  measure = Math.max( measure, 0 );
  this.element.style[ isWidth ? 'width' : 'height' ] = measure + 'px';
};

/**
 * emit eventComplete on a collection of items events
 * @param {String} eventName
 * @param {Array} items - Outlayer.Items
 */
proto._emitCompleteOnItems = function( eventName, items ) {
  var _this = this;
  function onComplete() {
    _this.dispatchEvent( eventName + 'Complete', null, [ items ] );
  }

  var count = items.length;
  if ( !items || !count ) {
    onComplete();
    return;
  }

  var doneCount = 0;
  function tick() {
    doneCount++;
    if ( doneCount == count ) {
      onComplete();
    }
  }

  // bind callback
  items.forEach( function( item ) {
    item.once( eventName, tick );
  });
};

/**
 * emits events via EvEmitter and jQuery events
 * @param {String} type - name of event
 * @param {Event} event - original event
 * @param {Array} args - extra arguments
 */
proto.dispatchEvent = function( type, event, args ) {
  // add original event to arguments
  var emitArgs = event ? [ event ].concat( args ) : args;
  this.emitEvent( type, emitArgs );

  if ( jQuery ) {
    // set this.$element
    this.$element = this.$element || jQuery( this.element );
    if ( event ) {
      // create jQuery event
      var $event = jQuery.Event( event );
      $event.type = type;
      this.$element.trigger( $event, args );
    } else {
      // just trigger with type if no event available
      this.$element.trigger( type, args );
    }
  }
};

// -------------------------- ignore & stamps -------------------------- //


/**
 * keep item in collection, but do not lay it out
 * ignored items do not get skipped in layout
 * @param {Element} elem
 */
proto.ignore = function( elem ) {
  var item = this.getItem( elem );
  if ( item ) {
    item.isIgnored = true;
  }
};

/**
 * return item to layout collection
 * @param {Element} elem
 */
proto.unignore = function( elem ) {
  var item = this.getItem( elem );
  if ( item ) {
    delete item.isIgnored;
  }
};

/**
 * adds elements to stamps
 * @param {NodeList, Array, Element, or String} elems
 */
proto.stamp = function( elems ) {
  elems = this._find( elems );
  if ( !elems ) {
    return;
  }

  this.stamps = this.stamps.concat( elems );
  // ignore
  elems.forEach( this.ignore, this );
};

/**
 * removes elements to stamps
 * @param {NodeList, Array, or Element} elems
 */
proto.unstamp = function( elems ) {
  elems = this._find( elems );
  if ( !elems ){
    return;
  }

  elems.forEach( function( elem ) {
    // filter out removed stamp elements
    utils.removeFrom( this.stamps, elem );
    this.unignore( elem );
  }, this );
};

/**
 * finds child elements
 * @param {NodeList, Array, Element, or String} elems
 * @returns {Array} elems
 */
proto._find = function( elems ) {
  if ( !elems ) {
    return;
  }
  // if string, use argument as selector string
  if ( typeof elems == 'string' ) {
    elems = this.element.querySelectorAll( elems );
  }
  elems = utils.makeArray( elems );
  return elems;
};

proto._manageStamps = function() {
  if ( !this.stamps || !this.stamps.length ) {
    return;
  }

  this._getBoundingRect();

  this.stamps.forEach( this._manageStamp, this );
};

// update boundingLeft / Top
proto._getBoundingRect = function() {
  // get bounding rect for container element
  var boundingRect = this.element.getBoundingClientRect();
  var size = this.size;
  this._boundingRect = {
    left: boundingRect.left + size.paddingLeft + size.borderLeftWidth,
    top: boundingRect.top + size.paddingTop + size.borderTopWidth,
    right: boundingRect.right - ( size.paddingRight + size.borderRightWidth ),
    bottom: boundingRect.bottom - ( size.paddingBottom + size.borderBottomWidth )
  };
};

/**
 * @param {Element} stamp
**/
proto._manageStamp = noop;

/**
 * get x/y position of element relative to container element
 * @param {Element} elem
 * @returns {Object} offset - has left, top, right, bottom
 */
proto._getElementOffset = function( elem ) {
  var boundingRect = elem.getBoundingClientRect();
  var thisRect = this._boundingRect;
  var size = getSize( elem );
  var offset = {
    left: boundingRect.left - thisRect.left - size.marginLeft,
    top: boundingRect.top - thisRect.top - size.marginTop,
    right: thisRect.right - boundingRect.right - size.marginRight,
    bottom: thisRect.bottom - boundingRect.bottom - size.marginBottom
  };
  return offset;
};

// -------------------------- resize -------------------------- //

// enable event handlers for listeners
// i.e. resize -> onresize
proto.handleEvent = utils.handleEvent;

/**
 * Bind layout to window resizing
 */
proto.bindResize = function() {
  window.addEventListener( 'resize', this );
  this.isResizeBound = true;
};

/**
 * Unbind layout to window resizing
 */
proto.unbindResize = function() {
  window.removeEventListener( 'resize', this );
  this.isResizeBound = false;
};

proto.onresize = function() {
  this.resize();
};

utils.debounceMethod( Outlayer, 'onresize', 100 );

proto.resize = function() {
  // don't trigger if size did not change
  // or if resize was unbound. See #9
  if ( !this.isResizeBound || !this.needsResizeLayout() ) {
    return;
  }

  this.layout();
};

/**
 * check if layout is needed post layout
 * @returns Boolean
 */
proto.needsResizeLayout = function() {
  var size = getSize( this.element );
  // check that this.size and size are there
  // IE8 triggers resize on body size change, so they might not be
  var hasSizes = this.size && size;
  return hasSizes && size.innerWidth !== this.size.innerWidth;
};

// -------------------------- methods -------------------------- //

/**
 * add items to Outlayer instance
 * @param {Array or NodeList or Element} elems
 * @returns {Array} items - Outlayer.Items
**/
proto.addItems = function( elems ) {
  var items = this._itemize( elems );
  // add items to collection
  if ( items.length ) {
    this.items = this.items.concat( items );
  }
  return items;
};

/**
 * Layout newly-appended item elements
 * @param {Array or NodeList or Element} elems
 */
proto.appended = function( elems ) {
  var items = this.addItems( elems );
  if ( !items.length ) {
    return;
  }
  // layout and reveal just the new items
  this.layoutItems( items, true );
  this.reveal( items );
};

/**
 * Layout prepended elements
 * @param {Array or NodeList or Element} elems
 */
proto.prepended = function( elems ) {
  var items = this._itemize( elems );
  if ( !items.length ) {
    return;
  }
  // add items to beginning of collection
  var previousItems = this.items.slice(0);
  this.items = items.concat( previousItems );
  // start new layout
  this._resetLayout();
  this._manageStamps();
  // layout new stuff without transition
  this.layoutItems( items, true );
  this.reveal( items );
  // layout previous items
  this.layoutItems( previousItems );
};

/**
 * reveal a collection of items
 * @param {Array of Outlayer.Items} items
 */
proto.reveal = function( items ) {
  this._emitCompleteOnItems( 'reveal', items );
  if ( !items || !items.length ) {
    return;
  }
  var stagger = this.updateStagger();
  items.forEach( function( item, i ) {
    item.stagger( i * stagger );
    item.reveal();
  });
};

/**
 * hide a collection of items
 * @param {Array of Outlayer.Items} items
 */
proto.hide = function( items ) {
  this._emitCompleteOnItems( 'hide', items );
  if ( !items || !items.length ) {
    return;
  }
  var stagger = this.updateStagger();
  items.forEach( function( item, i ) {
    item.stagger( i * stagger );
    item.hide();
  });
};

/**
 * reveal item elements
 * @param {Array}, {Element}, {NodeList} items
 */
proto.revealItemElements = function( elems ) {
  var items = this.getItems( elems );
  this.reveal( items );
};

/**
 * hide item elements
 * @param {Array}, {Element}, {NodeList} items
 */
proto.hideItemElements = function( elems ) {
  var items = this.getItems( elems );
  this.hide( items );
};

/**
 * get Outlayer.Item, given an Element
 * @param {Element} elem
 * @param {Function} callback
 * @returns {Outlayer.Item} item
 */
proto.getItem = function( elem ) {
  // loop through items to get the one that matches
  for ( var i=0; i < this.items.length; i++ ) {
    var item = this.items[i];
    if ( item.element == elem ) {
      // return item
      return item;
    }
  }
};

/**
 * get collection of Outlayer.Items, given Elements
 * @param {Array} elems
 * @returns {Array} items - Outlayer.Items
 */
proto.getItems = function( elems ) {
  elems = utils.makeArray( elems );
  var items = [];
  elems.forEach( function( elem ) {
    var item = this.getItem( elem );
    if ( item ) {
      items.push( item );
    }
  }, this );

  return items;
};

/**
 * remove element(s) from instance and DOM
 * @param {Array or NodeList or Element} elems
 */
proto.remove = function( elems ) {
  var removeItems = this.getItems( elems );

  this._emitCompleteOnItems( 'remove', removeItems );

  // bail if no items to remove
  if ( !removeItems || !removeItems.length ) {
    return;
  }

  removeItems.forEach( function( item ) {
    item.remove();
    // remove item from collection
    utils.removeFrom( this.items, item );
  }, this );
};

// ----- destroy ----- //

// remove and disable Outlayer instance
proto.destroy = function() {
  // clean up dynamic styles
  var style = this.element.style;
  style.height = '';
  style.position = '';
  style.width = '';
  // destroy items
  this.items.forEach( function( item ) {
    item.destroy();
  });

  this.unbindResize();

  var id = this.element.outlayerGUID;
  delete instances[ id ]; // remove reference to instance by id
  delete this.element.outlayerGUID;
  // remove data for jQuery
  if ( jQuery ) {
    jQuery.removeData( this.element, this.constructor.namespace );
  }

};

// -------------------------- data -------------------------- //

/**
 * get Outlayer instance from element
 * @param {Element} elem
 * @returns {Outlayer}
 */
Outlayer.data = function( elem ) {
  elem = utils.getQueryElement( elem );
  var id = elem && elem.outlayerGUID;
  return id && instances[ id ];
};


// -------------------------- create Outlayer class -------------------------- //

/**
 * create a layout class
 * @param {String} namespace
 */
Outlayer.create = function( namespace, options ) {
  // sub-class Outlayer
  var Layout = subclass( Outlayer );
  // apply new options and compatOptions
  Layout.defaults = utils.extend( {}, Outlayer.defaults );
  utils.extend( Layout.defaults, options );
  Layout.compatOptions = utils.extend( {}, Outlayer.compatOptions  );

  Layout.namespace = namespace;

  Layout.data = Outlayer.data;

  // sub-class Item
  Layout.Item = subclass( Item );

  // -------------------------- declarative -------------------------- //

  utils.htmlInit( Layout, namespace );

  // -------------------------- jQuery bridge -------------------------- //

  // make into jQuery plugin
  if ( jQuery && jQuery.bridget ) {
    jQuery.bridget( namespace, Layout );
  }

  return Layout;
};

function subclass( Parent ) {
  function SubClass() {
    Parent.apply( this, arguments );
  }

  SubClass.prototype = Object.create( Parent.prototype );
  SubClass.prototype.constructor = SubClass;

  return SubClass;
}

// ----- helpers ----- //

// how many milliseconds are in each unit
var msUnits = {
  ms: 1,
  s: 1000
};

// munge time-like parameter into millisecond number
// '0.4s' -> 40
function getMilliseconds( time ) {
  if ( typeof time == 'number' ) {
    return time;
  }
  var matches = time.match( /(^\d*\.?\d*)(\w*)/ );
  var num = matches && matches[1];
  var unit = matches && matches[2];
  if ( !num.length ) {
    return 0;
  }
  num = parseFloat( num );
  var mult = msUnits[ unit ] || 1;
  return num * mult;
}

// ----- fin ----- //

// back in global
Outlayer.Item = Item;

return Outlayer;

}));


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * EvEmitter v1.0.3
 * Lil' event emitter
 * MIT License
 */

/* jshint unused: true, undef: true, strict: true */

( function( global, factory ) {
  // universal module definition
  /* jshint strict: false */ /* globals define, module, window */
  if ( true ) {
    // AMD - RequireJS
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS - Browserify, Webpack
    module.exports = factory();
  } else {
    // Browser globals
    global.EvEmitter = factory();
  }

}( typeof window != 'undefined' ? window : this, function() {

"use strict";

function EvEmitter() {}

var proto = EvEmitter.prototype;

proto.on = function( eventName, listener ) {
  if ( !eventName || !listener ) {
    return;
  }
  // set events hash
  var events = this._events = this._events || {};
  // set listeners array
  var listeners = events[ eventName ] = events[ eventName ] || [];
  // only add once
  if ( listeners.indexOf( listener ) == -1 ) {
    listeners.push( listener );
  }

  return this;
};

proto.once = function( eventName, listener ) {
  if ( !eventName || !listener ) {
    return;
  }
  // add event
  this.on( eventName, listener );
  // set once flag
  // set onceEvents hash
  var onceEvents = this._onceEvents = this._onceEvents || {};
  // set onceListeners object
  var onceListeners = onceEvents[ eventName ] = onceEvents[ eventName ] || {};
  // set flag
  onceListeners[ listener ] = true;

  return this;
};

proto.off = function( eventName, listener ) {
  var listeners = this._events && this._events[ eventName ];
  if ( !listeners || !listeners.length ) {
    return;
  }
  var index = listeners.indexOf( listener );
  if ( index != -1 ) {
    listeners.splice( index, 1 );
  }

  return this;
};

proto.emitEvent = function( eventName, args ) {
  var listeners = this._events && this._events[ eventName ];
  if ( !listeners || !listeners.length ) {
    return;
  }
  var i = 0;
  var listener = listeners[i];
  args = args || [];
  // once stuff
  var onceListeners = this._onceEvents && this._onceEvents[ eventName ];

  while ( listener ) {
    var isOnce = onceListeners && onceListeners[ listener ];
    if ( isOnce ) {
      // remove listener
      // remove before trigger to prevent recursion
      this.off( eventName, listener );
      // unset once flag
      delete onceListeners[ listener ];
    }
    // trigger listener
    listener.apply( this, args );
    // get next listener
    i += isOnce ? 0 : 1;
    listener = listeners[i];
  }

  return this;
};

return EvEmitter;

}));


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.accessibility = {

    accessibility_selector: 0,

    start: function start() {

        // Save elements
        var current = componentsModule.modules.accessibility;
        current.parentElement = document.querySelector('[data-component=accessibility]');
        current.passwordElement = current.parentElement.querySelector('.component_accessibility_password');
        current.passwordInput = current.passwordElement.querySelector('input');
        current.selectElement = current.parentElement.querySelector('select');

        current.selector = current.createSelector();
    },

    createSelector: function createSelector() {

        var current = componentsModule.modules.accessibility;

        return new Selector({

            selector: '[name=component_accessibility_selector]',
            onSelect: function onSelect(instance, option) {

                current.accessibility_selector = option.getAttribute('data-item').trim();

                if (parseInt(current.accessibility_selector) === 1) current.passwordElement.classList.remove('hide');else current.passwordElement.classList.add('hide');

                reloadPackery();
            },

            onOpen: reloadPackery,
            onClose: reloadPackery

        });
    },

    resume: function resume() {

        // Save current instance
        var current = componentsModule.modules.accessibility;
        var data = current.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var accessibility = JSON.parse(data);

        var selectOptions = current.selectElement.querySelectorAll('option');
        current.accessibility_selector = accessibility.accessibility_selector;

        if (accessibility.accessibility_selector === 1) current.passwordElement.classList.remove('hide');

        Object.values(selectOptions).forEach(function (selectOption, index) {

            if (index !== accessibility.accessibility_selector) selectOption.removeAttribute('selected');else selectOption.setAttribute('selected', 'true');
        });

        current.selector.destroy();
        current.selector = current.createSelector();
    },

    validate: function validate() {

        var data = componentsModule.modules.accessibility.serialize();
        var validateSelector = data.accessibility_selector > -1 && data.accessibility_selector < 3;
        var validatePassword = data.accessibility_password.length < 121;

        return validateSelector && validatePassword;
    },

    serialize: function serialize() {

        var current = componentsModule.modules.accessibility;

        return {

            accessibility_selector: current.accessibility_selector,
            accessibility_password: current.passwordInput.value.trim()

        };
    }

};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.accessibility = { accessibility_selector: 0, start: function start() {
    var current = componentsModule.modules.accessibility;current.parentElement = document.querySelector("[data-component=accessibility]");current.passwordElement = current.parentElement.querySelector(".component_accessibility_password");current.passwordInput = current.passwordElement.querySelector("input");current.selectElement = current.parentElement.querySelector("select");current.selector = current.createSelector();
  }, createSelector: function createSelector() {
    var current = componentsModule.modules.accessibility;return new Selector({ selector: "[name=component_accessibility_selector]", onSelect: function onSelect(a, b) {
        current.accessibility_selector = b.getAttribute("data-item").trim();if (parseInt(current.accessibility_selector) === 1) {
          current.passwordElement.classList.remove("hide");
        } else {
          current.passwordElement.classList.add("hide");
        }reloadPackery();
      }, onOpen: reloadPackery, onClose: reloadPackery });
  }, resume: function resume() {
    var current = componentsModule.modules.accessibility;var b = current.parentElement.getAttribute("data-resume");if (b === "") {
      return true;
    }var a = JSON.parse(b);var selectOptions = current.selectElement.querySelectorAll("option");current.accessibility_selector = a.accessibility_selector;if (a.accessibility_selector === 1) {
      current.passwordElement.classList.remove("hide");
    }Object.values(selectOptions).forEach(function (c, d) {
      if (d !== a.accessibility_selector) {
        c.removeAttribute("selected");
      } else {
        c.setAttribute("selected", "true");
      }
    });current.selector.destroy();current.selector = current.createSelector();
  }, validate: function validate() {
    var c = componentsModule.modules.accessibility.serialize();var a = c.accessibility_selector > -1 && c.accessibility_selector < 3;var b = c.accessibility_password.length < 121;return a && b;
  }, serialize: function serialize() {
    var current = componentsModule.modules.accessibility;return { accessibility_selector: current.accessibility_selector, accessibility_password: current.passwordInput.value.trim() };
  } };

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.analytics = {

    start: function start() {

        // Save elements
        var current = componentsModule.modules.analytics;
        current.parentElement = document.querySelector('[data-component=analytics]');
        current.detailsElement = current.parentElement.querySelector('div.component_analytics_details');
        current.analyticsCheck = current.parentElement.querySelector('[name=component_analytics]');
        current.detailsCheck = current.parentElement.querySelector('[name=component_analytics_details]');

        // Show / Hide "detailed analytics" checkbox
        componentsModule.initializeEvent({

            event: 'change',
            element: current.analyticsCheck,

            content: function content(event) {

                var classList = componentsModule.modules.analytics.detailsElement.classList;

                if (!!event.target.checked) classList.remove('hide');else classList.add('hide');

                reloadPackery();
            }

        });
    },

    resume: function resume() {

        // Save current instance
        var current = componentsModule.modules.analytics;
        var data = current.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var analytics = JSON.parse(data);

        current.analyticsCheck.checked = !!analytics.analytics;
        triggerEvent(current.analyticsCheck, 'change');

        current.detailsCheck.checked = !!analytics.analytics_details;
    },

    validate: function validate() {

        return true;
    },

    serialize: function serialize() {

        var current = componentsModule.modules.analytics;

        return {

            analytics: !!current.analyticsCheck.checked,
            analytics_details: !!current.detailsCheck.checked

        };
    }

};

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.analytics = { start: function start() {
    var current = componentsModule.modules.analytics;current.parentElement = document.querySelector("[data-component=analytics]");current.detailsElement = current.parentElement.querySelector("div.component_analytics_details");current.analyticsCheck = current.parentElement.querySelector("[name=component_analytics]");current.detailsCheck = current.parentElement.querySelector("[name=component_analytics_details]");componentsModule.initializeEvent({ event: "change", element: current.analyticsCheck, content: function content(a) {
        var classList = componentsModule.modules.analytics.detailsElement.classList;if (!!a.target.checked) {
          classList.remove("hide");
        } else {
          classList.add("hide");
        }reloadPackery();
      } });
  }, resume: function resume() {
    var current = componentsModule.modules.analytics;var b = current.parentElement.getAttribute("data-resume");if (b === "") {
      return true;
    }var a = JSON.parse(b);current.analyticsCheck.checked = !!a.analytics;triggerEvent(current.analyticsCheck, "change");current.detailsCheck.checked = !!a.analytics_details;
  }, validate: function validate() {
    return true;
  }, serialize: function serialize() {
    var current = componentsModule.modules.analytics;return { analytics: !!current.analyticsCheck.checked, analytics_details: !!current.detailsCheck.checked };
  } };

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.attachments = {

    start: function start() {

        // Save elements
        var current = componentsModule.modules.attachments;
        current.parentElement = document.querySelector('[data-component=attachments]');
        current.listElement = current.parentElement.querySelector('.attachments-list');
        current.templateElement = current.parentElement.querySelector('#template_component_attachments_added').childNodes[0];

        // Delegate events
        componentsModule.initializeEvent({

            event: 'click',
            element: current.parentElement,
            content: function content(event) {

                // Open MediaManager
                if (event.target.matches('.add-attachment')) {

                    var type = event.target.getAttribute('data-content');

                    managerActiveInstance = new MediaManager({
                        manager: type,
                        onSelect: function onSelect(path) {

                            current.addNew(path, type);
                        }
                    });
                }

                // Remove attachment
                else if (event.target.matches('.attachment-remove')) {

                        current.listElement.removeChild(event.target.parentNode);

                        reloadPackery();
                    }
            }

        });
    },

    resume: function resume() {

        // Save current instance
        var current = componentsModule.modules.attachments;
        var data = current.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var attachments = JSON.parse(data).attachments;

        if (attachments === null) return true;

        var attachmentTypes = ['images', 'videos', 'sounds', 'files'];
        var attachmentDefinitions = ['app/Data/Files/Images/', 'app/Data/Files/Videos/', 'app/Data/Files/Sounds/', 'app/Data/Files/Files/'];

        Array.from(attachments).forEach(function (attachment) {

            var typeNumber = attachmentDefinitions.findIndex(function (definition) {
                return ~attachment.indexOf(definition);
            });

            attachment = attachment.replace(attachmentDefinitions[typeNumber], '');

            current.addNew(attachment, attachmentTypes[typeNumber]);
        });
    },

    isDuplicate: function isDuplicate(path) {

        return ~componentsModule.modules.attachments.serialize().attachments.indexOf(path);
    },

    addNew: function addNew(path, type) {

        var types = {
            images: ['Images', 'image'],
            videos: ['Videos', 'video'],
            sounds: ['Sounds', 'audio'],
            files: ['Files', 'file']
        };

        var current = componentsModule.modules.attachments;
        var pathPrefix = 'app/Data/Files/';
        var fileType = types[type][1];
        var text = path;

        path = pathPrefix + types[type][0] + '/' + path;

        if (current.isDuplicate(path)) return closeMediaManager();

        var template = current.templateElement.cloneNode(true);

        template.classList.add('component-instance');
        template.setAttribute('data-path', path);
        template.classList.add('icon-' + fileType);
        template.childNodes[1].innerText = text;

        current.listElement.insertBefore(template, current.listElement.childNodes[0]);

        closeMediaManager();
        reloadPackery();
    },

    validate: function validate() {

        return true;
    },

    serialize: function serialize() {

        var attachmentsElements = componentsModule.modules.attachments.listElement.childNodes;
        var attachmentsList = Array.from(attachmentsElements).reverse().map(function (element) {
            return element.getAttribute('data-path');
        });

        return {

            attachments: attachmentsList

        };
    }

};

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.attachments = { start: function start() {
    var current = componentsModule.modules.attachments;current.parentElement = document.querySelector("[data-component=attachments]");current.listElement = current.parentElement.querySelector(".attachments-list");current.templateElement = current.parentElement.querySelector("#template_component_attachments_added").childNodes[0];componentsModule.initializeEvent({ event: "click", element: current.parentElement, content: function content(a) {
        if (a.target.matches(".add-attachment")) {
          var type = a.target.getAttribute("data-content");managerActiveInstance = new MediaManager({ manager: type, onSelect: function onSelect(b) {
              current.addNew(b, type);
            } });
        } else {
          if (a.target.matches(".attachment-remove")) {
            current.listElement.removeChild(a.target.parentNode);reloadPackery();
          }
        }
      } });
  }, resume: function resume() {
    var current = componentsModule.modules.attachments;var b = current.parentElement.getAttribute("data-resume");if (b === "") {
      return true;
    }var a = JSON.parse(b).attachments;if (a === null) {
      return true;
    }var c = ["images", "videos", "sounds", "files"];var d = ["app/Data/Files/Images/", "app/Data/Files/Videos/", "app/Data/Files/Sounds/", "app/Data/Files/Files/"];Array.from(a).forEach(function (f) {
      var e = d.findIndex(function (g) {
        return ~f.indexOf(g);
      });f = f.replace(d[e], "");current.addNew(f, c[e]);
    });
  }, isDuplicate: function isDuplicate(a) {
    return ~componentsModule.modules.attachments.serialize().attachments.indexOf(a);
  }, addNew: function addNew(c, b) {
    var a = { images: ["Images", "image"], videos: ["Videos", "video"], sounds: ["Sounds", "audio"], files: ["Files", "file"] };var current = componentsModule.modules.attachments;var pathPrefix = "app/Data/Files/";var fileType = a[b][1];var text = c;c = pathPrefix + a[b][0] + "/" + c;if (current.isDuplicate(c)) {
      return closeMediaManager();
    }var template = current.templateElement.cloneNode(true);template.classList.add("component-instance");template.setAttribute("data-path", c);template.classList.add("icon-" + fileType);template.childNodes[1].innerText = text;current.listElement.insertBefore(template, current.listElement.childNodes[0]);closeMediaManager();reloadPackery();
  }, validate: function validate() {
    return true;
  }, serialize: function serialize() {
    var attachmentsElements = componentsModule.modules.attachments.listElement.childNodes;var attachmentsList = Array.from(attachmentsElements).reverse().map(function (a) {
      return a.getAttribute("data-path");
    });return { attachments: attachmentsList };
  } };

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.audio = {

    data: {},

    resumeInline: function resumeInline(identifier, element, resumeData) {

        var current = componentsModule.modules.audio;
        var path = resumeData.audio;

        current.create(identifier, element);
        current.onSelect(identifier, element, path, true);
    },

    validateInput: function validateInput(element, identifier, path, onSuccess) {

        var messageBox = element.querySelector('.validate-message');

        if (!/[(http(s)?):\/\/(www\.)?a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)/.test(path)) {

            showValidationResult(messageBox, 'COMPONENT_URL_INVALID', false, reloadPackery);

            return false;
        }

        new Promise(function (resolve) {

            var audio = new Audio();

            audio.addEventListener('canplaythrough', function () {
                resolve(true);
            });

            audio.addEventListener('error', function () {
                resolve(false);
            });

            audio.src = path;
        }).then(function (result) {

            if (result) showValidationResult(messageBox, 'COMPONENT_URL_INVALID', true, reloadPackery);else showValidationResult(messageBox, 'COMPONENT_URL_INVALID', false, reloadPackery);
        });

        if (onSuccess) onSuccess();
    },

    remove: function remove(element) {

        element.querySelectorAll('div.component-instance').forEach(function (item) {
            item.querySelector('span.item-remove').click();
        });
    },

    onSelect: function onSelect(identifier, element, path, outside) {

        var contentElement = element.querySelector('div.component-element-content');
        contentElement.classList.add('no-padding');

        // Remove current audio
        componentsModule.modules.audio.remove(element);

        // Create source link
        if (!outside) path = 'app/Data/Files/Sounds/' + path;

        // Save audio path
        componentsModule.modules.audio.data[identifier] = {
            title: '',
            audio: path,
            disabled: 0
        };

        // Create template
        var template = contentElement.querySelector('#template_component_content_audio_item').children[0].cloneNode(true);
        template.setAttribute('data-path', path);
        template.classList.add('component-instance');
        template.children[0].setAttribute('src', path);
        template.children[3].innerText = path.split('/').pop();
        contentElement.appendChild(template);

        var timer = void 0;
        template.children[1].addEventListener('click', function (event) {
            if (template.children[0].ended) template.children[2].click();
            if (template.children[0].paused) {
                template.children[0].play();
                showPlayerTime();
                timer = setInterval(showPlayerTime, 1000);
            } else {
                template.children[0].pause();
                showPlayerTime();
                clearInterval(timer);
            }
            event.target.classList.toggle('icon-pause');
        });

        template.children[2].addEventListener('click', function () {
            template.children[0].currentTime = 0;
            template.children[0].pause();
            template.children[1].classList.remove('icon-pause');
            clearInterval(timer);
            showPlayerTime();
        });

        function showPlayerTime() {
            var position = template.children[0].currentTime;
            position = parseInt(position / 60, 10) + ':' + pad(Math.round(position % 60), 2);
            var duration = template.children[0].duration;
            var minutes = parseInt(duration / 60, 10);
            var seconds = duration % 60;
            template.children[5].innerText = position + '/' + minutes + ':' + pad(Math.round(seconds), 2);
        }

        // Hide media manager
        template.children[0].addEventListener('loadedmetadata', function () {
            showPlayerTime();
            contentElement.querySelector('div.input-box.select-image').classList.add('hide');
            document.querySelector('div.media-manager span.close-manager').click();
        });

        // Remove audio
        template.children[4].addEventListener('click', function () {
            contentElement.querySelector('div.input-box.select-image').classList.remove('hide');
            contentElement.removeChild(template);
            contentElement.classList.remove('no-padding');
            delete componentsModule.modules.audio.data[identifier];
        });
    },

    create: function create(identifier, element) {
        componentsModule.initializeEvents([{
            // Open Media manager
            event: 'click',
            element: element.querySelector('button.inline-image_manager'),
            content: function content() {
                managerActiveInstance = new MediaManager({
                    manager: 'sounds',
                    onSelect: function onSelect(path) {
                        componentsModule.modules.audio.onSelect(identifier, element, path, false);
                    }
                });
            }
        }, {
            // Enter custom URL to audio
            event: 'keypress',
            element: element.querySelector('input[name=component_inline_audio_input]'),
            content: function content(event) {
                if (event.keyCode && event.keyCode === 13) {
                    var path = event.target.value;
                    componentsModule.modules.audio.validateInput(element, identifier, path, function () {

                        componentsModule.modules.audio.onSelect(identifier, element, path, true);
                    });
                }
            }
        }, {
            // Real-time URL validation
            event: 'change keyup',
            element: element.querySelector('input[name=component_inline_audio_input]'),
            content: function content(event) {
                componentsModule.modules.audio.validateInput(element, identifier, event.target.value);
            }
        }]);
    },

    validate: function validate() {
        return true;
    },

    serialize: function serialize() {
        return componentsModule.modules.audio.data;
    }

};

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.audio = { data: {}, resumeInline: function resumeInline(b, c, a) {
    var current = componentsModule.modules.audio;var path = a.audio;current.create(b, c);current.onSelect(b, c, path, true);
  }, validateInput: function validateInput(b, a, c, d) {
    var messageBox = b.querySelector(".validate-message");if (!/[(http(s)?):\/\/(www\.)?a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)/.test(c)) {
      showValidationResult(messageBox, "COMPONENT_URL_INVALID", false, reloadPackery);return false;
    }new Promise(function (e) {
      var audio = new Audio();audio.addEventListener("canplaythrough", function () {
        e(true);
      });audio.addEventListener("error", function () {
        e(false);
      });audio.src = c;
    }).then(function (e) {
      if (e) {
        showValidationResult(messageBox, "COMPONENT_URL_INVALID", true, reloadPackery);
      } else {
        showValidationResult(messageBox, "COMPONENT_URL_INVALID", false, reloadPackery);
      }
    });if (d) {
      d();
    }
  }, remove: function remove(a) {
    a.querySelectorAll("div.component-instance").forEach(function (b) {
      b.querySelector("span.item-remove").click();
    });
  }, onSelect: function onSelect(a, b, d, c) {
    var contentElement = b.querySelector("div.component-element-content");contentElement.classList.add("no-padding");componentsModule.modules.audio.remove(b);if (!c) {
      d = "app/Data/Files/Sounds/" + d;
    }componentsModule.modules.audio.data[a] = { title: "", audio: d, disabled: 0 };var template = contentElement.querySelector("#template_component_content_audio_item").children[0].cloneNode(true);template.setAttribute("data-path", d);template.classList.add("component-instance");template.children[0].setAttribute("src", d);template.children[3].innerText = d.split("/").pop();contentElement.appendChild(template);var timer = void 0;template.children[1].addEventListener("click", function (f) {
      if (template.children[0].ended) {
        template.children[2].click();
      }if (template.children[0].paused) {
        template.children[0].play();e();timer = setInterval(e, 1000);
      } else {
        template.children[0].pause();e();clearInterval(timer);
      }f.target.classList.toggle("icon-pause");
    });template.children[2].addEventListener("click", function () {
      template.children[0].currentTime = 0;template.children[0].pause();template.children[1].classList.remove("icon-pause");clearInterval(timer);e();
    });function e() {
      var position = template.children[0].currentTime;position = parseInt(position / 60, 10) + ":" + pad(Math.round(position % 60), 2);var duration = template.children[0].duration;var minutes = parseInt(duration / 60, 10);var seconds = duration % 60;template.children[5].innerText = position + "/" + minutes + ":" + pad(Math.round(seconds), 2);
    }template.children[0].addEventListener("loadedmetadata", function () {
      e();contentElement.querySelector("div.input-box.select-image").classList.add("hide");document.querySelector("div.media-manager span.close-manager").click();
    });template.children[4].addEventListener("click", function () {
      contentElement.querySelector("div.input-box.select-image").classList.remove("hide");contentElement.removeChild(template);contentElement.classList.remove("no-padding");delete componentsModule.modules.audio.data[a];
    });
  }, create: function create(a, b) {
    componentsModule.initializeEvents([{ event: "click", element: b.querySelector("button.inline-image_manager"), content: function content() {
        managerActiveInstance = new MediaManager({ manager: "sounds", onSelect: function onSelect(c) {
            componentsModule.modules.audio.onSelect(a, b, c, false);
          } });
      } }, { event: "keypress", element: b.querySelector("input[name=component_inline_audio_input]"), content: function content(c) {
        if (c.keyCode && c.keyCode === 13) {
          var path = c.target.value;componentsModule.modules.audio.validateInput(b, a, path, function () {
            componentsModule.modules.audio.onSelect(a, b, path, true);
          });
        }
      } }, { event: "change keyup", element: b.querySelector("input[name=component_inline_audio_input]"), content: function content(c) {
        componentsModule.modules.audio.validateInput(b, a, c.target.value);
      } }]);
  }, validate: function validate() {
    return true;
  }, serialize: function serialize() {
    return componentsModule.modules.audio.data;
  } };

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.categories = {

    start: function start() {

        // Save elements
        var current = componentsModule.modules.categories;
        current.parentElement = document.querySelector('[data-component=categories]');
        current.listElement = current.parentElement.querySelector('.categories-list');
        current.inputElement = current.parentElement.querySelector('input');
        current.templateElement = current.parentElement.querySelector('#template_component_categories_item').childNodes[0];

        // Get and show categories
        var categories = getJson(URI + 'api/categories.all&csrf_token=' + csrf_token);

        if (!categories.success || categories.code !== 200) return true;

        Object.values(categories.data).forEach(function (category) {

            var template = current.templateElement.cloneNode(true);
            template.setAttribute('data-category', category.id);
            template.setAttribute('data-active', 'false');
            template.children[0].innerText = category.name;

            current.listElement.appendChild(template);
        });

        // Events
        componentsModule.initializeEvents([{
            // Delegate click events
            event: 'click',
            element: current.parentElement,
            content: function content(event) {

                var target = event.target;

                // Add category
                if (target.matches('.add-category')) {

                    target.parentNode.setAttribute('data-active', 'true');
                    target.classList.add('hide');
                    target.nextSibling.classList.remove('hide');
                }

                // Remove category
                else if (target.matches('.remove-category')) {

                        target.parentNode.setAttribute('data-active', 'false');
                        target.previousSibling.classList.remove('hide');
                        target.classList.add('hide');
                    }
            }
        }, {
            // Search in categories
            event: 'change keyup',
            element: current.inputElement,
            content: function content() {

                var searchPhrase = current.inputElement.value.trim().toLowerCase();

                Array.from(current.listElement.childNodes).forEach(function (categoryElement) {

                    var categoryName = categoryElement.childNodes[0].innerText.toLowerCase();

                    if (~categoryName.indexOf(searchPhrase)) categoryElement.classList.remove('hide');else categoryElement.classList.add('hide');
                });

                reloadPackery();
            }
        }]);

        reloadPackery();
    },

    resume: function resume() {

        // Save current instance
        var current = componentsModule.modules.categories;
        var data = current.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var categories = JSON.parse(data).categories;

        if (categories === null) return true;

        categories.forEach(function (category) {

            current.listElement.querySelector('[data-category="' + category + '"]').childNodes[1].click();
        });
    },

    validate: function validate() {

        return true;
    },

    serialize: function serialize() {

        var categoriesElements = componentsModule.modules.categories.listElement.querySelectorAll('[data-active=true]');

        var activeCategories = Object.values(categoriesElements).map(function (categoryElement) {

            return categoryElement.getAttribute('data-category');
        });

        return {

            categories: activeCategories

        };
    }

};

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.categories = { start: function start() {
    var current = componentsModule.modules.categories;current.parentElement = document.querySelector("[data-component=categories]");current.listElement = current.parentElement.querySelector(".categories-list");current.inputElement = current.parentElement.querySelector("input");current.templateElement = current.parentElement.querySelector("#template_component_categories_item").childNodes[0];var a = getJson(URI + "api/categories.all&csrf_token=" + csrf_token);if (!a.success || a.code !== 200) {
      return true;
    }Object.values(a.data).forEach(function (b) {
      var template = current.templateElement.cloneNode(true);template.setAttribute("data-category", b.id);template.setAttribute("data-active", "false");template.children[0].innerText = b.name;current.listElement.appendChild(template);
    });componentsModule.initializeEvents([{ event: "click", element: current.parentElement, content: function content(b) {
        var target = b.target;if (target.matches(".add-category")) {
          target.parentNode.setAttribute("data-active", "true");target.classList.add("hide");target.nextSibling.classList.remove("hide");
        } else {
          if (target.matches(".remove-category")) {
            target.parentNode.setAttribute("data-active", "false");target.previousSibling.classList.remove("hide");target.classList.add("hide");
          }
        }
      } }, { event: "change keyup", element: current.inputElement, content: function content() {
        var b = current.inputElement.value.trim().toLowerCase();Array.from(current.listElement.childNodes).forEach(function (c) {
          var categoryName = c.childNodes[0].innerText.toLowerCase();if (~categoryName.indexOf(b)) {
            c.classList.remove("hide");
          } else {
            c.classList.add("hide");
          }
        });reloadPackery();
      } }]);reloadPackery();
  }, resume: function resume() {
    var current = componentsModule.modules.categories;var b = current.parentElement.getAttribute("data-resume");if (b === "") {
      return true;
    }var a = JSON.parse(b).categories;if (a === null) {
      return true;
    }a.forEach(function (c) {
      current.listElement.querySelector('[data-category="' + c + '"]').childNodes[1].click();
    });
  }, validate: function validate() {
    return true;
  }, serialize: function serialize() {
    var categoriesElements = componentsModule.modules.categories.listElement.querySelectorAll("[data-active=true]");var activeCategories = Object.values(categoriesElements).map(function (a) {
      return a.getAttribute("data-category");
    });return { categories: activeCategories };
  } };

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.code = {

    programmingLanguages: [],
    select: false,
    data: {},

    resumeInline: function resumeInline(identifier, element, resumeData) {

        componentsModule.modules.code.create(identifier, element, resumeData);
    },

    createSelector: function createSelector(identifier, current) {

        setTimeout(function () {

            new Selector({

                selector: 'select[name=component-inline-code-programming_languages-select_' + identifier + ']',

                onSelect: function onSelect(instance, option) {

                    current.data[identifier].code_language = +option.getAttribute('data-item').trim();
                }

            });
        });
    },

    create: function create(identifier, element, resumeData) {

        var current = componentsModule.modules.code;

        // Load programming languages
        if (current.programmingLanguages.length === 0) current.programmingLanguages = getJson('app/Config/programming_languages.json');

        // Create language selector
        if (current.select === false) {

            var _select = document.createElement('select');

            _select.setAttribute('id', 'select-relative');
            _select.setAttribute('data-type', 'search-selector');

            current.programmingLanguages.forEach(function (language, key) {

                var option = document.createElement('option');
                option.setAttribute('value', key.toString());

                if (language === 'JavaScript') option.setAttribute('selected', 'true');

                option.innerText = language;
                _select.appendChild(option);
            });

            current.select = _select;
        }

        var contentElement = element.querySelector('div.component-element-content');
        var textarea = contentElement.querySelector('textarea');
        var select = current.select.cloneNode(true);

        // Initialize data object
        current.data[identifier] = {
            title: '',
            code: '',
            code_language: 299,
            disabled: 0
        };

        if (resumeData) {

            if (resumeData.code) current.data[identifier].code = textarea.value = resumeData.code.trim();

            if (resumeData.code_language) {

                var selected = select.querySelector('[selected]');
                current.data[identifier].code_language = resumeData.code_language;

                selected.removeAttribute('selected');
                select.children[resumeData.code_language].setAttribute('selected', 'true');
            }
        }

        select.setAttribute('name', 'component-inline-code-programming_languages-select_' + identifier);
        contentElement.appendChild(select);

        current.createSelector(identifier, current);

        // Initialize events
        componentsModule.initializeEvents([{
            // Serialize textarea
            event: 'change keyup',
            element: textarea,
            content: function content(event) {
                current.data[identifier].code = event.target.value.trim();
            }
        }, {
            // Tab in textarea
            event: 'keydown',
            element: textarea,
            content: function content(event) {

                var keyCode = event.keyCode || event.which;

                if (keyCode === 9) {

                    event.preventDefault();

                    var start = this.selectionStart;
                    var end = this.selectionEnd;
                    var val = this.value;
                    var _selected = val.substring(start, end);
                    var re = /^/gm;
                    var count = _selected.match(re).length * 4;

                    this.value = val.substring(0, start) + _selected.replace(re, '    ') + val.substring(end);

                    if (start === end) this.selectionStart = end + count;else this.selectionStart = start;

                    this.selectionEnd = end + count;
                }
            }
        }]);
    },

    validate: function validate() {
        return true;
    },

    serialize: function serialize() {
        return componentsModule.modules.code.data;
    }

};

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.code = { programmingLanguages: [], select: false, data: {}, resumeInline: function resumeInline(b, c, a) {
    componentsModule.modules.code.create(b, c, a);
  }, createSelector: function createSelector(a, b) {
    setTimeout(function () {
      new Selector({ selector: "select[name=component-inline-code-programming_languages-select_" + a + "]", onSelect: function onSelect(c, d) {
          b.data[a].code_language = +d.getAttribute("data-item").trim();
        } });
    });
  }, create: function create(b, c, a) {
    var current = componentsModule.modules.code;if (current.programmingLanguages.length === 0) {
      current.programmingLanguages = getJson("app/Config/programming_languages.json");
    }if (current.select === false) {
      var _select = document.createElement("select");_select.setAttribute("id", "select-relative");_select.setAttribute("data-type", "search-selector");current.programmingLanguages.forEach(function (e, d) {
        var option = document.createElement("option");option.setAttribute("value", d.toString());if (e === "JavaScript") {
          option.setAttribute("selected", "true");
        }option.innerText = e;_select.appendChild(option);
      });current.select = _select;
    }var contentElement = c.querySelector("div.component-element-content");var textarea = contentElement.querySelector("textarea");var select = current.select.cloneNode(true);current.data[b] = { title: "", code: "", code_language: 299, disabled: 0 };if (a) {
      if (a.code) {
        current.data[b].code = textarea.value = a.code.trim();
      }if (a.code_language) {
        var selected = select.querySelector("[selected]");current.data[b].code_language = a.code_language;selected.removeAttribute("selected");select.children[a.code_language].setAttribute("selected", "true");
      }
    }select.setAttribute("name", "component-inline-code-programming_languages-select_" + b);contentElement.appendChild(select);current.createSelector(b, current);componentsModule.initializeEvents([{ event: "change keyup", element: textarea, content: function content(d) {
        current.data[b].code = d.target.value.trim();
      } }, { event: "keydown", element: textarea, content: function content(d) {
        var keyCode = d.keyCode || d.which;if (keyCode === 9) {
          d.preventDefault();var start = this.selectionStart;var end = this.selectionEnd;var val = this.value;var _selected = val.substring(start, end);var re = /^/gm;var count = _selected.match(re).length * 4;this.value = val.substring(0, start) + _selected.replace(re, "    ") + val.substring(end);if (start === end) {
            this.selectionStart = end + count;
          } else {
            this.selectionStart = start;
          }this.selectionEnd = end + count;
        }
      } }]);
  }, validate: function validate() {
    return true;
  }, serialize: function serialize() {
    return componentsModule.modules.code.data;
  } };

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.comments = {

    start: function start() {

        // Save elements
        var current = componentsModule.modules.comments;
        current.parentElement = document.querySelector('[data-component=comments]');
        current.commentsCheck = current.parentElement.querySelector('[name=component_comments]');
        current.approveBox = current.parentElement.querySelector('.component_comments_approve');
        current.approveCheck = current.approveBox.querySelector('input');

        // Events
        componentsModule.initializeEvent({

            event: 'change',
            element: current.commentsCheck,
            content: function content() {

                if (!!current.commentsCheck.checked) current.approveBox.classList.remove('hide');else current.approveBox.classList.add('hide');

                reloadPackery();
            }

        });
    },

    resume: function resume() {

        // Save current instance
        var current = componentsModule.modules.comments;
        var data = current.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var comments = JSON.parse(data);

        current.commentsCheck.checked = !!comments.comments;
        triggerEvent(current.commentsCheck, 'change');

        current.approveCheck.checked = comments.comments_approve;
    },

    validate: function validate() {

        return true;
    },

    serialize: function serialize() {

        var current = componentsModule.modules.comments;

        return {

            comments: !!current.commentsCheck.checked,
            comments_approve: !!current.approveCheck.checked

        };
    }

};

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.comments = { start: function start() {
    var current = componentsModule.modules.comments;current.parentElement = document.querySelector("[data-component=comments]");current.commentsCheck = current.parentElement.querySelector("[name=component_comments]");current.approveBox = current.parentElement.querySelector(".component_comments_approve");current.approveCheck = current.approveBox.querySelector("input");componentsModule.initializeEvent({ event: "change", element: current.commentsCheck, content: function content() {
        if (!!current.commentsCheck.checked) {
          current.approveBox.classList.remove("hide");
        } else {
          current.approveBox.classList.add("hide");
        }reloadPackery();
      } });
  }, resume: function resume() {
    var current = componentsModule.modules.comments;var a = current.parentElement.getAttribute("data-resume");if (a === "") {
      return true;
    }var b = JSON.parse(a);current.commentsCheck.checked = !!b.comments;triggerEvent(current.commentsCheck, "change");current.approveCheck.checked = b.comments_approve;
  }, validate: function validate() {
    return true;
  }, serialize: function serialize() {
    var current = componentsModule.modules.comments;return { comments: !!current.commentsCheck.checked, comments_approve: !!current.approveCheck.checked };
  } };

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.copyright = {

    start: function start() {

        // Save elements
        var current = componentsModule.modules.copyright;
        current.parentElement = document.querySelector('[data-component=copyright]');
        current.selectElement = current.parentElement.querySelector('select');

        current.selector = current.createSelector();
    },

    createSelector: function createSelector() {

        return new Selector({
            selector: '[name=component_copyright_selector]',
            onOpen: reloadPackery,
            onClose: reloadPackery
        });
    },

    resume: function resume() {

        // Save current instance
        var current = componentsModule.modules.copyright;
        var data = current.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var copyright = JSON.parse(data).copyright;

        var selectOptions = current.selectElement.querySelectorAll('option');

        Object.values(selectOptions).forEach(function (selectOption, index) {

            if (index !== copyright) selectOption.removeAttribute('selected');else selectOption.setAttribute('selected', 'true');
        });

        current.selector.destroy();
        current.selector = current.createSelector();
    },

    validate: function validate() {

        var data = componentsModule.modules.copyright.serialize().copyright;

        return data > -1 && data < 6;
    },

    serialize: function serialize() {

        return {

            copyright: parseInt(componentsModule.modules.copyright.selectElement.querySelector('[selected=true]').getAttribute('value'))

        };
    }

};

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.copyright = { start: function start() {
    var current = componentsModule.modules.copyright;current.parentElement = document.querySelector("[data-component=copyright]");current.selectElement = current.parentElement.querySelector("select");current.selector = current.createSelector();
  }, createSelector: function createSelector() {
    return new Selector({ selector: "[name=component_copyright_selector]", onOpen: reloadPackery, onClose: reloadPackery });
  }, resume: function resume() {
    var current = componentsModule.modules.copyright;var b = current.parentElement.getAttribute("data-resume");if (b === "") {
      return true;
    }var a = JSON.parse(b).copyright;var selectOptions = current.selectElement.querySelectorAll("option");Object.values(selectOptions).forEach(function (c, d) {
      if (d !== a) {
        c.removeAttribute("selected");
      } else {
        c.setAttribute("selected", "true");
      }
    });current.selector.destroy();current.selector = current.createSelector();
  }, validate: function validate() {
    var a = componentsModule.modules.copyright.serialize().copyright;return a > -1 && a < 6;
  }, serialize: function serialize() {
    return { copyright: parseInt(componentsModule.modules.copyright.selectElement.querySelector("[selected=true]").getAttribute("value")) };
  } };

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.created_at = {

    start: function start() {

        // Save elements
        var current = componentsModule.modules.created_at;
        current.parentElement = document.querySelector('[data-component=created_at]');
        current.customCheck = current.parentElement.querySelector('[name=component_created]');
        current.dateBox = current.parentElement.querySelector('.component_created_custom');
        current.dateInput = current.dateBox.querySelector('input');
        current.clearInput = current.dateBox.querySelector('.clear-input');

        current.customCheck.checked = false;

        // Events
        componentsModule.initializeEvents([{
            // Show / Hide custom input
            event: 'change',
            element: current.customCheck,
            content: function content() {

                if (!!current.customCheck.checked) current.dateBox.classList.remove('hide');else current.dateBox.classList.add('hide');

                reloadPackery();
            }
        }, {
            // Clear input
            event: 'click',
            element: current.clearInput,
            content: function content() {

                current.dateInput.value = '';
            }
        }]);
    },

    resume: function resume() {

        // Save current instance
        var current = componentsModule.modules.created_at;
        var data = current.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        current.dateInput.value = JSON.parse(data).created_at;
    },

    validate: function validate() {

        return true;
    },

    serialize: function serialize() {

        var current = componentsModule.modules.created_at;
        var isCustom = !!current.customCheck.checked;
        var data = false;

        if (isCustom && current.dateInput.value !== '') data = current.dateInput.value.trim();

        return {

            created_at: data

        };
    }

};

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.created_at = { start: function start() {
    var current = componentsModule.modules.created_at;current.parentElement = document.querySelector("[data-component=created_at]");current.customCheck = current.parentElement.querySelector("[name=component_created]");current.dateBox = current.parentElement.querySelector(".component_created_custom");current.dateInput = current.dateBox.querySelector("input");current.clearInput = current.dateBox.querySelector(".clear-input");current.customCheck.checked = false;componentsModule.initializeEvents([{ event: "change", element: current.customCheck, content: function content() {
        if (!!current.customCheck.checked) {
          current.dateBox.classList.remove("hide");
        } else {
          current.dateBox.classList.add("hide");
        }reloadPackery();
      } }, { event: "click", element: current.clearInput, content: function content() {
        current.dateInput.value = "";
      } }]);
  }, resume: function resume() {
    var current = componentsModule.modules.created_at;var a = current.parentElement.getAttribute("data-resume");if (a === "") {
      return true;
    }current.dateInput.value = JSON.parse(a).created_at;
  }, validate: function validate() {
    return true;
  }, serialize: function serialize() {
    var current = componentsModule.modules.created_at;var a = !!current.customCheck.checked;var data = false;if (a && current.dateInput.value !== "") {
      data = current.dateInput.value.trim();
    }return { created_at: data };
  } };

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.custom_fields = {

    start: function start() {

        // Save elements
        var current = componentsModule.modules.custom_fields;
        current.parentElement = document.querySelector('[data-component=custom_fields]');
        current.listElement = current.parentElement.querySelector('.custom_fields-list');
        current.identifierInput = current.parentElement.querySelector('#component_custom-fields_add_name');
        current.valueInput = current.parentElement.querySelector('#component_custom-fields_add_value');
        current.addButton = current.parentElement.querySelector('.add-custom_field');
        current.templateElement = current.parentElement.querySelector('#template_component_custom-fields_field').childNodes[0];

        componentsModule.initializeEvents([{
            // Delegate click events
            event: 'click',
            element: current.parentElement,
            content: function content(event) {

                var target = event.target;

                // Add custom field
                if (target.matches('.add-custom_field')) {

                    current.addField();
                }

                // Edit custom field
                else if (target.matches('.edit-custom_field')) {

                        var item = target.parentNode;

                        current.identifierInput.value = item.childNodes[0].innerText.trim();
                        current.valueInput.value = item.childNodes[1].innerText.trim();

                        current.listElement.removeChild(item);
                        current.identifierInput.focus();

                        reloadPackery();
                    }

                    // Remove custom field
                    else if (target.matches('.remove-custom_field')) {

                            current.listElement.removeChild(target.parentNode);
                            current.identifierInput.focus();

                            reloadPackery();
                        }
            }
        }, {
            // Allow submit with Enter key
            event: 'keydown',
            element: current.valueInput,
            content: function content(event) {

                if (event.keyCode && event.keyCode === 13) current.addButton.click();
            }

        }]);
    },

    resume: function resume() {

        // Save current instance
        var current = componentsModule.modules.custom_fields;
        var data = current.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var fields = JSON.parse(data).custom_fields;

        if (fields === null) return true;

        Object.keys(fields).map(function (key) {

            current.addField(key, fields[key]);
        });
    },

    addField: function addField(id, val) {

        var current = componentsModule.modules.custom_fields;
        var identifier = id || current.identifierInput.value.trim();
        var value = val || current.valueInput.value.trim();

        if (identifier === '' || value === '') return true;

        if (current.serialize().custom_fields[identifier]) {

            current.identifierInput.value = '';
            current.identifierInput.focus();
            current.valueInput.value = '';

            return true;
        }

        var template = current.templateElement.cloneNode(true);
        template.childNodes[0].innerText = identifier;
        template.childNodes[1].innerText = value;

        current.listElement.insertBefore(template, current.listElement.childNodes[0]);

        id || current.identifierInput.focus();
        current.identifierInput.value = '';
        current.valueInput.value = '';

        reloadPackery();
    },

    validate: function validate() {

        return true;
    },

    serialize: function serialize() {

        var fieldElements = componentsModule.modules.custom_fields.listElement.childNodes;
        var data = {};

        Array.from(fieldElements).map(function (fieldElement) {

            data[fieldElement.childNodes[0].innerText.trim()] = fieldElement.childNodes[1].innerText.trim();
        });

        return {

            custom_fields: data

        };
    }

};

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.custom_fields = { start: function start() {
    var current = componentsModule.modules.custom_fields;current.parentElement = document.querySelector("[data-component=custom_fields]");current.listElement = current.parentElement.querySelector(".custom_fields-list");current.identifierInput = current.parentElement.querySelector("#component_custom-fields_add_name");current.valueInput = current.parentElement.querySelector("#component_custom-fields_add_value");current.addButton = current.parentElement.querySelector(".add-custom_field");current.templateElement = current.parentElement.querySelector("#template_component_custom-fields_field").childNodes[0];componentsModule.initializeEvents([{ event: "click", element: current.parentElement, content: function content(a) {
        var target = a.target;if (target.matches(".add-custom_field")) {
          current.addField();
        } else {
          if (target.matches(".edit-custom_field")) {
            var item = target.parentNode;current.identifierInput.value = item.childNodes[0].innerText.trim();current.valueInput.value = item.childNodes[1].innerText.trim();current.listElement.removeChild(item);current.identifierInput.focus();reloadPackery();
          } else {
            if (target.matches(".remove-custom_field")) {
              current.listElement.removeChild(target.parentNode);current.identifierInput.focus();reloadPackery();
            }
          }
        }
      } }, { event: "keydown", element: current.valueInput, content: function content(a) {
        if (a.keyCode && a.keyCode === 13) {
          current.addButton.click();
        }
      } }]);
  }, resume: function resume() {
    var current = componentsModule.modules.custom_fields;var b = current.parentElement.getAttribute("data-resume");if (b === "") {
      return true;
    }var a = JSON.parse(b).custom_fields;if (a === null) {
      return true;
    }Object.keys(a).map(function (c) {
      current.addField(c, a[c]);
    });
  }, addField: function addField(d, c) {
    var current = componentsModule.modules.custom_fields;var a = d || current.identifierInput.value.trim();var b = c || current.valueInput.value.trim();if (a === "" || b === "") {
      return true;
    }if (current.serialize().custom_fields[a]) {
      current.identifierInput.value = "";current.identifierInput.focus();current.valueInput.value = "";return true;
    }var template = current.templateElement.cloneNode(true);template.childNodes[0].innerText = a;template.childNodes[1].innerText = b;current.listElement.insertBefore(template, current.listElement.childNodes[0]);d || current.identifierInput.focus();current.identifierInput.value = "";current.valueInput.value = "";reloadPackery();
  }, validate: function validate() {
    return true;
  }, serialize: function serialize() {
    var fieldElements = componentsModule.modules.custom_fields.listElement.childNodes;var data = {};Array.from(fieldElements).map(function (a) {
      data[a.childNodes[0].innerText.trim()] = a.childNodes[1].innerText.trim();
    });return { custom_fields: data };
  } };

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var excerpt = {
    start: function start() {

        // Save elements
        excerpt.parentElement = document.querySelector('[data-component=excerpt]');
        excerpt.inputElement = excerpt.parentElement.querySelector('textarea');
        excerpt.excerptBox = document.querySelector('.header-description');

        _Utils2.default.registerEvent({

            event: 'keydown keyup change',
            element: excerpt.inputElement,
            content: function content(event) {

                var value = event.target.value.trim();
                var length = value.length;

                if (length > 36) value = value.substr(0, 36) + '...';

                excerpt.excerptBox.innerText = value;
            }

        });
    },
    resume: function resume() {

        // Save current instance
        var data = excerpt.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var object = JSON.parse(data);
        excerpt.inputElement.value = object.excerpt;

        _Utils2.default.triggerEvent(excerpt.inputElement, 'change');
    },
    validate: function validate() {

        var data = excerpt.serialize().excerpt;

        return data.length < 361;
    },
    serialize: function serialize() {

        return {
            excerpt: excerpt.inputElement.value.trim()
        };
    }
};

module.exports = excerpt;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.gallery = {

    data: {},

    validate: function validate() {
        return true;
    },

    serialize: function serialize() {
        return componentsModule.modules.gallery.data;
    },

    resumeInline: function resumeInline(identifier, element, resumeData) {

        var current = componentsModule.modules.gallery;
        current.create(identifier, element);

        resumeData.gallery.forEach(function (image) {

            current.onSelect(identifier, element, image, true);
        });
    },

    validateInput: function validateInput(identifier, element, path, onSuccess) {

        if (!/[(http(s)?):\/\/(www\.)?a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)/.test(path)) {
            showValidationResult(element, 'COMPONENT_URL_INVALID', false, $.noop);
            return false;
        }

        var promise = new Promise(function (resolve, reject) {
            var image = new Image();
            image.onload = function () {
                resolve(true);
            };
            image.onerror = function () {
                resolve(false);
            };
            image.src = path;
        });

        promise.then(function (result) {

            if (result) {
                showValidationResult(element, '', true, $.noop);
                if (onSuccess) onSuccess(identifier, element, path, true);
                return true;
            }

            showValidationResult(element, 'COMPONENT_URL_INVALID', false, $.noop);
        });
    },

    onSelect: function onSelect(identifier, element, path, outside) {

        var current = componentsModule.modules.gallery;
        var contentElement = element.querySelector('div.gallery-items');
        contentElement.classList.remove('no-padding');

        // Create source link
        if (!outside) path = 'app/Data/Files/Images/' + path;

        // Check gallery data
        if (current.data[identifier]) {

            if (~current.data[identifier].gallery.indexOf(path)) {

                closeMediaManager();
                return false;
            }

            current.data[identifier].gallery.push(path);
        } else current.data[identifier] = {
            title: '',
            gallery: [path],
            disabled: 0
        };

        // Create template
        if (!current.templateElement) current.templateElement = element.querySelector('#template_component_gallery_item').children[0].cloneNode(true);

        var template = current.templateElement.cloneNode(true);

        template.setAttribute('data-path', path);
        template.classList.add('component-instance');

        template.children[0].children[0].setAttribute('src', path);
        template.children[0].children[0].setAttribute('alt', path);

        // Remove image
        template.children[1].addEventListener('click', function () {

            contentElement.removeChild(template);

            for (var i = 0; i < current.data[identifier].gallery.length; ++i) {

                if (current.data[identifier].gallery[i] === path) current.data[identifier].gallery.splice(i, 1);
            }
        });

        // Show image
        contentElement.appendChild(template);

        // Hide Media manager
        if (!outside) document.querySelector('div.media-manager span.close-manager').click();
    },

    create: function create(identifier, element) {

        var current = componentsModule.modules.gallery;

        componentsModule.initializeEvents([{
            // Open Media Manager
            event: 'click',
            element: element.querySelector('button.inline-image_manager'),
            content: function content() {

                managerActiveInstance = new MediaManager({
                    manager: 'images',

                    onSelect: function onSelect(path) {

                        current.onSelect(identifier, element, path, false);
                    }

                });
            }
        }, {
            // Enter custom URL to image
            event: 'keypress',
            element: element.querySelector('input[name=component_inline_picture_input]'),
            content: function content(event) {

                if (event.keyCode && event.keyCode === 13) {

                    var path = event.target.value.trim();

                    current.validateInput(identifier, element, path, current.onSelect);
                }
            }
        }, {
            // Validate image URL
            event: 'change keyup',
            element: element.querySelector('input[name=component_inline_picture_input]'),
            content: function content(event) {

                current.validateInput(identifier, element, event.target.value.trim());
            }
        }]);
    }

};

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.gallery = { data: {}, validate: function validate() {
    return true;
  }, serialize: function serialize() {
    return componentsModule.modules.gallery.data;
  }, resumeInline: function resumeInline(b, c, a) {
    var current = componentsModule.modules.gallery;current.create(b, c);a.gallery.forEach(function (d) {
      current.onSelect(b, c, d, true);
    });
  }, validateInput: function validateInput(a, b, c, d) {
    if (!/[(http(s)?):\/\/(www\.)?a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)/.test(c)) {
      showValidationResult(b, "COMPONENT_URL_INVALID", false, $.noop);return false;
    }var promise = new Promise(function (f, e) {
      var image = new Image();image.onload = function () {
        f(true);
      };image.onerror = function () {
        f(false);
      };image.src = c;
    });promise.then(function (e) {
      if (e) {
        showValidationResult(b, "", true, $.noop);if (d) {
          d(a, b, c, true);
        }return true;
      }showValidationResult(b, "COMPONENT_URL_INVALID", false, $.noop);
    });
  }, onSelect: function onSelect(a, b, d, c) {
    var current = componentsModule.modules.gallery;var contentElement = b.querySelector("div.gallery-items");contentElement.classList.remove("no-padding");if (!c) {
      d = "app/Data/Files/Images/" + d;
    }if (current.data[a]) {
      if (~current.data[a].gallery.indexOf(d)) {
        closeMediaManager();return false;
      }current.data[a].gallery.push(d);
    } else {
      current.data[a] = { title: "", gallery: [d], disabled: 0 };
    }if (!current.templateElement) {
      current.templateElement = b.querySelector("#template_component_gallery_item").children[0].cloneNode(true);
    }var template = current.templateElement.cloneNode(true);template.setAttribute("data-path", d);template.classList.add("component-instance");template.children[0].children[0].setAttribute("src", d);template.children[0].children[0].setAttribute("alt", d);template.children[1].addEventListener("click", function () {
      contentElement.removeChild(template);for (var i = 0; i < current.data[a].gallery.length; ++i) {
        if (current.data[a].gallery[i] === d) {
          current.data[a].gallery.splice(i, 1);
        }
      }
    });contentElement.appendChild(template);if (!c) {
      document.querySelector("div.media-manager span.close-manager").click();
    }
  }, create: function create(a, b) {
    var current = componentsModule.modules.gallery;componentsModule.initializeEvents([{ event: "click", element: b.querySelector("button.inline-image_manager"), content: function content() {
        managerActiveInstance = new MediaManager({ manager: "images", onSelect: function onSelect(c) {
            current.onSelect(a, b, c, false);
          } });
      } }, { event: "keypress", element: b.querySelector("input[name=component_inline_picture_input]"), content: function content(c) {
        if (c.keyCode && c.keyCode === 13) {
          var path = c.target.value.trim();current.validateInput(a, b, path, current.onSelect);
        }
      } }, { event: "change keyup", element: b.querySelector("input[name=component_inline_picture_input]"), content: function content(c) {
        current.validateInput(a, b, c.target.value.trim());
      } }]);
  } };

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.header_image = {

    start: function start() {

        // Save elements
        var current = componentsModule.modules.header_image;
        current.parentElement = document.querySelector('[data-component=header_image]');
        current.inputBox = current.parentElement.querySelector('.input-box');
        current.mediaButton = current.inputBox.querySelector('.image_manager');
        current.mediaInput = current.inputBox.querySelector('input');
        current.messageElement = current.inputBox.querySelector('.validate-message');
        current.templateElement = current.parentElement.querySelector('#template_component_header-image_image').childNodes[0];

        // Events
        componentsModule.initializeEvents([{
            // Delegate click events
            event: 'click',
            element: current.parentElement,
            content: function content(event) {

                // Open MediaManager
                if (event.target.matches('.image_manager')) {

                    managerActiveInstance = new MediaManager({
                        manager: 'images',
                        onSelect: function onSelect(path) {

                            current.addNew(path, false);
                        }
                    });
                }

                // Remove header image
                else if (event.target.matches('.header_image-remove')) {

                        current.inputBox.classList.remove('hide');

                        current.parentElement.removeChild(current.parentElement.querySelector('div.component-instance'));

                        reloadPackery();
                    }
            }
        }, {
            // Enter custom URL to image
            event: 'keypress',
            element: current.mediaInput,
            content: function content(event) {

                if (!event.keyCode || event.keyCode !== 13) return false;

                var path = event.target.value.trim();

                current.validateInput(path, function () {

                    current.addNew(path, true);
                });
            }
        }, {
            // Real-time URL validation
            event: 'change keyup',
            element: current.mediaInput,
            content: function content(event) {

                current.validateInput(event.target.value.trim());
            }
        }]);
    },

    resume: function resume() {

        // Save current instance
        var current = componentsModule.modules.header_image;
        var data = current.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var headerImage = JSON.parse(data).header_image;

        if (headerImage === '') return true;

        current.addNew(headerImage, !~headerImage.indexOf('app/Data/Files/Images/'));
    },

    removeCurrent: function removeCurrent(parent) {

        if (parent.querySelector('div.header_image-image.component-instance')) parent.removeChild(parent.querySelector('div.header_image-image.component-instance'));
    },

    // --------------------------------------------------------

    addNew: function addNew(path, outside) {

        path = path.replace('app/Data/Files/Images/', '');

        var current = componentsModule.modules.header_image;
        var text = path;
        var template = current.templateElement.cloneNode(true);

        current.removeCurrent(current.parentElement);
        current.inputBox.value = '';

        if (!outside) path = 'app/Data/Files/Images/' + path;

        template.setAttribute('data-path', path);
        template.classList.add('component-instance');

        template.childNodes[0].setAttribute('src', path);
        template.childNodes[0].setAttribute('alt', path);

        template.childNodes[1].innerText = text;

        current.parentElement.appendChild(template);

        current.inputBox.classList.add('hide');
        closeMediaManager();
        reloadPackery();
    },

    // ---------------------------------------

    validateInput: function validateInput(path, onSuccess, onError) {

        var current = componentsModule.modules.header_image;

        if (!validateUrl(path)) return showValidationResult(current.messageElement, 'COMPONENT_URL_INVALID', false, reloadPackery);

        new Promise(function (resolve) {

            var image = new Image();

            image.onload = function () {
                resolve(true);
            };

            image.onerror = function () {
                resolve(false);
            };

            image.src = path;
        }).then(function (result) {

            if (result) {

                showValidationResult(current.messageElement, 'COMPONENT_URL_INVALID', true, reloadPackery);

                if (onSuccess) onSuccess();
            } else {

                showValidationResult(current.messageElement, 'COMPONENT_URL_INVALID', false, reloadPackery);

                if (onError) onError();
            }
        });
    },

    validate: function validate() {

        return true;
    },

    serialize: function serialize() {

        var current = componentsModule.modules.header_image;
        var instance = current.parentElement.querySelector('div.header_image-image.component-instance');
        var data = '';

        if (instance) data = instance.getAttribute('data-path');

        return {
            header_image: data
        };
    }

};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.header_image = { start: function start() {
    var current = componentsModule.modules.header_image;current.parentElement = document.querySelector("[data-component=header_image]");current.inputBox = current.parentElement.querySelector(".input-box");current.mediaButton = current.inputBox.querySelector(".image_manager");current.mediaInput = current.inputBox.querySelector("input");current.messageElement = current.inputBox.querySelector(".validate-message");current.templateElement = current.parentElement.querySelector("#template_component_header-image_image").childNodes[0];componentsModule.initializeEvents([{ event: "click", element: current.parentElement, content: function content(a) {
        if (a.target.matches(".image_manager")) {
          managerActiveInstance = new MediaManager({ manager: "images", onSelect: function onSelect(b) {
              current.addNew(b, false);
            } });
        } else {
          if (a.target.matches(".header_image-remove")) {
            current.inputBox.classList.remove("hide");current.parentElement.removeChild(current.parentElement.querySelector("div.component-instance"));reloadPackery();
          }
        }
      } }, { event: "keypress", element: current.mediaInput, content: function content(a) {
        if (!a.keyCode || a.keyCode !== 13) {
          return false;
        }var path = a.target.value.trim();current.validateInput(path, function () {
          current.addNew(path, true);
        });
      } }, { event: "change keyup", element: current.mediaInput, content: function content(a) {
        current.validateInput(a.target.value.trim());
      } }]);
  }, resume: function resume() {
    var current = componentsModule.modules.header_image;var b = current.parentElement.getAttribute("data-resume");if (b === "") {
      return true;
    }var a = JSON.parse(b).header_image;if (a === "") {
      return true;
    }current.addNew(a, !~a.indexOf("app/Data/Files/Images/"));
  }, removeCurrent: function removeCurrent(a) {
    if (a.querySelector("div.header_image-image.component-instance")) {
      a.removeChild(a.querySelector("div.header_image-image.component-instance"));
    }
  }, addNew: function addNew(b, a) {
    b = b.replace("app/Data/Files/Images/", "");var current = componentsModule.modules.header_image;var text = b;var template = current.templateElement.cloneNode(true);current.removeCurrent(current.parentElement);current.inputBox.value = "";if (!a) {
      b = "app/Data/Files/Images/" + b;
    }template.setAttribute("data-path", b);template.classList.add("component-instance");template.childNodes[0].setAttribute("src", b);template.childNodes[0].setAttribute("alt", b);template.childNodes[1].innerText = text;current.parentElement.appendChild(template);current.inputBox.classList.add("hide");closeMediaManager();reloadPackery();
  }, validateInput: function validateInput(b, c, a) {
    var current = componentsModule.modules.header_image;if (!validateUrl(b)) {
      return showValidationResult(current.messageElement, "COMPONENT_URL_INVALID", false, reloadPackery);
    }new Promise(function (d) {
      var image = new Image();image.onload = function () {
        d(true);
      };image.onerror = function () {
        d(false);
      };image.src = b;
    }).then(function (d) {
      if (d) {
        showValidationResult(current.messageElement, "COMPONENT_URL_INVALID", true, reloadPackery);if (c) {
          c();
        }
      } else {
        showValidationResult(current.messageElement, "COMPONENT_URL_INVALID", false, reloadPackery);if (a) {
          a();
        }
      }
    });
  }, validate: function validate() {
    return true;
  }, serialize: function serialize() {
    var current = componentsModule.modules.header_image;var instance = current.parentElement.querySelector("div.header_image-image.component-instance");var data = "";if (instance) {
      data = instance.getAttribute("data-path");
    }return { header_image: data };
  } };

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.heading = {

    data: {},
    elements: {},

    start: function start() {

        // Save elements
        var current = componentsModule.modules.heading;
        current.templateElement = document.querySelector('#component_heading_template').children[0];
        current.resumeData = current.templateElement.getAttribute('data-resume');
    },

    resumeInline: function resumeInline(identifier, element, resumeData) {

        componentsModule.modules.heading.create(identifier, element, function (data, elements) {

            elements.inputElement.value = resumeData.value.trim();
            triggerEvent(elements.inputElement, 'change');

            elements.typeOptions[+resumeData.type - 1].click();
        });
    },

    create: function create(identifier, element, callback) {

        var current = componentsModule.modules.heading;

        current.data[identifier] = {
            title: '',
            type: '1',
            value: '',
            disabled: 0
        };

        current.elements[identifier] = {
            typeOptions: element.querySelectorAll('div.heading-types span'),
            inputElement: element.querySelector('input[name=component_inline_heading]')
        };

        var data = current.data[identifier];
        var elements = current.elements[identifier];

        componentsModule.initializeEvents([{
            // Serialize input element
            event: 'change keyup',
            element: elements.inputElement,
            content: function content(event) {

                data.value = event.target.value.trim();
            }
        }, {
            // Heading type switcher
            event: 'click',
            element: elements.typeOptions,
            content: function content(event) {

                elements.typeOptions.forEach(function (item) {
                    item.classList.remove('type-selected');
                });

                event.target.classList.add('type-selected');
                data.type = event.target.getAttribute('data-heading').trim();
            }
        }]);

        if (callback) callback(data, elements);
    },

    validate: function validate() {

        return true;
    },

    serialize: function serialize() {

        return componentsModule.modules.heading.data;
    }

};

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.heading = { data: {}, elements: {}, start: function start() {
    var current = componentsModule.modules.heading;current.templateElement = document.querySelector("#component_heading_template").children[0];current.resumeData = current.templateElement.getAttribute("data-resume");
  }, resumeInline: function resumeInline(b, c, a) {
    componentsModule.modules.heading.create(b, c, function (e, d) {
      d.inputElement.value = a.value.trim();triggerEvent(d.inputElement, "change");d.typeOptions[+a.type - 1].click();
    });
  }, create: function create(a, b, c) {
    var current = componentsModule.modules.heading;current.data[a] = { title: "", type: "1", value: "", disabled: 0 };current.elements[a] = { typeOptions: b.querySelectorAll("div.heading-types span"), inputElement: b.querySelector("input[name=component_inline_heading]") };var data = current.data[a];var elements = current.elements[a];componentsModule.initializeEvents([{ event: "change keyup", element: elements.inputElement, content: function content(d) {
        data.value = d.target.value.trim();
      } }, { event: "click", element: elements.typeOptions, content: function content(d) {
        elements.typeOptions.forEach(function (e) {
          e.classList.remove("type-selected");
        });d.target.classList.add("type-selected");data.type = d.target.getAttribute("data-heading").trim();
      } }]);if (c) {
      c(data, elements);
    }
  }, validate: function validate() {
    return true;
  }, serialize: function serialize() {
    return componentsModule.modules.heading.data;
  } };

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.languages = {

    start: function start() {

        // Load languages
        languages = getJson('app/Config/languages.json');
        var listElement = document.querySelector('div.languages-list');
        var targetSelect = document.querySelector('select[name=write_current_language]');

        var _loop = function _loop(abbr) {
            var template = document.querySelector('#template_component_languages_item').childNodes[0].cloneNode(true);
            var localeString = 'LANGUAGE_' + languages[abbr].toUpperCase().split(';')[0];
            template.setAttribute('data-language', abbr);
            template.childNodes[0].setAttribute('data-locale', localeString);
            template.childNodes[0].innerText = languages[abbr];
            listElement.appendChild(template);

            // Add language
            template.childNodes[1].addEventListener('click', function () {
                var currentOptions = targetSelect.children;
                for (var i = 0; i < currentOptions.length; ++i) {
                    if (currentOptions[i].getAttribute('data-locale') === localeString) return false;
                }var newOption = document.createElement('option');
                newOption.setAttribute('value', abbr);
                newOption.setAttribute('data-locale', localeString);
                newOption.innerText = languages[abbr];
                targetSelect.appendChild(newOption);
                selector.destroy();
                selector = new Selector({
                    selector: 'select.selector-search-select'
                });
                template.childNodes[1].classList.add('hide');
                template.childNodes[2].classList.remove('hide');
                if (componentsModule.modules.languages.data.languages.indexOf(abbr) === -1) componentsModule.modules.languages.data.languages.push(abbr);
                // ...
            });

            // Remove language
            template.childNodes[2].addEventListener('click', function () {
                var actionTextLocale = translate.locale.system[localeString];
                if (typeof actionTextLocale === 'undefined') actionTextLocale = languages[abbr];
                var actionText = translate.locale.response['ACTION_CONFIRM_REMOVE_LANGUAGE'].replace('%language%', actionTextLocale);
                confirmAction(actionText, function () {
                    var option = targetSelect.querySelector('option[data-locale=' + localeString + ']');
                    if (option.getAttribute('selected')) targetSelect.children[0].setAttribute('selected', 'true');
                    targetSelect.removeChild(option);
                    selector.destroy();
                    selector = new Selector({
                        selector: 'select.selector-search-select'
                    });
                    template.childNodes[2].classList.add('hide');
                    template.childNodes[1].classList.remove('hide');
                    if (componentsModule.modules.languages.data.languages.indexOf(abbr) !== -1) componentsModule.modules.languages.data.languages.splice(componentsModule.modules.languages.data.languages.indexOf(abbr), 1);
                    // ...
                });
            });
        };

        for (var abbr in languages) {
            _loop(abbr);
        }

        translate.addTranslation(['system']);
    },

    data: {
        languages: []
    },

    validate: function validate() {},

    serialize: function serialize() {
        return componentsModule.modules.languages.data.languages;
    },

    events: [{
        // Search in languages list
        event: "change keyup",
        element: document.querySelector('input[name=component_language_search]'),
        content: function content(event) {
            var searchPhrase = event.target.value.toLowerCase();
            var searchPhraseLength = searchPhrase.length;
            var listElements = document.querySelector('div.languages-list').childNodes;
            var listElementsLength = listElements.length;
            // Search by abbr
            if (searchPhraseLength < 3) {
                for (var i = 0; i < listElementsLength; ++i) {
                    var abbr = listElements[i].getAttribute('data-language').substring(0, searchPhraseLength).toLowerCase();
                    if (abbr === searchPhrase) listElements[i].classList.remove('hide');else listElements[i].classList.add('hide');
                }
                packery.packery().reloadItems();
                return true;
            }
            // Search by name
            for (var _i = 0; _i < listElementsLength; ++_i) {
                var _abbr = listElements[_i].childNodes[0].innerText.substring(0, searchPhraseLength).toLowerCase();
                if (_abbr === searchPhrase) listElements[_i].classList.remove('hide');else listElements[_i].classList.add('hide');
            }
            packery.packery().reloadItems();
        }
    }]

};

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.languages = { start: function start() {
    languages = getJson("app/Config/languages.json");var listElement = document.querySelector("div.languages-list");var targetSelect = document.querySelector("select[name=write_current_language]");
    var _loop = function _loop(abbr) {
      var template = document.querySelector("#template_component_languages_item").childNodes[0].cloneNode(true);var localeString = "LANGUAGE_" + languages[abbr].toUpperCase().split(";")[0];template.setAttribute("data-language", abbr);template.childNodes[0].setAttribute("data-locale", localeString);template.childNodes[0].innerText = languages[abbr];listElement.appendChild(template);template.childNodes[1].addEventListener("click", function () {
        var currentOptions = targetSelect.children;for (var i = 0; i < currentOptions.length; ++i) {
          if (currentOptions[i].getAttribute("data-locale") === localeString) {
            return false;
          }
        }var newOption = document.createElement("option");newOption.setAttribute("value", abbr);newOption.setAttribute("data-locale", localeString);newOption.innerText = languages[abbr];targetSelect.appendChild(newOption);selector.destroy();selector = new Selector({ selector: "select.selector-search-select" });template.childNodes[1].classList.add("hide");template.childNodes[2].classList.remove("hide");if (componentsModule.modules.languages.data.languages.indexOf(abbr) === -1) {
          componentsModule.modules.languages.data.languages.push(abbr);
        }
      });template.childNodes[2].addEventListener("click", function () {
        var actionTextLocale = translate.locale.system[localeString];if (typeof actionTextLocale === "undefined") {
          actionTextLocale = languages[abbr];
        }var actionText = translate.locale.response.ACTION_CONFIRM_REMOVE_LANGUAGE.replace("%language%", actionTextLocale);confirmAction(actionText, function () {
          var option = targetSelect.querySelector("option[data-locale=" + localeString + "]");if (option.getAttribute("selected")) {
            targetSelect.children[0].setAttribute("selected", "true");
          }targetSelect.removeChild(option);selector.destroy();selector = new Selector({ selector: "select.selector-search-select" });template.childNodes[2].classList.add("hide");template.childNodes[1].classList.remove("hide");if (componentsModule.modules.languages.data.languages.indexOf(abbr) !== -1) {
            componentsModule.modules.languages.data.languages.splice(componentsModule.modules.languages.data.languages.indexOf(abbr), 1);
          }
        });
      });
    };

    for (var abbr in languages) {
      _loop(abbr);
    }translate.addTranslation(["system"]);
  }, data: { languages: [] }, validate: function validate() {}, serialize: function serialize() {
    return componentsModule.modules.languages.data.languages;
  }, events: [{ event: "change keyup", element: document.querySelector("input[name=component_language_search]"), content: function content(a) {
      var searchPhrase = a.target.value.toLowerCase();var searchPhraseLength = searchPhrase.length;var listElements = document.querySelector("div.languages-list").childNodes;var listElementsLength = listElements.length;if (searchPhraseLength < 3) {
        for (var i = 0; i < listElementsLength; ++i) {
          var abbr = listElements[i].getAttribute("data-language").substring(0, searchPhraseLength).toLowerCase();if (abbr === searchPhrase) {
            listElements[i].classList.remove("hide");
          } else {
            listElements[i].classList.add("hide");
          }
        }packery.packery().reloadItems();return true;
      }for (var _i = 0; _i < listElementsLength; ++_i) {
        var _abbr = listElements[_i].childNodes[0].innerText.substring(0, searchPhraseLength).toLowerCase();if (_abbr === searchPhrase) {
          listElements[_i].classList.remove("hide");
        } else {
          listElements[_i].classList.add("hide");
        }
      }packery.packery().reloadItems();
    } }] };

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.last_update = {

    start: function start() {

        // Save elements
        var current = componentsModule.modules.last_update;
        current.parentElement = document.querySelector('[data-component=last_update]');
        current.customCheck = current.parentElement.querySelector('[name=component_last-update]');
        current.dateBox = current.parentElement.querySelector('.component_last_custom');
        current.dateInput = current.dateBox.querySelector('input');
        current.clearInput = current.dateBox.querySelector('.clear-input');

        current.customCheck.checked = false;

        // Events
        componentsModule.initializeEvents([{
            // Show / Hide custom input
            event: 'change',
            element: current.customCheck,
            content: function content() {

                if (!!current.customCheck.checked) current.dateBox.classList.remove('hide');else current.dateBox.classList.add('hide');

                reloadPackery();
            }
        }, {
            // Clear input
            event: 'click',
            element: current.clearInput,
            content: function content() {

                current.dateInput.value = '';
            }
        }]);
    },

    resume: function resume() {

        // Save current instance
        var current = componentsModule.modules.last_update;
        var data = current.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        current.dateInput.value = JSON.parse(data).last_update;
    },

    validate: function validate() {

        return true;
    },

    serialize: function serialize() {

        var current = componentsModule.modules.last_update;
        var isCustom = !!current.customCheck.checked;
        var data = false;

        if (isCustom && current.dateInput.value !== '') data = current.dateInput.value.trim();

        return {

            last_update: data

        };
    }

};

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.last_update = { start: function start() {
    var current = componentsModule.modules.last_update;current.parentElement = document.querySelector("[data-component=last_update]");current.customCheck = current.parentElement.querySelector("[name=component_last-update]");current.dateBox = current.parentElement.querySelector(".component_last_custom");current.dateInput = current.dateBox.querySelector("input");current.clearInput = current.dateBox.querySelector(".clear-input");current.customCheck.checked = false;componentsModule.initializeEvents([{ event: "change", element: current.customCheck, content: function content() {
        if (!!current.customCheck.checked) {
          current.dateBox.classList.remove("hide");
        } else {
          current.dateBox.classList.add("hide");
        }reloadPackery();
      } }, { event: "click", element: current.clearInput, content: function content() {
        current.dateInput.value = "";
      } }]);
  }, resume: function resume() {
    var current = componentsModule.modules.last_update;var a = current.parentElement.getAttribute("data-resume");if (a === "") {
      return true;
    }current.dateInput.value = JSON.parse(a).last_update;
  }, validate: function validate() {
    return true;
  }, serialize: function serialize() {
    var current = componentsModule.modules.last_update;var a = !!current.customCheck.checked;var data = false;if (a && current.dateInput.value !== "") {
      data = current.dateInput.value.trim();
    }return { last_update: data };
  } };

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.link = {

    data: {},

    resumeInline: function resumeInline(identifier, element, resumeData) {

        componentsModule.modules.link.create(identifier, element, resumeData);
    },

    createSelector: function createSelector(identifier, current) {

        setTimeout(function () {

            new Selector({

                selector: 'select[name="' + identifier + '"]',

                onSelect: function onSelect(instance, option) {

                    current.data[identifier].link_target = +option.getAttribute('data-item').trim();
                }

            });
        });
    },

    create: function create(identifier, element, resumeData) {

        var current = componentsModule.modules.link;

        // Initialize Data
        current.data[identifier] = {
            title: '',
            link: '',
            link_text: '',
            link_position: 1,
            link_target: 0,
            disabled: 0
        };

        var select = element.querySelector('select[name=component_inline_link_target]');
        var positionItems = element.querySelectorAll('span.position-item');
        var linkInput = element.querySelector('input[name=component_inline_link_url]');
        var linkName = element.querySelector('input[name=component_inline_link_name]');

        if (resumeData) {

            if (resumeData.link) current.data[identifier].link = linkInput.value = resumeData.link.trim();

            if (resumeData.link_text) current.data[identifier].link_text = linkName.value = resumeData.link_text.trim();

            if (resumeData.link_position !== undefined) {

                current.data[identifier].link_position = resumeData.link_position;

                positionItems.forEach(function (item) {

                    if (item.matches('[data-position="' + resumeData.link_position + '"]')) {

                        item.classList.add('active');
                        return true;
                    }

                    item.classList.remove('active');
                });
            }

            if (resumeData.link_target !== undefined) {

                var selected = select.querySelector('[selected]');

                selected.removeAttribute('selected');
                select.children[resumeData.link_target].setAttribute('selected', 'true');
            }
        }

        // Initialize target Selector
        select.setAttribute('name', identifier);
        current.createSelector(identifier, current);

        componentsModule.initializeEvents([{
            // Serialize link
            event: 'change keyup',
            element: linkInput,
            content: function content(event) {

                current.data[identifier].link = event.target.value.trim();
            }
        }, {
            // Serialize link text
            event: 'change keyup',
            element: linkName,
            content: function content(event) {

                current.data[identifier].link_text = event.target.value.trim();
            }
        }, {
            // Serialize position component
            event: 'click',
            element: positionItems,
            content: function content(event) {

                current.data[identifier].link_position = event.target.getAttribute('data-position');

                positionItems.forEach(function (item) {
                    item.classList.remove('active');
                });

                event.target.classList.add('active');
            }
        }]);
    },

    validate: function validate() {
        return true;
    },

    serialize: function serialize() {
        return componentsModule.modules.link.data;
    }

};

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.link = { data: {}, resumeInline: function resumeInline(b, c, a) {
    componentsModule.modules.link.create(b, c, a);
  }, createSelector: function createSelector(a, b) {
    setTimeout(function () {
      new Selector({ selector: 'select[name="' + a + '"]', onSelect: function onSelect(c, d) {
          b.data[a].link_target = +d.getAttribute("data-item").trim();
        } });
    });
  }, create: function create(b, c, a) {
    var current = componentsModule.modules.link;current.data[b] = { title: "", link: "", link_text: "", link_position: 1, link_target: 0, disabled: 0 };var select = c.querySelector("select[name=component_inline_link_target]");var positionItems = c.querySelectorAll("span.position-item");var linkInput = c.querySelector("input[name=component_inline_link_url]");var linkName = c.querySelector("input[name=component_inline_link_name]");if (a) {
      if (a.link) {
        current.data[b].link = linkInput.value = a.link.trim();
      }if (a.link_text) {
        current.data[b].link_text = linkName.value = a.link_text.trim();
      }if (a.link_position !== undefined) {
        current.data[b].link_position = a.link_position;positionItems.forEach(function (d) {
          if (d.matches('[data-position="' + a.link_position + '"]')) {
            d.classList.add("active");return true;
          }d.classList.remove("active");
        });
      }if (a.link_target !== undefined) {
        var selected = select.querySelector("[selected]");selected.removeAttribute("selected");select.children[a.link_target].setAttribute("selected", "true");
      }
    }select.setAttribute("name", b);current.createSelector(b, current);componentsModule.initializeEvents([{ event: "change keyup", element: linkInput, content: function content(d) {
        current.data[b].link = d.target.value.trim();
      } }, { event: "change keyup", element: linkName, content: function content(d) {
        current.data[b].link_text = d.target.value.trim();
      } }, { event: "click", element: positionItems, content: function content(d) {
        current.data[b].link_position = d.target.getAttribute("data-position");positionItems.forEach(function (e) {
          e.classList.remove("active");
        });d.target.classList.add("active");
      } }]);
  }, validate: function validate() {
    return true;
  }, serialize: function serialize() {
    return componentsModule.modules.link.data;
  } };

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.list = {

    data: {},
    itemClone: false,

    validate: function validate() {
        return true;
    },

    serialize: function serialize() {
        return componentsModule.modules.list.data;
    },

    resumeInline: function resumeInline(identifier, element, resumeData) {

        var current = componentsModule.modules.list;
        var listElement = current.create(identifier, element, resumeData);

        resumeData.list.forEach(function (listItem, index) {

            if (listItem === '') return true;

            var checked = resumeData.list_checked[index] || 0;

            current.createItem(identifier, listElement, undefined, false, [listItem.trim(), checked]);
        });

        if (current.data[identifier].list.length < 1) current.createItem(identifier, listElement);
    },

    reloadItems: function reloadItems(identifier, listElement) {

        var newOrder = [];
        var newContent = [];
        var newChecked = [];
        var current = componentsModule.modules.list;

        listElement.querySelectorAll('.list-item').forEach(function (item, key) {
            newOrder.push(parseFloat(item.getAttribute('data-item')));
            item.querySelector('.item-number').innerText = +key + 1 + '.';
            var text = item.querySelector('p').innerText.trim();
            if (text === current.itemClone.querySelector('p').innerText.trim()) text = '';
            newContent.push(text);
            newChecked.push(item.querySelector('.item-check').classList.contains('checked'));
        });

        current.data[identifier].list = newContent;
        current.data[identifier].list_checked = newChecked;
        current.data[identifier].order = newOrder;
    },

    createItem: function createItem(identifier, listElement, after, focus, data) {

        if (!data) data = [];

        var current = componentsModule.modules.list;
        var itemID = Math.random() * (99999 - 10000) + 10000;

        // Create item data
        var index = void 0;
        var checked = data[1] || false;
        var value = data[0] || '';

        if (!after) {

            current.data[identifier].list.push(value);
            current.data[identifier].list_checked.push(checked);
            current.data[identifier].order.push(itemID);
            index = +current.data[identifier].order.indexOf(itemID);
        } else {

            index = +current.data[identifier].order.indexOf(after);

            if (index === -1) return false;

            index += 1;
            current.data[identifier].list.splice(index, 0, value);
            current.data[identifier].list_checked.splice(index, 0, checked);
            current.data[identifier].order.splice(index, 0, itemID);
        }

        // Create item clone
        var itemElement = current.itemClone.cloneNode(true);
        itemElement.setAttribute('data-item', itemID.toString());
        itemElement.querySelector('.item-number').innerText = +index + 1 + '.';

        var itemText = itemElement.querySelector('p');
        var itemCheck = itemElement.querySelector('.item-check');

        // Create item events
        componentsModule.initializeEvents([{
            // Check item
            event: 'click',
            element: itemCheck,
            content: function content(event) {
                event.target.classList.toggle('checked');
                var index = current.data[identifier].order.indexOf(itemID);
                current.data[identifier].list_checked[index] = event.target.classList.contains('checked');
            }
        }, {
            // Focus hide placeholder
            event: 'focus',
            element: itemText,
            content: function content(event) {

                var target = event.target;

                if (target.innerText.trim() !== current.itemClone.querySelector('p').innerText) return false;

                target.classList.remove('item-text-placeholder');
                target.innerText = '';
            }
        }, {
            // Blur add placeholder
            event: 'blur',
            element: itemText,
            content: function content(event) {

                var target = event.target;
                var nextItem = target.parentNode.nextSibling;

                if (target.innerText.trim() !== '' && nextItem === null) current.createItem(identifier, listElement, itemID, true);

                if (target.innerText.trim() !== '') return false;

                target.classList.add('item-text-placeholder');
                target.innerText = current.itemClone.querySelector('p').innerText;
            }
        }, {
            // Add item after
            event: 'keydown',
            element: itemText,
            content: function content(event) {

                if (event.keyCode !== 13) return false;

                var currentItem = event.target.parentNode;
                var nextItem = currentItem.nextSibling;

                if (nextItem !== null) nextItem.querySelector('p').focus();else event.target.blur();

                event.preventDefault();
            }
        }, {
            // Serialize item
            event: 'keyup change',
            element: itemText,
            content: function content(event) {

                current.data[identifier].list[index] = event.target.innerText.trim();
            }
        }, {
            // Delete item
            event: 'click',
            element: itemElement.querySelector('.list-item-delete'),
            content: function content() {

                if (listElement.children.length < 2) return false;

                var index = current.data[identifier].order.indexOf(itemID);

                if (index === -1) return false;

                current.data[identifier].list.splice(index, 1);
                current.data[identifier].order.splice(index, 1);
                current.data[identifier].list_checked.splice(index, 1);

                listElement.removeChild(itemElement);
                current.reloadItems(identifier, listElement);
            }
        }]);

        // Show item
        if (!after) listElement.appendChild(itemElement);else {

            if (!current.data[identifier].order[index + 1]) listElement.appendChild(itemElement);else listElement.insertBefore(itemElement, listElement.children[index + 1]);
        }

        // Resume data
        itemText.innerText = data[0] || itemText.innerText;

        if (data[0] !== undefined) itemText.classList.remove('item-text-placeholder');

        if (data[1] === 1) itemCheck.click();

        // Focus
        if (focus) itemText.focus();
    },

    create: function create(identifier, element, resumeData) {

        var current = componentsModule.modules.list;
        var contentElement = element.querySelector('.component-element-content');
        var listElement = contentElement.querySelector('.component-inline-list-content');
        var listItem = listElement.querySelector('.list-item');

        if (!current.itemClone) current.itemClone = listItem.cloneNode(true);
        listElement.removeChild(listItem);

        // Data
        current.data[identifier] = {
            title: '',
            disabled: 0,
            list: [],
            order: [],
            list_checked: [],
            list_title: '',
            list_type: 0,
            list_position: 1
        };

        // Drag & Drop
        Sortable.create(listElement, {
            sort: true,
            animation: 200,
            scroll: false,
            draggable: '.list-item',
            handle: '.list-item-move',
            onStart: function onStart(event) {
                event.item.classList.add('chosen');
            },
            onEnd: function onEnd(event) {
                event.item.classList.remove('chosen');
                current.reloadItems(identifier, listElement);
            }
        });

        // Events
        var typeItems = contentElement.querySelectorAll('.component-list_type .position-item');
        var positionItems = contentElement.querySelectorAll('.component-list_align .position-item');
        var nameInput = contentElement.querySelector('input[name=component_inline_list_name]');

        componentsModule.initializeEvents([{
            // Serialize list title
            event: 'change keyup',
            element: nameInput,
            content: function content(event) {
                current.data[identifier].list_title = event.target.value.trim();
            }
        }, {
            // Serialize list type
            event: 'click',
            element: typeItems,
            content: function content(event) {
                listElement.setAttribute('data-type', current.data[identifier].list_type = event.target.getAttribute('data-position'));
                typeItems.forEach(function (item) {
                    item.classList.remove('active');
                });
                event.target.classList.add('active');
            }
        }, {
            // Serialize list align
            event: 'click',
            element: positionItems,
            content: function content(event) {
                current.data[identifier].list_position = event.target.getAttribute('data-position');
                positionItems.forEach(function (item) {
                    item.classList.remove('active');
                });
                event.target.classList.add('active');
            }
        }]);

        if (resumeData !== undefined) {

            nameInput.value = resumeData.list_title.trim();
            triggerEvent(nameInput, 'change');

            typeItems[+resumeData.list_type].click();
            positionItems[+resumeData.list_position].click();
        }

        // First item
        if (!resumeData) current.createItem(identifier, listElement);

        return listElement;
    }

};

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.list = { data: {}, itemClone: false, validate: function validate() {
    return true;
  }, serialize: function serialize() {
    return componentsModule.modules.list.data;
  }, resumeInline: function resumeInline(b, c, a) {
    var current = componentsModule.modules.list;var listElement = current.create(b, c, a);a.list.forEach(function (f, d) {
      if (f === "") {
        return true;
      }var e = a.list_checked[d] || 0;current.createItem(b, listElement, undefined, false, [f.trim(), e]);
    });if (current.data[b].list.length < 1) {
      current.createItem(b, listElement);
    }
  }, reloadItems: function reloadItems(a, b) {
    var newOrder = [];var newContent = [];var newChecked = [];var current = componentsModule.modules.list;b.querySelectorAll(".list-item").forEach(function (d, c) {
      newOrder.push(parseFloat(d.getAttribute("data-item")));d.querySelector(".item-number").innerText = +c + 1 + ".";var text = d.querySelector("p").innerText.trim();if (text === current.itemClone.querySelector("p").innerText.trim()) {
        text = "";
      }newContent.push(text);newChecked.push(d.querySelector(".item-check").classList.contains("checked"));
    });current.data[a].list = newContent;current.data[a].list_checked = newChecked;current.data[a].order = newOrder;
  }, createItem: function createItem(b, c, g, a, f) {
    if (!f) {
      f = [];
    }var current = componentsModule.modules.list;var itemID = Math.random() * (99999 - 10000) + 10000;var index = void 0;var d = f[1] || false;var e = f[0] || "";if (!g) {
      current.data[b].list.push(e);current.data[b].list_checked.push(d);current.data[b].order.push(itemID);index = +current.data[b].order.indexOf(itemID);
    } else {
      index = +current.data[b].order.indexOf(g);if (index === -1) {
        return false;
      }index += 1;current.data[b].list.splice(index, 0, e);current.data[b].list_checked.splice(index, 0, d);current.data[b].order.splice(index, 0, itemID);
    }var itemElement = current.itemClone.cloneNode(true);itemElement.setAttribute("data-item", itemID.toString());itemElement.querySelector(".item-number").innerText = +index + 1 + ".";var itemText = itemElement.querySelector("p");var itemCheck = itemElement.querySelector(".item-check");componentsModule.initializeEvents([{ event: "click", element: itemCheck, content: function content(h) {
        h.target.classList.toggle("checked");var index = current.data[b].order.indexOf(itemID);current.data[b].list_checked[index] = h.target.classList.contains("checked");
      } }, { event: "focus", element: itemText, content: function content(h) {
        var target = h.target;if (target.innerText.trim() !== current.itemClone.querySelector("p").innerText) {
          return false;
        }target.classList.remove("item-text-placeholder");target.innerText = "";
      } }, { event: "blur", element: itemText, content: function content(h) {
        var target = h.target;var nextItem = target.parentNode.nextSibling;if (target.innerText.trim() !== "" && nextItem === null) {
          current.createItem(b, c, itemID, true);
        }if (target.innerText.trim() !== "") {
          return false;
        }target.classList.add("item-text-placeholder");target.innerText = current.itemClone.querySelector("p").innerText;
      } }, { event: "keydown", element: itemText, content: function content(h) {
        if (h.keyCode !== 13) {
          return false;
        }var currentItem = h.target.parentNode;var nextItem = currentItem.nextSibling;if (nextItem !== null) {
          nextItem.querySelector("p").focus();
        } else {
          h.target.blur();
        }h.preventDefault();
      } }, { event: "keyup change", element: itemText, content: function content(h) {
        current.data[b].list[index] = h.target.innerText.trim();
      } }, { event: "click", element: itemElement.querySelector(".list-item-delete"), content: function content() {
        if (c.children.length < 2) {
          return false;
        }var index = current.data[b].order.indexOf(itemID);if (index === -1) {
          return false;
        }current.data[b].list.splice(index, 1);current.data[b].order.splice(index, 1);current.data[b].list_checked.splice(index, 1);c.removeChild(itemElement);current.reloadItems(b, c);
      } }]);if (!g) {
      c.appendChild(itemElement);
    } else {
      if (!current.data[b].order[index + 1]) {
        c.appendChild(itemElement);
      } else {
        c.insertBefore(itemElement, c.children[index + 1]);
      }
    }itemText.innerText = f[0] || itemText.innerText;if (f[0] !== undefined) {
      itemText.classList.remove("item-text-placeholder");
    }if (f[1] === 1) {
      itemCheck.click();
    }if (a) {
      itemText.focus();
    }
  }, create: function create(b, c, a) {
    var current = componentsModule.modules.list;var contentElement = c.querySelector(".component-element-content");var listElement = contentElement.querySelector(".component-inline-list-content");var listItem = listElement.querySelector(".list-item");if (!current.itemClone) {
      current.itemClone = listItem.cloneNode(true);
    }listElement.removeChild(listItem);current.data[b] = { title: "", disabled: 0, list: [], order: [], list_checked: [], list_title: "", list_type: 0, list_position: 1 };Sortable.create(listElement, { sort: true, animation: 200, scroll: false, draggable: ".list-item", handle: ".list-item-move", onStart: function onStart(d) {
        d.item.classList.add("chosen");
      }, onEnd: function onEnd(d) {
        d.item.classList.remove("chosen");current.reloadItems(b, listElement);
      } });var typeItems = contentElement.querySelectorAll(".component-list_type .position-item");var positionItems = contentElement.querySelectorAll(".component-list_align .position-item");var nameInput = contentElement.querySelector("input[name=component_inline_list_name]");componentsModule.initializeEvents([{ event: "change keyup", element: nameInput, content: function content(d) {
        current.data[b].list_title = d.target.value.trim();
      } }, { event: "click", element: typeItems, content: function content(d) {
        listElement.setAttribute("data-type", current.data[b].list_type = d.target.getAttribute("data-position"));typeItems.forEach(function (e) {
          e.classList.remove("active");
        });d.target.classList.add("active");
      } }, { event: "click", element: positionItems, content: function content(d) {
        current.data[b].list_position = d.target.getAttribute("data-position");positionItems.forEach(function (e) {
          e.classList.remove("active");
        });d.target.classList.add("active");
      } }]);if (a !== undefined) {
      nameInput.value = a.list_title.trim();triggerEvent(nameInput, "change");typeItems[+a.list_type].click();positionItems[+a.list_position].click();
    }if (!a) {
      current.createItem(b, listElement);
    }return listElement;
  } };

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.meta = {

    start: function start() {

        // Save elements
        var current = componentsModule.modules.meta;
        current.parentElement = document.querySelector('[data-component=meta]');
        current.customCheck = current.parentElement.querySelector('[name=component_meta_manually]');
        current.customBox = current.parentElement.querySelector('.component_meta_custom');
        current.keyInput = current.parentElement.querySelector('[name=component_meta_keywords]');
        current.descInput = current.parentElement.querySelector('[name=component_meta_description]');
        current.robotsSelect = current.parentElement.querySelector('[name=component_meta_robots]');

        current.customCheck.checked = false;

        // Selector
        current.selector = current.createSelector();

        // Events
        componentsModule.initializeEvent({

            event: 'change',
            element: current.customCheck,
            content: function content() {

                if (current.customCheck.checked) current.customBox.classList.remove('hide');else current.customBox.classList.add('hide');

                reloadPackery();
            }

        });
    },

    createSelector: function createSelector() {

        return new Selector({
            selector: '[name=component_meta_robots]',
            onOpen: reloadPackery,
            onClose: reloadPackery
        });
    },

    resume: function resume() {

        // Save current instance
        var current = componentsModule.modules.meta;
        var data = current.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var meta = JSON.parse(data);

        current.customCheck.checked = !!meta.meta;
        triggerEvent(current.customCheck, 'change');

        current.keyInput.value = meta.meta_keywords.trim();
        current.descInput.value = meta.meta_description.trim();

        var selectOptions = current.robotsSelect.querySelectorAll('option');

        Object.values(selectOptions).forEach(function (selectOption, index) {

            if (index !== meta.meta_robots) selectOption.removeAttribute('selected');else selectOption.setAttribute('selected', 'true');
        });

        current.selector.destroy();
        current.selector = current.createSelector();
    },

    validate: function validate() {

        return true;
    },

    serialize: function serialize() {

        var current = componentsModule.modules.meta;

        return {

            meta: !!current.customCheck.checked,
            meta_keywords: current.keyInput.value.trim(),
            meta_description: current.descInput.value.trim(),
            meta_robots: parseInt(current.robotsSelect.querySelector('[selected=true]').getAttribute('value'))

        };
    }

};

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.meta = { start: function start() {
    var current = componentsModule.modules.meta;current.parentElement = document.querySelector("[data-component=meta]");current.customCheck = current.parentElement.querySelector("[name=component_meta_manually]");current.customBox = current.parentElement.querySelector(".component_meta_custom");current.keyInput = current.parentElement.querySelector("[name=component_meta_keywords]");current.descInput = current.parentElement.querySelector("[name=component_meta_description]");current.robotsSelect = current.parentElement.querySelector("[name=component_meta_robots]");current.customCheck.checked = false;current.selector = current.createSelector();componentsModule.initializeEvent({ event: "change", element: current.customCheck, content: function content() {
        if (current.customCheck.checked) {
          current.customBox.classList.remove("hide");
        } else {
          current.customBox.classList.add("hide");
        }reloadPackery();
      } });
  }, createSelector: function createSelector() {
    return new Selector({ selector: "[name=component_meta_robots]", onOpen: reloadPackery, onClose: reloadPackery });
  }, resume: function resume() {
    var current = componentsModule.modules.meta;var a = current.parentElement.getAttribute("data-resume");if (a === "") {
      return true;
    }var b = JSON.parse(a);current.customCheck.checked = !!b.meta;triggerEvent(current.customCheck, "change");current.keyInput.value = b.meta_keywords.trim();current.descInput.value = b.meta_description.trim();var selectOptions = current.robotsSelect.querySelectorAll("option");Object.values(selectOptions).forEach(function (c, d) {
      if (d !== b.meta_robots) {
        c.removeAttribute("selected");
      } else {
        c.setAttribute("selected", "true");
      }
    });current.selector.destroy();current.selector = current.createSelector();
  }, validate: function validate() {
    return true;
  }, serialize: function serialize() {
    var current = componentsModule.modules.meta;return { meta: !!current.customCheck.checked, meta_keywords: current.keyInput.value.trim(), meta_description: current.descInput.value.trim(), meta_robots: parseInt(current.robotsSelect.querySelector("[selected=true]").getAttribute("value")) };
  } };

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.mistakes = {

    start: function start() {

        // Save elements
        var current = componentsModule.modules.mistakes;
        current.parentElement = document.querySelector('[data-component=mistakes]');
        current.enableCheck = current.parentElement.querySelector('[name=component_mistakes]');
        current.notifyBox = current.parentElement.querySelector('.component_mistakes_notify');
        current.notifyCheck = current.notifyBox.querySelector('[name=component_mistakes_notify]');
        current.emailBox = current.notifyBox.querySelector('div');
        current.emailCheck = current.emailBox.querySelector('input');

        // Delegate change event
        componentsModule.initializeEvent({

            event: 'change',
            element: current.parentElement,
            content: function content(event) {

                var target = event.target;

                // Show notifications settings
                if (target === current.enableCheck) {

                    if (!!target.checked) current.notifyBox.classList.remove('hide');else current.notifyBox.classList.add('hide');

                    reloadPackery();
                }

                // Show email notifications settings
                else if (target === current.notifyCheck) {

                        if (!!target.checked) current.emailBox.classList.remove('hide');else current.emailBox.classList.add('hide');

                        reloadPackery();
                    }
            }

        });
    },

    resume: function resume() {

        // Save current instance
        var current = componentsModule.modules.mistakes;
        var data = current.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var mistakes = JSON.parse(data);

        current.enableCheck.checked = !!mistakes.mistakes;
        triggerEvent(current.enableCheck, 'change');

        current.emailCheck.checked = !!mistakes.mistakes_email;

        current.notifyCheck.checked = !!mistakes.mistakes_notify;
        triggerEvent(current.notifyCheck, 'change');
    },

    validate: function validate() {

        return true;
    },

    serialize: function serialize() {

        var current = componentsModule.modules.mistakes;

        return {

            mistakes: !!current.enableCheck.checked,
            mistakes_notify: !!current.notifyCheck.checked,
            mistakes_email: !!current.emailCheck.checked

        };
    }

};

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.mistakes = { start: function start() {
    var current = componentsModule.modules.mistakes;current.parentElement = document.querySelector("[data-component=mistakes]");current.enableCheck = current.parentElement.querySelector("[name=component_mistakes]");current.notifyBox = current.parentElement.querySelector(".component_mistakes_notify");current.notifyCheck = current.notifyBox.querySelector("[name=component_mistakes_notify]");current.emailBox = current.notifyBox.querySelector("div");current.emailCheck = current.emailBox.querySelector("input");componentsModule.initializeEvent({ event: "change", element: current.parentElement, content: function content(a) {
        var target = a.target;if (target === current.enableCheck) {
          if (!!target.checked) {
            current.notifyBox.classList.remove("hide");
          } else {
            current.notifyBox.classList.add("hide");
          }reloadPackery();
        } else {
          if (target === current.notifyCheck) {
            if (!!target.checked) {
              current.emailBox.classList.remove("hide");
            } else {
              current.emailBox.classList.add("hide");
            }reloadPackery();
          }
        }
      } });
  }, resume: function resume() {
    var current = componentsModule.modules.mistakes;var a = current.parentElement.getAttribute("data-resume");if (a === "") {
      return true;
    }var b = JSON.parse(a);current.enableCheck.checked = !!b.mistakes;triggerEvent(current.enableCheck, "change");current.emailCheck.checked = !!b.mistakes_email;current.notifyCheck.checked = !!b.mistakes_notify;triggerEvent(current.notifyCheck, "change");
  }, validate: function validate() {
    return true;
  }, serialize: function serialize() {
    var current = componentsModule.modules.mistakes;return { mistakes: !!current.enableCheck.checked, mistakes_notify: !!current.notifyCheck.checked, mistakes_email: !!current.emailCheck.checked };
  } };

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.note = {

    data: {},

    resumeInline: function resumeInline(identifier, element, resumeData) {

        componentsModule.modules.note.create(identifier, element, resumeData);
    },

    validate: function validate() {
        return true;
    },

    serialize: function serialize() {
        return componentsModule.modules.note.data;
    },

    create: function create(identifier, element, resumeData) {

        var current = componentsModule.modules.note;
        var positionItems = element.querySelectorAll('span.position-item');
        var textarea = element.querySelector('textarea[name=component_inline_note]');

        current.data[identifier] = {
            title: '',
            note: '',
            note_position: 1,
            disabled: 0
        };

        componentsModule.initializeEvents([{
            // Serialize textarea
            event: 'change keyup',
            element: textarea,
            content: function content(event) {
                current.data[identifier].note = event.target.value.trim();
            }
        }, {
            // Serialize position
            event: 'click',
            element: positionItems,
            content: function content(event) {
                current.data[identifier].note_position = event.target.getAttribute('data-position');
                positionItems.forEach(function (item) {
                    item.classList.remove('active');
                });
                event.target.classList.add('active');
            }
        }]);

        if (resumeData) {

            if (resumeData.note) {

                textarea.value = resumeData.note.trim();
                triggerEvent(textarea, 'change');
            }

            if (resumeData.note_position !== undefined) positionItems[resumeData.note_position].click();
        }
    }

};

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.note = { data: {}, resumeInline: function resumeInline(b, c, a) {
    componentsModule.modules.note.create(b, c, a);
  }, validate: function validate() {
    return true;
  }, serialize: function serialize() {
    return componentsModule.modules.note.data;
  }, create: function create(b, c, a) {
    var current = componentsModule.modules.note;var positionItems = c.querySelectorAll("span.position-item");var textarea = c.querySelector("textarea[name=component_inline_note]");current.data[b] = { title: "", note: "", note_position: 1, disabled: 0 };componentsModule.initializeEvents([{ event: "change keyup", element: textarea, content: function content(d) {
        current.data[b].note = d.target.value.trim();
      } }, { event: "click", element: positionItems, content: function content(d) {
        current.data[b].note_position = d.target.getAttribute("data-position");positionItems.forEach(function (e) {
          e.classList.remove("active");
        });d.target.classList.add("active");
      } }]);if (a) {
      if (a.note) {
        textarea.value = a.note.trim();triggerEvent(textarea, "change");
      }if (a.note_position !== undefined) {
        positionItems[a.note_position].click();
      }
    }
  } };

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var perex = {

    start: function start() {

        // Save elements
        perex.parentElement = document.querySelector('[data-component=perex]');
        perex.dateInput = perex.parentElement.querySelector('[name=component_perex_date]');
        perex.locationInput = perex.parentElement.querySelector('[name=component_perex_location]');

        // Clear date input
        _Utils2.default.registerEvent({

            event: 'click',
            element: perex.parentElement.querySelector('.clear-perex-date'),
            content: function content() {
                perex.dateInput.value = '';
            }

        });
    },

    resume: function resume() {

        // Save current instance
        var data = perex.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var object = JSON.parse(data);

        perex.dateInput.value = object.perex_date;
        perex.locationInput.value = object.perex_location;

        _Utils2.default.triggerEvent(perex.locationInput, 'change');
    },

    validate: function validate() {

        var data = perex.serialize().perex_location;

        return data.length < 121;
    },

    serialize: function serialize() {

        return {
            perex_date: perex.dateInput.value.trim(),
            perex_location: perex.locationInput.value.trim()
        };
    }

};

module.exports = perex;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.perex = { start: function start() {
    var current = componentsModule.modules.perex;current.parentElement = document.querySelector("[data-component=perex]");current.dateInput = current.parentElement.querySelector("[name=component_perex_date]");current.locationInput = current.parentElement.querySelector("[name=component_perex_location]");componentsModule.initializeEvent({ event: "click", element: current.parentElement.querySelector(".clear-perex-date"), content: function content() {
        current.dateInput.value = "";
      } });
  }, resume: function resume() {
    var current = componentsModule.modules.perex;var b = current.parentElement.getAttribute("data-resume");if (b === "") {
      return true;
    }var a = JSON.parse(b);current.dateInput.value = a.perex_date;current.locationInput.value = a.perex_location;triggerEvent(current.locationInput, "change");
  }, validate: function validate() {
    var a = componentsModule.modules.perex.serialize().perex_location;return a.length < 121;
  }, serialize: function serialize() {
    var current = componentsModule.modules.perex;return { perex_date: current.dateInput.value.trim(), perex_location: current.locationInput.value.trim() };
  } };

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.picture = {

    data: {},
    elements: {},

    start: function start() {

        // Save elements
        var current = componentsModule.modules.picture;
        current.templateElement = contentElement.querySelector('#template_component_content_picture_image').children[0];
    },

    resumeInline: function resumeInline(identifier, element, resumeData) {

        var current = componentsModule.modules.picture;
        var path = resumeData.picture;

        current.create(identifier, element);

        current.onSelect(identifier, element, path, true, function (description, align) {

            description.value = resumeData.picture_description.trim();
            triggerEvent(description, 'change');

            align[resumeData.picture_align].click();
        });
    },

    validateInput: function validateInput(path, identifier, onSuccess, onError) {

        console.log('validation');

        var current = componentsModule.modules.picture;
        var elements = current.elements[identifier];

        if (!validateUrl(path)) return showValidationResult(elements.messageBox, 'COMPONENT_URL_INVALID', false, reloadPackery);

        new Promise(function (resolve) {

            var image = new Image();

            image.onload = function () {
                resolve(true);
            };

            image.onerror = function () {
                resolve(false);
            };

            image.src = path;
        }).then(function (result) {

            if (result) {

                showValidationResult(elements.messageBox, 'COMPONENT_URL_INVALID', true, reloadPackery);

                if (onSuccess) onSuccess();
            } else {

                showValidationResult(elements.messageBox, 'COMPONENT_URL_INVALID', false, reloadPackery);

                if (onError) onError();
            }
        });
    },

    removeCurrent: function removeCurrent(element) {

        var instance = element.querySelector('div.component-instance span.picture-remove');

        if (instance) instance.click();
    },

    onSelect: function onSelect(identifier, element, path, outside, callback) {

        var current = componentsModule.modules.picture;
        var elements = current.elements[identifier];

        elements.contentElement.classList.add('no-padding');

        // Remove current image
        current.removeCurrent(element);

        // Create source link
        if (!outside) path = 'app/Data/Files/Images/' + path;

        // Save image path
        current.data[identifier] = {
            title: '',
            picture: path,
            picture_description: '',
            picture_align: 1,
            disabled: 0
        };

        // Create template
        var template = current.templateElement.cloneNode(true);

        template.setAttribute('data-path', path);
        template.classList.add('component-instance');

        template.children[0].setAttribute('src', path);
        template.children[0].setAttribute('alt', path);

        elements.contentElement.appendChild(template);

        // Hide media manager
        template.children[0].addEventListener('load', function () {

            closeMediaManager();
            elements.inputBox.classList.add('hide');
        });

        var alignOptions = template.children[3].children;
        componentsModule.initializeEvents([{
            // Serialize description
            event: 'change keyup',
            element: template.children[2],
            content: function content(event) {

                current.data[identifier].picture_description = event.target.value.trim();
            }
        }, {
            // Align picture
            event: 'click',
            element: alignOptions,
            content: function content(event) {

                current.data[identifier].picture_align = +event.target.getAttribute('data-value');

                Object.values(alignOptions).forEach(function (item) {

                    item.classList.remove('active');
                });

                event.target.classList.add('active');
            }
        }]);

        // Remove image
        template.children[1].addEventListener('click', function () {

            elements.inputBox.classList.remove('hide');
            elements.contentElement.removeChild(template);
            elements.contentElement.classList.remove('no-padding');

            delete current.data[identifier];
        });

        if (callback) callback(template.children[2], alignOptions);
    },

    create: function create(identifier, element) {

        var current = componentsModule.modules.picture;
        current.elements[identifier] = {};

        var elements = current.elements[identifier];
        elements.parentElement = element;
        elements.contentElement = element.querySelector('div.component-element-content');
        elements.inputBox = elements.contentElement.querySelector('div.input-box.select-image');
        elements.messageBox = elements.inputBox.querySelector('.validate-message');

        componentsModule.initializeEvents([{
            // Open Media Manager
            event: 'click',
            element: element.querySelector('button.inline-image_manager'),
            content: function content() {

                managerActiveInstance = new MediaManager({
                    manager: 'images',
                    onSelect: function onSelect(path) {

                        current.onSelect(identifier, element, path, false);
                    }
                });
            }
        }, {
            // Enter custom URL to image
            event: 'keypress',
            element: element.querySelector('input[name=component_inline_picture_input]'),
            content: function content(event) {

                if (!event.keyCode || event.keyCode !== 13) return false;

                var path = event.target.value.trim();

                current.validateInput(path, identifier, function () {

                    current.onSelect(identifier, element, path, true);
                });
            }
        }, {
            // Real-time URL validation
            event: 'change keyup',
            element: element.querySelector('input[name=component_inline_picture_input]'),
            content: function content(event) {

                current.validateInput(event.target.value.trim(), identifier);
            }
        }]);
    },

    validate: function validate() {

        return true;
    },

    serialize: function serialize() {

        return componentsModule.modules.picture.data;
    }

};

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.picture = { data: {}, elements: {}, start: function start() {
    var current = componentsModule.modules.picture;current.templateElement = contentElement.querySelector("#template_component_content_picture_image").children[0];
  }, resumeInline: function resumeInline(b, c, a) {
    var current = componentsModule.modules.picture;var path = a.picture;current.create(b, c);current.onSelect(b, c, path, true, function (d, e) {
      d.value = a.picture_description.trim();triggerEvent(d, "change");e[a.picture_align].click();
    });
  }, validateInput: function validateInput(c, a, d, b) {
    console.log("validation");var current = componentsModule.modules.picture;var elements = current.elements[a];if (!validateUrl(c)) {
      return showValidationResult(elements.messageBox, "COMPONENT_URL_INVALID", false, reloadPackery);
    }new Promise(function (e) {
      var image = new Image();image.onload = function () {
        e(true);
      };image.onerror = function () {
        e(false);
      };image.src = c;
    }).then(function (e) {
      if (e) {
        showValidationResult(elements.messageBox, "COMPONENT_URL_INVALID", true, reloadPackery);if (d) {
          d();
        }
      } else {
        showValidationResult(elements.messageBox, "COMPONENT_URL_INVALID", false, reloadPackery);if (b) {
          b();
        }
      }
    });
  }, removeCurrent: function removeCurrent(a) {
    var instance = a.querySelector("div.component-instance span.picture-remove");if (instance) {
      instance.click();
    }
  }, onSelect: function onSelect(a, b, d, c, e) {
    var current = componentsModule.modules.picture;var elements = current.elements[a];elements.contentElement.classList.add("no-padding");current.removeCurrent(b);if (!c) {
      d = "app/Data/Files/Images/" + d;
    }current.data[a] = { title: "", picture: d, picture_description: "", picture_align: 1, disabled: 0 };var template = current.templateElement.cloneNode(true);template.setAttribute("data-path", d);template.classList.add("component-instance");template.children[0].setAttribute("src", d);template.children[0].setAttribute("alt", d);elements.contentElement.appendChild(template);template.children[0].addEventListener("load", function () {
      closeMediaManager();elements.inputBox.classList.add("hide");
    });var alignOptions = template.children[3].children;componentsModule.initializeEvents([{ event: "change keyup", element: template.children[2], content: function content(f) {
        current.data[a].picture_description = f.target.value.trim();
      } }, { event: "click", element: alignOptions, content: function content(f) {
        current.data[a].picture_align = +f.target.getAttribute("data-value");Object.values(alignOptions).forEach(function (g) {
          g.classList.remove("active");
        });f.target.classList.add("active");
      } }]);template.children[1].addEventListener("click", function () {
      elements.inputBox.classList.remove("hide");elements.contentElement.removeChild(template);elements.contentElement.classList.remove("no-padding");delete current.data[a];
    });if (e) {
      e(template.children[2], alignOptions);
    }
  }, create: function create(a, b) {
    var current = componentsModule.modules.picture;current.elements[a] = {};var elements = current.elements[a];elements.parentElement = b;elements.contentElement = b.querySelector("div.component-element-content");elements.inputBox = elements.contentElement.querySelector("div.input-box.select-image");elements.messageBox = elements.inputBox.querySelector(".validate-message");componentsModule.initializeEvents([{ event: "click", element: b.querySelector("button.inline-image_manager"), content: function content() {
        managerActiveInstance = new MediaManager({ manager: "images", onSelect: function onSelect(c) {
            current.onSelect(a, b, c, false);
          } });
      } }, { event: "keypress", element: b.querySelector("input[name=component_inline_picture_input]"), content: function content(c) {
        if (!c.keyCode || c.keyCode !== 13) {
          return false;
        }var path = c.target.value.trim();current.validateInput(path, a, function () {
          current.onSelect(a, b, path, true);
        });
      } }, { event: "change keyup", element: b.querySelector("input[name=component_inline_picture_input]"), content: function content(c) {
        current.validateInput(c.target.value.trim(), a);
      } }]);
  }, validate: function validate() {
    return true;
  }, serialize: function serialize() {
    return componentsModule.modules.picture.data;
  } };

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var pin = {

    start: function start() {

        // Save elements
        pin.parentElement = document.querySelector('[data-component=pin]');
        pin.checkElement = pin.parentElement.querySelector('input');
    },

    resume: function resume() {

        // Save current instance
        var data = pin.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var object = JSON.parse(data);
        pin.checkElement.checked = !!object.pin;
    },

    validate: function validate() {

        var data = pin.serialize().pin;

        return typeof data === 'boolean';
    },

    serialize: function serialize() {

        return {
            pin: !!pin.checkElement.checked
        };
    }

};

module.exports = pin;

/***/ }),
/* 61 */,
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.planner = {

    start: function start() {

        // Save elements
        var current = componentsModule.modules.planner;
        current.parentElement = document.querySelector('[data-component=planner');
        current.customPublish = current.parentElement.querySelector('.component_planner_publish_custom');
        current.notifyBox = current.parentElement.querySelector('.component_planner_notify_email');

        current.publishAuto = current.parentElement.querySelector('[name=component_planner_publish]');
        current.publishInput = current.parentElement.querySelector('[name=component_planner_publish_datetime]');
        current.expiryInput = current.parentElement.querySelector('[name=component_planner_publish_expiry]');
        current.plannerNotify = current.parentElement.querySelector('[name=component_planner_notify]');
        current.notifyEmail = current.parentElement.querySelector('[name=component_planner_notify_email]');

        // Events
        componentsModule.initializeEvents([{
            // Delegate change events
            event: 'change',
            element: current.parentElement,
            content: function content(event) {

                var target = event.target;

                // Auto-publication change
                if (target === current.publishAuto) {

                    if (target.checked) current.customPublish.classList.add('hide');else current.customPublish.classList.remove('hide');

                    reloadPackery();
                }

                // Notification change
                else if (target === current.plannerNotify) {

                        if (target.checked) current.notifyBox.classList.remove('hide');else current.notifyBox.classList.add('hide');

                        reloadPackery();
                    }
            }
        }, {
            // Delegate click events
            event: 'click',
            element: current.parentElement,
            content: function content(event) {

                // Clear input
                if (event.target.matches('.clear-input')) {

                    event.target.parentNode.querySelector('input').value = '';
                }
            }
        }]);
    },

    resume: function resume() {

        // Save current instance
        var current = componentsModule.modules.planner;
        var data = current.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var planner = JSON.parse(data);

        if (planner === null) return true;

        current.publishAuto.checked = !planner.planner;
        triggerEvent(current.publishAuto, 'change');

        current.publishInput.value = planner.planner_date;
        current.expiryInput.value = planner.planner_expiry;

        current.plannerNotify.checked = !!planner.planner_notify;
        triggerEvent(current.plannerNotify, 'change');

        current.notifyEmail.checked = !!planner.planner_notify_email;
    },

    validate: function validate() {

        return true;
    },

    serialize: function serialize() {

        var current = componentsModule.modules.planner;

        return {

            planner: !current.publishAuto.checked,
            planner_date: current.publishInput.value.trim(),
            planner_expiry: current.expiryInput.value.trim(),
            planner_notify: !!current.plannerNotify.checked,
            planner_notify_email: !!current.notifyEmail.checked

        };
    }

};

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.planner = { start: function start() {
    var current = componentsModule.modules.planner;current.parentElement = document.querySelector("[data-component=planner");current.customPublish = current.parentElement.querySelector(".component_planner_publish_custom");current.notifyBox = current.parentElement.querySelector(".component_planner_notify_email");current.publishAuto = current.parentElement.querySelector("[name=component_planner_publish]");current.publishInput = current.parentElement.querySelector("[name=component_planner_publish_datetime]");current.expiryInput = current.parentElement.querySelector("[name=component_planner_publish_expiry]");current.plannerNotify = current.parentElement.querySelector("[name=component_planner_notify]");current.notifyEmail = current.parentElement.querySelector("[name=component_planner_notify_email]");componentsModule.initializeEvents([{ event: "change", element: current.parentElement, content: function content(a) {
        var target = a.target;if (target === current.publishAuto) {
          if (target.checked) {
            current.customPublish.classList.add("hide");
          } else {
            current.customPublish.classList.remove("hide");
          }reloadPackery();
        } else {
          if (target === current.plannerNotify) {
            if (target.checked) {
              current.notifyBox.classList.remove("hide");
            } else {
              current.notifyBox.classList.add("hide");
            }reloadPackery();
          }
        }
      } }, { event: "click", element: current.parentElement, content: function content(a) {
        if (a.target.matches(".clear-input")) {
          a.target.parentNode.querySelector("input").value = "";
        }
      } }]);
  }, resume: function resume() {
    var current = componentsModule.modules.planner;var a = current.parentElement.getAttribute("data-resume");if (a === "") {
      return true;
    }var b = JSON.parse(a);if (b === null) {
      return true;
    }current.publishAuto.checked = !b.planner;triggerEvent(current.publishAuto, "change");current.publishInput.value = b.planner_date;current.expiryInput.value = b.planner_expiry;current.plannerNotify.checked = !!b.planner_notify;triggerEvent(current.plannerNotify, "change");current.notifyEmail.checked = !!b.planner_notify_email;
  }, validate: function validate() {
    return true;
  }, serialize: function serialize() {
    var current = componentsModule.modules.planner;return { planner: !current.publishAuto.checked, planner_date: current.publishInput.value.trim(), planner_expiry: current.expiryInput.value.trim(), planner_notify: !!current.plannerNotify.checked, planner_notify_email: !!current.notifyEmail.checked };
  } };

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.poll = {

    data: {},
    itemClone: false,

    validate: function validate() {
        return true;
    },

    serialize: function serialize() {
        return componentsModule.modules.poll.data;
    },

    resumeInline: function resumeInline(identifier, element, resumeData) {

        var current = componentsModule.modules.poll;
        var listElement = current.create(identifier, element, resumeData);

        resumeData.poll.forEach(function (pollItem) {

            if (pollItem === '') return true;

            current.createItem(identifier, listElement, undefined, false, pollItem);
        });

        if (current.data[identifier].poll.length < 1) current.createItem(identifier, listElement);
    },

    reloadItems: function reloadItems(identifier, listElement) {

        var newOrder = [];
        var newContent = [];
        var current = componentsModule.modules.poll;

        listElement.querySelectorAll('.poll-item').forEach(function (item) {
            newOrder.push(parseFloat(item.getAttribute('data-item')));
            var text = item.querySelector('p').innerText.trim();
            if (text === current.itemClone.querySelector('p').innerText.trim()) text = '';
            newContent.push(text);
        });

        current.data[identifier].poll = newContent;
        current.data[identifier].order = newOrder;
    },

    createItem: function createItem(identifier, listElement, after, focus, pollItem) {

        if (!pollItem) pollItem = '';

        var current = componentsModule.modules.poll;
        var itemID = Math.random() * (99999 - 10000) + 10000;
        var index = void 0;

        // Create item data
        if (!after) {

            current.data[identifier].poll.push(pollItem);
            current.data[identifier].order.push(itemID);
            index = +current.data[identifier].order.indexOf(itemID);
        } else {

            index = +current.data[identifier].order.indexOf(after);

            if (index === -1) return false;

            index += 1;
            current.data[identifier].poll.splice(index, 0, pollItem);
            current.data[identifier].order.splice(index, 0, itemID);
        }

        // Create item clone
        var itemElement = current.itemClone.cloneNode(true);
        var itemText = itemElement.querySelector('p');

        itemElement.setAttribute('data-item', itemID.toString());

        // Create item events
        componentsModule.initializeEvents([{
            // Focus hide placeholder
            event: 'focus',
            element: itemText,
            content: function content(event) {

                var target = event.target;

                if (target.innerText.trim() !== current.itemClone.querySelector('p').innerText) return false;

                target.classList.remove('item-text-placeholder');
                target.innerText = '';
            }
        }, {
            // Blur add placeholder
            event: 'blur',
            element: itemText,
            content: function content(event) {

                var target = event.target;
                var nextItem = target.parentNode.nextSibling;

                if (target.innerText.trim() !== '' && nextItem === null) current.createItem(identifier, listElement, itemID, true);

                if (target.innerText.trim() !== '') return false;

                target.classList.add('item-text-placeholder');
                target.innerText = current.itemClone.querySelector('p').innerText;
            }
        }, {
            // Add item after
            event: 'keydown',
            element: itemText,
            content: function content(event) {

                if (event.keyCode !== 13) return false;

                var currentItem = event.target.parentNode;
                var nextItem = currentItem.nextSibling;

                if (nextItem !== null) nextItem.querySelector('p').focus();else event.target.blur();

                event.preventDefault();
            }
        }, {
            // Serialize item
            event: 'keyup change',
            element: itemText,
            content: function content(event) {

                current.data[identifier].poll[index] = event.target.innerText.trim();
            }
        }, {
            // Delete item
            event: 'click',
            element: itemElement.querySelector('.poll-item-delete'),
            content: function content() {

                if (listElement.children.length < 2) return false;

                var index = current.data[identifier].order.indexOf(itemID);

                if (index === -1) return false;

                current.data[identifier].poll.splice(index, 1);
                current.data[identifier].order.splice(index, 1);

                listElement.removeChild(itemElement);
                current.reloadItems(identifier, listElement);
            }
        }]);

        // Show item
        if (!after) listElement.appendChild(itemElement);else {

            if (!current.data[identifier].order[index + 1]) listElement.appendChild(itemElement);else listElement.insertBefore(itemElement, listElement.children[index + 1]);
        }

        // Resume data
        itemText.innerText = pollItem ? pollItem : itemText.innerText;

        if (pollItem) itemText.classList.remove('item-text-placeholder');

        // Focus
        if (focus) itemText.focus();
    },

    create: function create(identifier, element, resumeData) {

        var current = componentsModule.modules.poll;
        var contentElement = element.querySelector('.component-element-content');
        var listElement = contentElement.querySelector('.component-inline-poll-content');
        var listItem = listElement.querySelector('.poll-item');

        if (!current.itemClone) current.itemClone = listItem.cloneNode(true);
        listElement.removeChild(listItem);

        // Data
        current.data[identifier] = {
            title: '',
            disabled: 0,
            poll: [],
            order: [],
            poll_title: '',
            poll_type: 0,
            poll_position: 1
        };

        // Drag & Drop
        Sortable.create(listElement, {
            sort: true,
            animation: 200,
            scroll: false,
            draggable: '.poll-item',
            handle: '.poll-item-move',
            onStart: function onStart(event) {
                event.item.classList.add('chosen');
            },
            onEnd: function onEnd(event) {
                event.item.classList.remove('chosen');
                current.reloadItems(identifier, listElement);
            }
        });

        // Events
        var typeItems = contentElement.querySelectorAll('.component-poll_type .position-item');
        var positionItems = contentElement.querySelectorAll('.component-poll_align .position-item');
        var nameInput = contentElement.querySelector('input[name=component_inline_poll_name]');

        componentsModule.initializeEvents([{
            // Serialize poll title
            event: 'change keyup',
            element: nameInput,
            content: function content(event) {
                current.data[identifier].poll_title = event.target.value.trim();
            }
        }, {
            // Serialize poll type
            event: 'click',
            element: typeItems,
            content: function content(event) {
                listElement.setAttribute('data-type', current.data[identifier].poll_type = event.target.getAttribute('data-position'));
                typeItems.forEach(function (item) {
                    item.classList.remove('active');
                });
                event.target.classList.add('active');
            }
        }, {
            // Serialize poll align
            event: 'click',
            element: positionItems,
            content: function content(event) {
                current.data[identifier].poll_position = event.target.getAttribute('data-position');
                positionItems.forEach(function (item) {
                    item.classList.remove('active');
                });
                event.target.classList.add('active');
            }
        }]);

        if (resumeData !== undefined) {

            nameInput.value = resumeData.poll_title.trim();
            triggerEvent(nameInput, 'change');

            typeItems[+resumeData.poll_type].click();
            positionItems[+resumeData.poll_position].click();
        }

        // First item
        if (!resumeData) current.createItem(identifier, listElement);

        return listElement;
    }

};

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.poll = { data: {}, itemClone: false, validate: function validate() {
    return true;
  }, serialize: function serialize() {
    return componentsModule.modules.poll.data;
  }, resumeInline: function resumeInline(b, c, a) {
    var current = componentsModule.modules.poll;var listElement = current.create(b, c, a);a.poll.forEach(function (d) {
      if (d === "") {
        return true;
      }current.createItem(b, listElement, undefined, false, d);
    });if (current.data[b].poll.length < 1) {
      current.createItem(b, listElement);
    }
  }, reloadItems: function reloadItems(a, b) {
    var newOrder = [];var newContent = [];var current = componentsModule.modules.poll;b.querySelectorAll(".poll-item").forEach(function (c) {
      newOrder.push(parseFloat(c.getAttribute("data-item")));var text = c.querySelector("p").innerText.trim();if (text === current.itemClone.querySelector("p").innerText.trim()) {
        text = "";
      }newContent.push(text);
    });current.data[a].poll = newContent;current.data[a].order = newOrder;
  }, createItem: function createItem(c, d, e, a, b) {
    if (!b) {
      b = "";
    }var current = componentsModule.modules.poll;var itemID = Math.random() * (99999 - 10000) + 10000;var index = void 0;if (!e) {
      current.data[c].poll.push(b);current.data[c].order.push(itemID);index = +current.data[c].order.indexOf(itemID);
    } else {
      index = +current.data[c].order.indexOf(e);if (index === -1) {
        return false;
      }index += 1;current.data[c].poll.splice(index, 0, b);current.data[c].order.splice(index, 0, itemID);
    }var itemElement = current.itemClone.cloneNode(true);var itemText = itemElement.querySelector("p");itemElement.setAttribute("data-item", itemID.toString());componentsModule.initializeEvents([{ event: "focus", element: itemText, content: function content(f) {
        var target = f.target;if (target.innerText.trim() !== current.itemClone.querySelector("p").innerText) {
          return false;
        }target.classList.remove("item-text-placeholder");target.innerText = "";
      } }, { event: "blur", element: itemText, content: function content(f) {
        var target = f.target;var nextItem = target.parentNode.nextSibling;if (target.innerText.trim() !== "" && nextItem === null) {
          current.createItem(c, d, itemID, true);
        }if (target.innerText.trim() !== "") {
          return false;
        }target.classList.add("item-text-placeholder");target.innerText = current.itemClone.querySelector("p").innerText;
      } }, { event: "keydown", element: itemText, content: function content(f) {
        if (f.keyCode !== 13) {
          return false;
        }var currentItem = f.target.parentNode;var nextItem = currentItem.nextSibling;if (nextItem !== null) {
          nextItem.querySelector("p").focus();
        } else {
          f.target.blur();
        }f.preventDefault();
      } }, { event: "keyup change", element: itemText, content: function content(f) {
        current.data[c].poll[index] = f.target.innerText.trim();
      } }, { event: "click", element: itemElement.querySelector(".poll-item-delete"), content: function content() {
        if (d.children.length < 2) {
          return false;
        }var index = current.data[c].order.indexOf(itemID);if (index === -1) {
          return false;
        }current.data[c].poll.splice(index, 1);current.data[c].order.splice(index, 1);d.removeChild(itemElement);current.reloadItems(c, d);
      } }]);if (!e) {
      d.appendChild(itemElement);
    } else {
      if (!current.data[c].order[index + 1]) {
        d.appendChild(itemElement);
      } else {
        d.insertBefore(itemElement, d.children[index + 1]);
      }
    }itemText.innerText = b ? b : itemText.innerText;if (b) {
      itemText.classList.remove("item-text-placeholder");
    }if (a) {
      itemText.focus();
    }
  }, create: function create(b, c, a) {
    var current = componentsModule.modules.poll;var contentElement = c.querySelector(".component-element-content");var listElement = contentElement.querySelector(".component-inline-poll-content");var listItem = listElement.querySelector(".poll-item");if (!current.itemClone) {
      current.itemClone = listItem.cloneNode(true);
    }listElement.removeChild(listItem);current.data[b] = { title: "", disabled: 0, poll: [], order: [], poll_title: "", poll_type: 0, poll_position: 1 };Sortable.create(listElement, { sort: true, animation: 200, scroll: false, draggable: ".poll-item", handle: ".poll-item-move", onStart: function onStart(d) {
        d.item.classList.add("chosen");
      }, onEnd: function onEnd(d) {
        d.item.classList.remove("chosen");current.reloadItems(b, listElement);
      } });var typeItems = contentElement.querySelectorAll(".component-poll_type .position-item");var positionItems = contentElement.querySelectorAll(".component-poll_align .position-item");var nameInput = contentElement.querySelector("input[name=component_inline_poll_name]");componentsModule.initializeEvents([{ event: "change keyup", element: nameInput, content: function content(d) {
        current.data[b].poll_title = d.target.value.trim();
      } }, { event: "click", element: typeItems, content: function content(d) {
        listElement.setAttribute("data-type", current.data[b].poll_type = d.target.getAttribute("data-position"));typeItems.forEach(function (e) {
          e.classList.remove("active");
        });d.target.classList.add("active");
      } }, { event: "click", element: positionItems, content: function content(d) {
        current.data[b].poll_position = d.target.getAttribute("data-position");positionItems.forEach(function (e) {
          e.classList.remove("active");
        });d.target.classList.add("active");
      } }]);if (a !== undefined) {
      nameInput.value = a.poll_title.trim();triggerEvent(nameInput, "change");typeItems[+a.poll_type].click();positionItems[+a.poll_position].click();
    }if (!a) {
      current.createItem(b, listElement);
    }return listElement;
  } };

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.quote = {

    data: {},

    validate: function validate() {
        return true;
    },

    serialize: function serialize() {
        return componentsModule.modules.quote.data;
    },

    resumeInline: function resumeInline(identifier, element, resumeData) {

        componentsModule.modules.quote.create(identifier, element, resumeData);
    },

    create: function create(identifier, element, resumeData) {

        var current = componentsModule.modules.quote;

        // Create instance data
        current.data[identifier] = {
            title: '',
            quote: '',
            quote_author: '',
            quote_position: 1,
            disabled: 0
        };

        var positionItems = element.querySelectorAll('span.position-item');
        var quoteInput = element.querySelector('textarea[name=component_inline_quote_text]');
        var authorInput = element.querySelector('input[name=component_inline_quote_author]');

        componentsModule.initializeEvents([{
            // Serialize quote body
            event: 'change keyup',
            element: quoteInput,
            content: function content(event) {
                current.data[identifier].quote = event.target.value.trim();
            }
        }, {
            // Serialize quote author
            event: 'change keyup',
            element: authorInput,
            content: function content(event) {
                current.data[identifier].quote_author = event.target.value.trim();
            }
        }, {
            // Serialize position component
            event: 'click',
            element: positionItems,
            content: function content(event) {
                current.data[identifier].quote_position = event.target.getAttribute('data-position');
                positionItems.forEach(function (item) {
                    item.classList.remove('active');
                });
                event.target.classList.add('active');
            }
        }]);

        if (resumeData) {

            if (resumeData.quote) {

                quoteInput.value = resumeData.quote.trim();
                triggerEvent(quoteInput, 'change');
            }

            if (resumeData.quote_author) {

                authorInput.value = resumeData.quote_author.trim();
                triggerEvent(authorInput, 'change');
            }

            if (resumeData.quote_position !== undefined) positionItems[resumeData.quote_position].click();
        }
    }

};

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.quote = { data: {}, validate: function validate() {
    return true;
  }, serialize: function serialize() {
    return componentsModule.modules.quote.data;
  }, resumeInline: function resumeInline(b, c, a) {
    componentsModule.modules.quote.create(b, c, a);
  }, create: function create(b, c, a) {
    var current = componentsModule.modules.quote;current.data[b] = { title: "", quote: "", quote_author: "", quote_position: 1, disabled: 0 };var positionItems = c.querySelectorAll("span.position-item");var quoteInput = c.querySelector("textarea[name=component_inline_quote_text]");var authorInput = c.querySelector("input[name=component_inline_quote_author]");componentsModule.initializeEvents([{ event: "change keyup", element: quoteInput, content: function content(d) {
        current.data[b].quote = d.target.value.trim();
      } }, { event: "change keyup", element: authorInput, content: function content(d) {
        current.data[b].quote_author = d.target.value.trim();
      } }, { event: "click", element: positionItems, content: function content(d) {
        current.data[b].quote_position = d.target.getAttribute("data-position");positionItems.forEach(function (e) {
          e.classList.remove("active");
        });d.target.classList.add("active");
      } }]);if (a) {
      if (a.quote) {
        quoteInput.value = a.quote.trim();triggerEvent(quoteInput, "change");
      }if (a.quote_author) {
        authorInput.value = a.quote_author.trim();triggerEvent(authorInput, "change");
      }if (a.quote_position !== undefined) {
        positionItems[a.quote_position].click();
      }
    }
  } };

/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.revisions = {

    start: function start() {

        // Save elements
        var current = componentsModule.modules.revisions;
        current.parentElement = document.querySelector('[data-component=revisions]');
        current.textInput = current.parentElement.querySelector('textarea');
        current.listElement = current.parentElement.querySelector('.revisions-list');
        current.templateElement = current.parentElement.querySelector('#template_component_revisions_item').childNodes[0];
    },

    resume: function resume() {

        // Save current instance
        var current = componentsModule.modules.revisions;
        var data = current.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var revisions = JSON.parse(data).revision;

        if (revisions === null) return true;

        revisions.forEach(function (revision) {

            var template = current.templateElement.cloneNode(true);
            template.childNodes[0].innerText = revision.created_at;
            template.childNodes[1].innerText = revision.description;

            current.listElement.appendChild(template);
        });

        current.listElement.scrollTop = current.listElement.scrollHeight;

        reloadPackery();
    },

    validate: function validate() {

        var data = componentsModule.modules.revisions.serialize().revision;

        return data.length < 251;
    },

    serialize: function serialize() {

        return {

            revision: componentsModule.modules.revisions.textInput.value.trim()

        };
    }

};

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.revisions = { start: function start() {
    var current = componentsModule.modules.revisions;current.parentElement = document.querySelector("[data-component=revisions]");current.textInput = current.parentElement.querySelector("textarea");current.listElement = current.parentElement.querySelector(".revisions-list");current.templateElement = current.parentElement.querySelector("#template_component_revisions_item").childNodes[0];
  }, resume: function resume() {
    var current = componentsModule.modules.revisions;var b = current.parentElement.getAttribute("data-resume");if (b === "") {
      return true;
    }var a = JSON.parse(b).revision;if (a === null) {
      return true;
    }a.forEach(function (c) {
      var template = current.templateElement.cloneNode(true);template.childNodes[0].innerText = c.created_at;template.childNodes[1].innerText = c.description;current.listElement.appendChild(template);
    });current.listElement.scrollTop = current.listElement.scrollHeight;reloadPackery();
  }, validate: function validate() {
    var a = componentsModule.modules.revisions.serialize().revision;return a.length < 251;
  }, serialize: function serialize() {
    return { revision: componentsModule.modules.revisions.textInput.value.trim() };
  } };

/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.rich_text = {

    data: {},
    elements: {},

    resumeInline: function resumeInline(identifier, element, resumeData) {

        var current = componentsModule.modules.rich_text;

        current.create(identifier, element, function () {

            current.data[identifier].value = resumeData.value.trim();
        });
    },

    reload: function reload(identifier) {

        componentsModule.modules.rich_text.onCreate(identifier);
        CKEDITOR.instances['editor_' + identifier].setData(componentsModule.modules.rich_text.data[identifier].value);
    },

    create: function create(identifier, element, callback) {

        componentsModule.modules.rich_text.data[identifier] = {
            title: '',
            value: '',
            disabled: 0
        };

        element.querySelector('textarea').setAttribute('id', 'editor_' + identifier);

        if (callback) callback();
    },

    onCreate: function onCreate(identifier) {

        var current = componentsModule.modules.rich_text;

        CKEDITOR.replace('editor_' + identifier, ckconfig);

        CKEDITOR.instances['editor_' + identifier].on('change', function () {
            current.data[identifier].value = CKEDITOR.instances['editor_' + identifier].getData().trim();
        });

        if (current.data[identifier].value !== '') CKEDITOR.instances['editor_' + identifier].setData(current.data[identifier].value);
    },

    validate: function validate() {

        return true;
    },

    serialize: function serialize() {

        return componentsModule.modules.rich_text.data;
    }

};

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.rich_text = { data: {}, elements: {}, resumeInline: function resumeInline(b, c, a) {
    var current = componentsModule.modules.rich_text;current.create(b, c, function () {
      current.data[b].value = a.value.trim();
    });
  }, reload: function reload(a) {
    componentsModule.modules.rich_text.onCreate(a);CKEDITOR.instances["editor_" + a].setData(componentsModule.modules.rich_text.data[a].value);
  }, create: function create(a, b, c) {
    componentsModule.modules.rich_text.data[a] = { title: "", value: "", disabled: 0 };b.querySelector("textarea").setAttribute("id", "editor_" + a);if (c) {
      c();
    }
  }, onCreate: function onCreate(a) {
    var current = componentsModule.modules.rich_text;CKEDITOR.replace("editor_" + a, ckconfig);CKEDITOR.instances["editor_" + a].on("change", function () {
      current.data[a].value = CKEDITOR.instances["editor_" + a].getData().trim();
    });if (current.data[a].value !== "") {
      CKEDITOR.instances["editor_" + a].setData(current.data[a].value);
    }
  }, validate: function validate() {
    return true;
  }, serialize: function serialize() {
    return componentsModule.modules.rich_text.data;
  } };

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.sources = {

    start: function start() {

        // Save elements
        var current = componentsModule.modules.sources;
        current.parentElement = document.querySelector('[data-component=sources]');
        current.nameInput = current.parentElement.querySelector('[name=component_sources_add_name]');
        current.valueInput = current.parentElement.querySelector('[name=component_sources_add_source]');
        current.addButton = current.parentElement.querySelector('.sources-add');
        current.itemsList = current.parentElement.querySelector('.sources-list');
        current.templateElement = current.parentElement.querySelector('#template_component_sources_item').childNodes[0];

        // Events
        componentsModule.initializeEvents([{
            // Enter to add source
            event: 'keyup',
            element: current.valueInput,
            content: function content(event) {

                if (!event.keyCode || event.keyCode !== 13) return true;

                current.addButton.click();
            }
        }, {
            // Delegate click events
            event: 'click',
            element: current.parentElement,
            content: function content(event) {

                var target = event.target;

                // Add source
                if (target === current.addButton) current.addSource();

                // Edit source
                else if (target.matches('.source-edit')) {

                        var parent = target.parentNode;

                        current.nameInput.value = parent.childNodes[0].innerText.trim();
                        current.valueInput.value = parent.childNodes[1].innerText.trim();
                        current.nameInput.focus();

                        current.itemsList.removeChild(parent);

                        reloadPackery();
                    }

                    // Remove source
                    else if (target.matches('.source-remove')) {

                            current.nameInput.value = '';
                            current.valueInput.value = '';
                            current.nameInput.focus();

                            current.itemsList.removeChild(target.parentNode);

                            reloadPackery();
                        }
            }
        }]);
    },

    addSource: function addSource(source) {

        // Save current
        var current = componentsModule.modules.sources;
        var currentSources = current.itemsList.childNodes;

        var sourceNames = Object.values(currentSources).map(function (sourceElement) {
            return sourceElement.childNodes[0].innerText.trim();
        });

        var sourceName = source[0] || current.nameInput.value.trim();

        if (~sourceNames.indexOf(sourceName)) {
            current.nameInput.value = '';
            if (!source) current.nameInput.focus();
            return true;
        }

        var sourceValue = source[1] || current.valueInput.value.trim();

        if (sourceName === '' || sourceValue === '') {
            if (!source) current.nameInput.focus();
            return true;
        }

        var template = current.templateElement.cloneNode(true);
        template.children[0].innerText = sourceName;
        template.children[1].innerText = sourceValue;

        current.nameInput.value = '';
        current.valueInput.value = '';

        if (!source) current.nameInput.focus();

        current.itemsList.insertBefore(template, current.itemsList.childNodes[0]);
        reloadPackery();
    },

    resume: function resume() {

        // Save current instance
        var current = componentsModule.modules.sources;
        var data = current.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var sources = JSON.parse(data).sources;

        if (sources === null) return true;

        sources.forEach(function (source) {

            current.addSource(source);
        });

        reloadPackery();
    },

    validate: function validate() {

        return true;
    },

    serialize: function serialize() {

        var sourceItems = componentsModule.modules.sources.itemsList.childNodes;

        var sources = Object.values(sourceItems).reverse().map(function (sourceItem) {

            return [sourceItem.childNodes[0].innerText.trim(), sourceItem.childNodes[1].innerText.trim()];
        });

        return {

            sources: sources

        };
    }

};

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.sources = { start: function start() {
    var current = componentsModule.modules.sources;current.parentElement = document.querySelector("[data-component=sources]");current.nameInput = current.parentElement.querySelector("[name=component_sources_add_name]");current.valueInput = current.parentElement.querySelector("[name=component_sources_add_source]");current.addButton = current.parentElement.querySelector(".sources-add");current.itemsList = current.parentElement.querySelector(".sources-list");current.templateElement = current.parentElement.querySelector("#template_component_sources_item").childNodes[0];componentsModule.initializeEvents([{ event: "keyup", element: current.valueInput, content: function content(a) {
        if (!a.keyCode || a.keyCode !== 13) {
          return true;
        }current.addButton.click();
      } }, { event: "click", element: current.parentElement, content: function content(a) {
        var target = a.target;if (target === current.addButton) {
          current.addSource();
        } else {
          if (target.matches(".source-edit")) {
            var parent = target.parentNode;current.nameInput.value = parent.childNodes[0].innerText.trim();current.valueInput.value = parent.childNodes[1].innerText.trim();current.nameInput.focus();current.itemsList.removeChild(parent);reloadPackery();
          } else {
            if (target.matches(".source-remove")) {
              current.nameInput.value = "";current.valueInput.value = "";current.nameInput.focus();current.itemsList.removeChild(target.parentNode);reloadPackery();
            }
          }
        }
      } }]);
  }, addSource: function addSource(c) {
    var current = componentsModule.modules.sources;var currentSources = current.itemsList.childNodes;var sourceNames = Object.values(currentSources).map(function (d) {
      return d.childNodes[0].innerText.trim();
    });var a = c[0] || current.nameInput.value.trim();if (~sourceNames.indexOf(a)) {
      current.nameInput.value = "";if (!c) {
        current.nameInput.focus();
      }return true;
    }var b = c[1] || current.valueInput.value.trim();if (a === "" || b === "") {
      if (!c) {
        current.nameInput.focus();
      }return true;
    }var template = current.templateElement.cloneNode(true);template.children[0].innerText = a;template.children[1].innerText = b;current.nameInput.value = "";current.valueInput.value = "";if (!c) {
      current.nameInput.focus();
    }current.itemsList.insertBefore(template, current.itemsList.childNodes[0]);reloadPackery();
  }, resume: function resume() {
    var current = componentsModule.modules.sources;var b = current.parentElement.getAttribute("data-resume");if (b === "") {
      return true;
    }var a = JSON.parse(b).sources;if (a === null) {
      return true;
    }a.forEach(function (c) {
      current.addSource(c);
    });reloadPackery();
  }, validate: function validate() {
    return true;
  }, serialize: function serialize() {
    var sourceItems = componentsModule.modules.sources.itemsList.childNodes;var sources = Object.values(sourceItems).reverse().map(function (a) {
      return [a.childNodes[0].innerText.trim(), a.childNodes[1].innerText.trim()];
    });return { sources: sources };
  } };

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.status = {

    start: function start() {

        // Save elements
        var current = componentsModule.modules.status;
        current.parentElement = document.querySelector('[data-component=status]');
        current.selectElement = current.parentElement.querySelector('select');

        current.selector = current.createSelector();
    },

    createSelector: function createSelector() {

        return new Selector({
            selector: 'select[name=component_status]',
            onOpen: reloadPackery,
            onClose: reloadPackery
        });
    },

    resume: function resume() {

        // Save current instance
        var current = componentsModule.modules.status;
        var data = current.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var status = JSON.parse(data).status;

        var selectOptions = current.selectElement.querySelectorAll('option');

        Object.values(selectOptions).forEach(function (selectOption, index) {

            if (index !== status) selectOption.removeAttribute('selected');else selectOption.setAttribute('selected', 'true');
        });

        current.selector.destroy();
        current.selector = current.createSelector();
    },

    validate: function validate() {

        var data = componentsModule.modules.status.serialize().status;

        return data > -1 && data < 4;
    },

    serialize: function serialize() {

        return {

            status: parseInt(componentsModule.modules.status.selectElement.querySelector('[selected=true]').getAttribute('value'))

        };
    }

};

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.status = { start: function start() {
    var current = componentsModule.modules.status;current.parentElement = document.querySelector("[data-component=status]");current.selectElement = current.parentElement.querySelector("select");current.selector = current.createSelector();
  }, createSelector: function createSelector() {
    return new Selector({ selector: "select[name=component_status]", onOpen: reloadPackery, onClose: reloadPackery });
  }, resume: function resume() {
    var current = componentsModule.modules.status;var b = current.parentElement.getAttribute("data-resume");if (b === "") {
      return true;
    }var a = JSON.parse(b).status;var selectOptions = current.selectElement.querySelectorAll("option");Object.values(selectOptions).forEach(function (c, d) {
      if (d !== a) {
        c.removeAttribute("selected");
      } else {
        c.setAttribute("selected", "true");
      }
    });current.selector.destroy();current.selector = current.createSelector();
  }, validate: function validate() {
    var a = componentsModule.modules.status.serialize().status;return a > -1 && a < 4;
  }, serialize: function serialize() {
    return { status: parseInt(componentsModule.modules.status.selectElement.querySelector("[selected=true]").getAttribute("value")) };
  } };

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.table = {

    data: {},

    template: false,
    clones: {

        clone: false,

        actionRow: false,
        headerRow: false,
        tableRow: false,

        headerActionFirst: false,
        headerAction: false,

        asideActionFirst: false,
        asideAction: false,

        headerCell: false,
        contentCell: false,

        emptyCell: false

    },

    resumeInline: function resumeInline(identifier, element, resumeData) {

        var current = componentsModule.modules.table;
        current.create(identifier, element, resumeData);
    },

    validate: function validate() {
        return true;
    },

    serialize: function serialize() {
        return componentsModule.modules.table.data;
    },

    addRow: function addRow(table, identifier, before, resumeData) {

        var current = componentsModule.modules.table;
        var clones = current.clones;
        var data = current.data[identifier];
        var tableRow = clones.tableRow.cloneNode(true);
        var actionCell = clones.asideAction.cloneNode(true);
        var columnID = data.table.order.columns[0];
        var headerCell = clones.headerCell.cloneNode(true);

        var rowID = Math.floor(Math.random() * (9999999 - 1000000)) + 1000000;

        tableRow.appendChild(actionCell);
        headerCell.setAttribute('data-column', data.table.order.columns[0]);
        tableRow.appendChild(headerCell);

        // Serialize row header cell
        data.table.rows[rowID] = {};
        tableRow.setAttribute('data-row', rowID);

        if (before === undefined) data.table.order.rows.push(rowID);else {

            var beforeID = parseFloat(before.getAttribute('data-row'));
            var beforeIndex = data.table.order.rows.indexOf(beforeID);

            if (beforeIndex === -1) return false;

            data.table.order.rows.splice(beforeIndex, 0, rowID);
        }

        if (data.table.hidden) if (data.table.hidden.columns.indexOf(columnID) !== -1) headerCell.classList.add('hidden');

        for (var i = 0; i < data.dimensions[0]; ++i) {

            var contentCell = clones.contentCell.cloneNode(true);
            var _columnID = data.table.order.columns[+i + 1];

            contentCell.setAttribute('data-column', _columnID);
            tableRow.appendChild(contentCell);
        }

        if (!before) table.appendChild(tableRow);else table.insertBefore(tableRow, before);

        if (resumeData !== undefined) {

            if (resumeData.hidden) triggerEvent(actionCell.children[0], 'click');

            if (resumeData.header) {
                headerCell.innerText = resumeData.header;
                triggerEvent(headerCell, 'input');
            }
        }

        ++data.dimensions[1];
        return table;
    },

    addColumn: function addColumn(table, identifier, afterID, resumeData) {

        var current = componentsModule.modules.table;
        var data = current.data[identifier];
        var clones = current.clones;

        var columnID = Math.floor(Math.random() * (999999 - 100000)) + 100000;
        var actionRow = table.querySelector('.table-action-row');
        var actionCell = clones.headerAction.cloneNode(true);

        var headerRow = table.querySelector('.table-header-row');
        var headerCell = clones.headerCell.cloneNode(true);

        var contentRows = table.querySelectorAll('.table-row');
        var contentCell = clones.contentCell.cloneNode(true);

        if (afterID !== undefined) {

            var afterIndex = data.table.order.columns.indexOf(parseInt(afterID));
            data.table.order.columns.splice(++afterIndex, 0, columnID);
        } else data.table.order.columns.push(columnID);

        actionCell.setAttribute('data-column', columnID.toString());
        headerCell.setAttribute('data-column', columnID.toString());
        contentCell.setAttribute('data-column', columnID.toString());

        if (afterID === undefined) {

            actionRow.appendChild(actionCell);
            headerRow.appendChild(headerCell);

            if (resumeData !== undefined) {

                if (resumeData.header) {
                    headerCell.innerText = resumeData.header;
                    triggerEvent(headerCell, 'input');
                }
            }

            contentRows.forEach(function (row, index) {

                var currentCell = contentCell.cloneNode(true);
                row.appendChild(currentCell);

                if (resumeData !== undefined) {

                    if (resumeData.data[index] !== undefined) {
                        currentCell.innerText = resumeData.data[index];
                        triggerEvent(currentCell, 'input');
                    }

                    // If hidden row
                    var rowID = row.getAttribute('data-row');
                    if (data.table.hidden) if (data.table.hidden.rows.indexOf(rowID) !== -1) currentCell.classList.add('hidden');
                }
            });
        } else {

            var afterAction = actionRow.querySelector('[data-column="' + afterID + '"]');
            var afterHeader = headerRow.querySelector('[data-column="' + afterID + '"]');
            var done = false;

            actionRow.insertBefore(actionCell, afterAction.nextSibling);
            headerRow.insertBefore(headerCell, afterHeader.nextSibling);

            contentRows.forEach(function (row) {

                if (done) return false;

                var afterCell = row.querySelector('[data-column="' + afterID + '"]');
                var clone = contentCell.cloneNode(true);

                row.insertBefore(clone, afterCell.nextSibling);
            });
        }

        if (resumeData !== undefined) {

            // If column is hidden
            if (resumeData.hidden !== undefined) triggerEvent(actionCell.children[0], 'click');
        }

        ++componentsModule.modules.table.data[identifier].dimensions[0];
        return table;
    },

    allowHorizontalScrolling: function allowHorizontalScrolling(contentElement) {

        componentsModule.initializeEvent({

            event: 'wheel',
            element: contentElement,

            content: function content(event) {

                this.scrollLeft -= -(event.deltaY * 20);
                event.preventDefault();
            }

        });
    },

    createTemplateClones: function createTemplateClones(element) {

        var current = componentsModule.modules.table;
        var template = current.template;
        var clones = current.clones;

        // Save parent template
        if (template === false) current.template = template = element.querySelector('#template_inline_table_components').cloneNode(true).children[0];

        // Other clones
        if (clones.actionRow === false) clones.actionRow = template.querySelector('.table-action-row').cloneNode(true);

        if (clones.headerActionFirst === false) clones.headerActionFirst = template.querySelector('.table-header-action-first').cloneNode(true);

        if (clones.headerAction === false) clones.headerAction = template.querySelector('.table-header-action').cloneNode(true);

        if (clones.emptyCell === false) clones.emptyCell = document.createElement('td');

        if (clones.headerRow === false) clones.headerRow = template.querySelector('.table-header-row').cloneNode(true);

        if (clones.asideActionFirst === false) clones.asideActionFirst = template.querySelector('.table-aside-action-first').cloneNode(true);

        if (clones.headerCell === false) clones.headerCell = template.querySelector('th[contenteditable=true]').cloneNode(true);

        if (clones.asideAction === false) clones.asideAction = template.querySelector('.table-aside-action').cloneNode(true);

        if (clones.contentCell === false) clones.contentCell = template.querySelector('td[contenteditable=true]').cloneNode(true);

        if (clones.tableRow === false) clones.tableRow = template.querySelector('.table-row').cloneNode(true);
    },

    create: function create(identifier, element, resumeData) {

        var current = componentsModule.modules.table;
        var contentElement = element.querySelector('div.table-box');
        var nameInput = element.querySelector('input[name=component_inline_table_name]');
        var clones = current.clones;
        var data = current.data;

        // Create template clones
        current.createTemplateClones(element);

        var table = document.createElement('table');
        var actionRow = clones.actionRow.cloneNode(true);
        var headerRow = clones.headerRow.cloneNode(true);
        var firstColumnID = Math.floor(Math.random() * (999999 - 100000)) + 100000;
        var firstRowID = Math.floor(Math.random() * (9999999 - 1000000)) + 1000000;
        var addRowElement = contentElement.querySelector('.table-add-button');

        current.allowHorizontalScrolling(contentElement);

        // Create table data
        data[identifier] = {

            title: '',
            table: {

                hidden: {
                    columns: [],
                    rows: []
                },

                header: {},
                rows: {},
                name: '',

                order: {
                    rows: [],
                    columns: []
                }

            },

            dimensions: [0, 0],
            disabled: 0

        };

        // Create events
        componentsModule.initializeEvents([{
            // Serialize table name
            event: 'input',
            element: nameInput,
            content: function content(event) {
                data[identifier].table.name = event.target.value.trim();
            }
        }, {
            // Delegate click events
            event: 'click',
            element: table,
            content: function content(event) {

                var target = event.target;

                // Hide column
                if (target.matches('.table-hide-column')) {

                    var columnID = target.parentNode.getAttribute('data-column');

                    var hiddenIndex = void 0;
                    var isHidden = ~(hiddenIndex = data[identifier].table.hidden.columns.indexOf(columnID));

                    var rowsList = table.querySelectorAll('tr');
                    var rowSelector = '[data-column="' + columnID + '"]';

                    if (isHidden) {

                        rowsList.forEach(function (row) {

                            var rowID = row.getAttribute('data-row');
                            var rowColumn = row.querySelector(rowSelector);
                            var isHiddenRow = ~data[identifier].table.hidden.rows.indexOf(rowID);

                            if (isHiddenRow) return true;

                            if (rowColumn) rowColumn.classList.remove('hidden');
                        });

                        data[identifier].table.hidden.columns.splice(hiddenIndex, 1);
                    } else {

                        rowsList.forEach(function (row) {

                            var rowColumn = row.querySelector(rowSelector);

                            if (rowColumn) rowColumn.classList.add('hidden');
                        });

                        data[identifier].table.hidden.columns.push(columnID);
                    }
                }

                // Hide row
                else if (target.matches('.table-hide-row')) {

                        var rowID = target.parentNode.parentNode.getAttribute('data-row');

                        var _hiddenIndex = void 0;
                        var _isHidden = ~(_hiddenIndex = data[identifier].table.hidden.rows.indexOf(rowID));

                        var row = table.querySelector('[data-row="' + rowID + '"]');

                        if (_isHidden) {

                            var columnsList = row.querySelectorAll('[data-column]');
                            row.children[0].classList.remove('hidden');

                            columnsList.forEach(function (column) {

                                var columnID = column.getAttribute('data-column');
                                var isHiddenColumn = ~data[identifier].table.hidden.columns.indexOf(columnID);

                                if (isHiddenColumn) return true;

                                column.classList.remove('hidden');
                            });

                            data[identifier].table.hidden.rows.splice(_hiddenIndex, 1);
                        } else {

                            Array.from(row.children).forEach(function (column) {

                                column.classList.add('hidden');
                            });

                            data[identifier].table.hidden.rows.push(rowID);
                        }
                    }

                    // Add column
                    else if (target.matches('.table-new-column')) {

                            var _columnID2 = target.parentNode.getAttribute('data-column');
                            current.addColumn(table, identifier, _columnID2);
                        }

                        // Delete column
                        else if (target.matches('.table-delete-column')) {

                                var _columnID3 = target.parentNode.getAttribute('data-column');
                                var _rowsList = Array.from(table.querySelectorAll('tr'));
                                var columnCells = table.querySelectorAll('[data-column="' + _columnID3 + '"');
                                var _rowID = _rowsList[1].getAttribute('data-row');
                                var headerIdentifier = _columnID3 + '.' + _rowID;

                                Array.from(columnCells).forEach(function (cell, index) {

                                    _rowsList[index].removeChild(cell);
                                });

                                --data[identifier].dimensions[0];
                                delete data[identifier].table.header[headerIdentifier];

                                var _hiddenIndex2 = data[identifier].table.hidden.columns.indexOf(_columnID3);
                                if (~_hiddenIndex2) data[identifier].table.hidden.columns.splice(_hiddenIndex2, 1);

                                var orderIndex = data[identifier].table.order.columns.indexOf(parseInt(_columnID3));
                                if (~orderIndex) data[identifier].table.order.columns.splice(orderIndex, 1);

                                Object.keys(data[identifier].table.rows).forEach(function (rowID) {

                                    delete data[identifier].table.rows[rowID][_columnID3];
                                });
                            }

                            // Add row
                            else if (target.matches('.table-new-row')) {

                                    var eventRow = target.parentNode.parentNode;
                                    current.addRow(table, identifier, eventRow);
                                }

                                // Delete row
                                else if (target.matches('.table-delete-row')) {

                                        var parent = target.parentNode.parentNode;
                                        var _rowID2 = parent.getAttribute('data-row');
                                        var _columnID4 = parent.children[1].getAttribute('data-column');
                                        var _headerIdentifier = _columnID4 + '.' + _rowID2;
                                        var _hiddenIndex3 = data[identifier].table.hidden.rows.indexOf(_rowID2.toString());
                                        var _orderIndex = data[identifier].table.order.rows.indexOf(parseInt(_rowID2));

                                        if (~_hiddenIndex3) data[identifier].table.hidden.rows.splice(_hiddenIndex3, 1);

                                        if (~_orderIndex) data[identifier].table.order.rows.splice(_orderIndex, 1);

                                        delete data[identifier].table.rows[_rowID2];
                                        delete data[identifier].table.header[_headerIdentifier];
                                        --data[identifier].dimensions[1];

                                        parent.parentNode.removeChild(parent);
                                    }
            }
        }, {
            // Add new row at the end
            event: 'click',
            element: addRowElement,
            content: function content() {

                current.addRow(table, identifier);
            }
        }, {
            // Delegate input events
            event: 'input',
            element: table,
            content: function content(event) {

                var target = event.target;

                // Serialize table headers
                if (target.matches('th[contenteditable]')) {

                    var columnID = target.getAttribute('data-column');
                    var rowID = target.parentNode.getAttribute('data-row');
                    var headerIdentifier = columnID + '.' + rowID;

                    data[identifier].table.header[headerIdentifier] = target.innerText.trim();
                }

                // Serialize table cells
                else if (target.matches('td[contenteditable]')) {

                        var _columnID5 = target.getAttribute('data-column');
                        var _rowID3 = target.parentNode.getAttribute('data-row');

                        data[identifier].table.rows[_rowID3][_columnID5] = target.innerText.trim();
                    }
            }
        }]);

        // Render action row ___________________________________________________________________________________________
        // ACTION ROW PROTOTYPE: | empty cell | header action cell first |
        var emptyClone = clones.emptyCell.cloneNode(true);
        emptyClone.classList.add('table-aside-action');

        actionRow.appendChild(emptyClone);
        actionRow.appendChild(clones.headerActionFirst.cloneNode(true));

        // Save row identifier
        data[identifier].table.order.columns.push(firstColumnID);
        actionRow.children[1].setAttribute('data-column', firstColumnID.toString());

        // Render header row ___________________________________________________________________________________________
        // HEADER ROW PROTOTYPE: | aside action cell first | header cell |
        headerRow.appendChild(clones.asideActionFirst.cloneNode(true));
        headerRow.appendChild(clones.headerCell.cloneNode(true));

        // Save row identifier and data
        data[identifier].table.rows[firstRowID] = {};
        data[identifier].table.order.rows.push(firstRowID);
        headerRow.setAttribute('data-row', firstRowID.toString());
        headerRow.children[1].setAttribute('data-column', firstColumnID.toString());

        // Show complete table
        table.appendChild(actionRow);
        table.appendChild(headerRow);

        // Resume data
        if (resumeData !== undefined) {

            // Initialize table name
            nameInput.value = resumeData.table.name.trim();
            triggerEvent(nameInput, 'input');

            // Change table global header
            var firstRow = resumeData.table.order.rows[0];
            var firstColumn = resumeData.table.order.columns[0];
            var headerIdentifier = firstColumn + '.' + firstRow;

            if (resumeData.table.header) {
                headerRow.children[1].innerText = resumeData.table.header[headerIdentifier];
                triggerEvent(headerRow.children[1], 'input');
            }

            // Show / Hide first row and column
            if (resumeData.table.hidden) {

                if (resumeData.table.hidden.columns) {

                    if (resumeData.table.hidden.columns.indexOf(firstColumn) !== -1) triggerEvent(actionRow.children[1].children[0], 'click');
                }

                if (resumeData.table.hidden.rows) {

                    if (resumeData.table.hidden.rows.indexOf(firstRow) !== -1) triggerEvent(headerRow.children[0].children[0], 'click');
                }
            }

            // Render rest of the table
            // Create table rows
            for (var i = 0; i < resumeData.dimensions[1]; ++i) {

                var rowID = resumeData.table.order.rows[i + 1];
                var headerID = firstColumn + '.' + rowID;
                var rowData = {};

                if (resumeData.table.hidden) if (resumeData.table.hidden.rows) rowData.hidden = resumeData.table.hidden.rows.indexOf(rowID) !== -1;

                if (resumeData.table.header) rowData.header = resumeData.table.header[headerID];

                current.addRow(table, identifier, undefined, rowData);
            }

            // Create table columns

            var _loop = function _loop(_i) {

                var columnID = resumeData.table.order.columns[_i + 1];
                var headerID = columnID + '.' + firstRow;
                var columnData = {};

                if (resumeData.table.hidden) if (resumeData.table.hidden.columns) columnData.hidden = resumeData.table.hidden.columns.indexOf(columnID) !== -1;

                if (resumeData.table.header) columnData.header = resumeData.table.header[headerID];

                columnData.data = [];

                if (resumeData.table.rows) resumeData.table.order.rows.forEach(function (row) {

                    if (resumeData.table.rows[row] === undefined) return false;

                    if (resumeData.table.rows[row][columnID]) columnData.data.push(resumeData.table.rows[row][columnID]);
                });

                current.addColumn(table, identifier, undefined, columnData);
            };

            for (var _i = 0; _i < resumeData.dimensions[0]; ++_i) {
                _loop(_i);
            }
        } else {

            // Create table rows
            for (var _i2 = 0; _i2 < 4; ++_i2) {
                current.addRow(table, identifier);
            } // Create table columns
            for (var _i3 = 0; _i3 < 3; ++_i3) {
                current.addColumn(table, identifier);
            }
        }

        contentElement.appendChild(table);
    }

};

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.table = { data: {}, template: false, clones: { clone: false, actionRow: false, headerRow: false, tableRow: false, headerActionFirst: false, headerAction: false, asideActionFirst: false, asideAction: false, headerCell: false, contentCell: false, emptyCell: false }, resumeInline: function resumeInline(b, c, a) {
    var current = componentsModule.modules.table;current.create(b, c, a);
  }, validate: function validate() {
    return true;
  }, serialize: function serialize() {
    return componentsModule.modules.table.data;
  }, addRow: function addRow(c, b, d, a) {
    var current = componentsModule.modules.table;var clones = current.clones;var data = current.data[b];var tableRow = clones.tableRow.cloneNode(true);var actionCell = clones.asideAction.cloneNode(true);var columnID = data.table.order.columns[0];var headerCell = clones.headerCell.cloneNode(true);var rowID = Math.floor(Math.random() * (9999999 - 1000000)) + 1000000;tableRow.appendChild(actionCell);headerCell.setAttribute("data-column", data.table.order.columns[0]);tableRow.appendChild(headerCell);data.table.rows[rowID] = {};tableRow.setAttribute("data-row", rowID);if (d === undefined) {
      data.table.order.rows.push(rowID);
    } else {
      var beforeID = parseFloat(d.getAttribute("data-row"));var beforeIndex = data.table.order.rows.indexOf(beforeID);if (beforeIndex === -1) {
        return false;
      }data.table.order.rows.splice(beforeIndex, 0, rowID);
    }if (data.table.hidden) {
      if (data.table.hidden.columns.indexOf(columnID) !== -1) {
        headerCell.classList.add("hidden");
      }
    }for (var i = 0; i < data.dimensions[0]; ++i) {
      var contentCell = clones.contentCell.cloneNode(true);var _columnID = data.table.order.columns[+i + 1];contentCell.setAttribute("data-column", _columnID);tableRow.appendChild(contentCell);
    }if (!d) {
      c.appendChild(tableRow);
    } else {
      c.insertBefore(tableRow, d);
    }if (a !== undefined) {
      if (a.hidden) {
        triggerEvent(actionCell.children[0], "click");
      }if (a.header) {
        headerCell.innerText = a.header;triggerEvent(headerCell, "input");
      }
    }++data.dimensions[1];return c;
  }, addColumn: function addColumn(d, c, b, a) {
    var current = componentsModule.modules.table;var data = current.data[c];var clones = current.clones;var columnID = Math.floor(Math.random() * (999999 - 100000)) + 100000;var actionRow = d.querySelector(".table-action-row");var actionCell = clones.headerAction.cloneNode(true);var headerRow = d.querySelector(".table-header-row");var headerCell = clones.headerCell.cloneNode(true);var contentRows = d.querySelectorAll(".table-row");var contentCell = clones.contentCell.cloneNode(true);if (b !== undefined) {
      var afterIndex = data.table.order.columns.indexOf(parseInt(b));data.table.order.columns.splice(++afterIndex, 0, columnID);
    } else {
      data.table.order.columns.push(columnID);
    }actionCell.setAttribute("data-column", columnID.toString());headerCell.setAttribute("data-column", columnID.toString());contentCell.setAttribute("data-column", columnID.toString());if (b === undefined) {
      actionRow.appendChild(actionCell);headerRow.appendChild(headerCell);if (a !== undefined) {
        if (a.header) {
          headerCell.innerText = a.header;triggerEvent(headerCell, "input");
        }
      }contentRows.forEach(function (f, e) {
        var currentCell = contentCell.cloneNode(true);f.appendChild(currentCell);if (a !== undefined) {
          if (a.data[e] !== undefined) {
            currentCell.innerText = a.data[e];triggerEvent(currentCell, "input");
          }var rowID = f.getAttribute("data-row");if (data.table.hidden) {
            if (data.table.hidden.rows.indexOf(rowID) !== -1) {
              currentCell.classList.add("hidden");
            }
          }
        }
      });
    } else {
      var afterAction = actionRow.querySelector('[data-column="' + b + '"]');var afterHeader = headerRow.querySelector('[data-column="' + b + '"]');var done = false;actionRow.insertBefore(actionCell, afterAction.nextSibling);headerRow.insertBefore(headerCell, afterHeader.nextSibling);contentRows.forEach(function (e) {
        if (done) {
          return false;
        }var afterCell = e.querySelector('[data-column="' + b + '"]');var clone = contentCell.cloneNode(true);e.insertBefore(clone, afterCell.nextSibling);
      });
    }if (a !== undefined) {
      if (a.hidden !== undefined) {
        triggerEvent(actionCell.children[0], "click");
      }
    }++componentsModule.modules.table.data[c].dimensions[0];return d;
  }, allowHorizontalScrolling: function allowHorizontalScrolling(a) {
    componentsModule.initializeEvent({ event: "wheel", element: a, content: function content(b) {
        this.scrollLeft -= -(b.deltaY * 20);b.preventDefault();
      } });
  }, createTemplateClones: function createTemplateClones(a) {
    var current = componentsModule.modules.table;var template = current.template;var clones = current.clones;if (template === false) {
      current.template = template = a.querySelector("#template_inline_table_components").cloneNode(true).children[0];
    }if (clones.actionRow === false) {
      clones.actionRow = template.querySelector(".table-action-row").cloneNode(true);
    }if (clones.headerActionFirst === false) {
      clones.headerActionFirst = template.querySelector(".table-header-action-first").cloneNode(true);
    }if (clones.headerAction === false) {
      clones.headerAction = template.querySelector(".table-header-action").cloneNode(true);
    }if (clones.emptyCell === false) {
      clones.emptyCell = document.createElement("td");
    }if (clones.headerRow === false) {
      clones.headerRow = template.querySelector(".table-header-row").cloneNode(true);
    }if (clones.asideActionFirst === false) {
      clones.asideActionFirst = template.querySelector(".table-aside-action-first").cloneNode(true);
    }if (clones.headerCell === false) {
      clones.headerCell = template.querySelector("th[contenteditable=true]").cloneNode(true);
    }if (clones.asideAction === false) {
      clones.asideAction = template.querySelector(".table-aside-action").cloneNode(true);
    }if (clones.contentCell === false) {
      clones.contentCell = template.querySelector("td[contenteditable=true]").cloneNode(true);
    }if (clones.tableRow === false) {
      clones.tableRow = template.querySelector(".table-row").cloneNode(true);
    }
  }, create: function create(c, d, a) {
    var current = componentsModule.modules.table;var contentElement = d.querySelector("div.table-box");var nameInput = d.querySelector("input[name=component_inline_table_name]");var clones = current.clones;var data = current.data;current.createTemplateClones(d);var table = document.createElement("table");var actionRow = clones.actionRow.cloneNode(true);var headerRow = clones.headerRow.cloneNode(true);var firstColumnID = Math.floor(Math.random() * (999999 - 100000)) + 100000;var firstRowID = Math.floor(Math.random() * (9999999 - 1000000)) + 1000000;var addRowElement = contentElement.querySelector(".table-add-button");current.allowHorizontalScrolling(contentElement);data[c] = { title: "", table: { hidden: { columns: [], rows: [] }, header: {}, rows: {}, name: "", order: { rows: [], columns: [] } }, dimensions: [0, 0], disabled: 0 };componentsModule.initializeEvents([{ event: "input", element: nameInput, content: function content(j) {
        data[c].table.name = j.target.value.trim();
      } }, { event: "click", element: table, content: function content(j) {
        var target = j.target;if (target.matches(".table-hide-column")) {
          var e = target.parentNode.getAttribute("data-column");var hiddenIndex = void 0;var isHidden = ~(hiddenIndex = data[c].table.hidden.columns.indexOf(e));var rowsList = table.querySelectorAll("tr");var rowSelector = '[data-column="' + e + '"]';if (isHidden) {
            rowsList.forEach(function (k) {
              var f = k.getAttribute("data-row");var rowColumn = k.querySelector(rowSelector);var isHiddenRow = ~data[c].table.hidden.rows.indexOf(f);if (isHiddenRow) {
                return true;
              }if (rowColumn) {
                rowColumn.classList.remove("hidden");
              }
            });data[c].table.hidden.columns.splice(hiddenIndex, 1);
          } else {
            rowsList.forEach(function (k) {
              var rowColumn = k.querySelector(rowSelector);if (rowColumn) {
                rowColumn.classList.add("hidden");
              }
            });data[c].table.hidden.columns.push(e);
          }
        } else {
          if (target.matches(".table-hide-row")) {
            var f = target.parentNode.parentNode.getAttribute("data-row");var _hiddenIndex = void 0;var _isHidden = ~(_hiddenIndex = data[c].table.hidden.rows.indexOf(f));var row = table.querySelector('[data-row="' + f + '"]');if (_isHidden) {
              var columnsList = row.querySelectorAll("[data-column]");row.children[0].classList.remove("hidden");columnsList.forEach(function (k) {
                var e = k.getAttribute("data-column");var isHiddenColumn = ~data[c].table.hidden.columns.indexOf(e);if (isHiddenColumn) {
                  return true;
                }k.classList.remove("hidden");
              });data[c].table.hidden.rows.splice(_hiddenIndex, 1);
            } else {
              Array.from(row.children).forEach(function (k) {
                k.classList.add("hidden");
              });data[c].table.hidden.rows.push(f);
            }
          } else {
            if (target.matches(".table-new-column")) {
              var _e = target.parentNode.getAttribute("data-column");current.addColumn(table, c, _e);
            } else {
              if (target.matches(".table-delete-column")) {
                var _e2 = target.parentNode.getAttribute("data-column");var _rowsList = Array.from(table.querySelectorAll("tr"));var columnCells = table.querySelectorAll('[data-column="' + _e2 + '"');var _f = _rowsList[1].getAttribute("data-row");var b = _e2 + "." + _f;Array.from(columnCells).forEach(function (k, l) {
                  _rowsList[l].removeChild(k);
                });--data[c].dimensions[0];delete data[c].table.header[b];var _hiddenIndex2 = data[c].table.hidden.columns.indexOf(_e2);if (~_hiddenIndex2) {
                  data[c].table.hidden.columns.splice(_hiddenIndex2, 1);
                }var orderIndex = data[c].table.order.columns.indexOf(parseInt(_e2));if (~orderIndex) {
                  data[c].table.order.columns.splice(orderIndex, 1);
                }Object.keys(data[c].table.rows).forEach(function (k) {
                  delete data[c].table.rows[k][_e2];
                });
              } else {
                if (target.matches(".table-new-row")) {
                  var eventRow = target.parentNode.parentNode;current.addRow(table, c, eventRow);
                } else {
                  if (target.matches(".table-delete-row")) {
                    var parent = target.parentNode.parentNode;var _f2 = parent.getAttribute("data-row");var _e3 = parent.children[1].getAttribute("data-column");var _b = _e3 + "." + _f2;var _hiddenIndex3 = data[c].table.hidden.rows.indexOf(_f2.toString());var _orderIndex = data[c].table.order.rows.indexOf(parseInt(_f2));if (~_hiddenIndex3) {
                      data[c].table.hidden.rows.splice(_hiddenIndex3, 1);
                    }if (~_orderIndex) {
                      data[c].table.order.rows.splice(_orderIndex, 1);
                    }delete data[c].table.rows[_f2];delete data[c].table.header[_b];--data[c].dimensions[1];parent.parentNode.removeChild(parent);
                  }
                }
              }
            }
          }
        }
      } }, { event: "click", element: addRowElement, content: function content() {
        current.addRow(table, c);
      } }, { event: "input", element: table, content: function content(j) {
        var target = j.target;if (target.matches("th[contenteditable]")) {
          var e = target.getAttribute("data-column");var f = target.parentNode.getAttribute("data-row");var b = e + "." + f;data[c].table.header[b] = target.innerText.trim();
        } else {
          if (target.matches("td[contenteditable]")) {
            var _e4 = target.getAttribute("data-column");var _f3 = target.parentNode.getAttribute("data-row");data[c].table.rows[_f3][_e4] = target.innerText.trim();
          }
        }
      } }]);var emptyClone = clones.emptyCell.cloneNode(true);emptyClone.classList.add("table-aside-action");actionRow.appendChild(emptyClone);actionRow.appendChild(clones.headerActionFirst.cloneNode(true));data[c].table.order.columns.push(firstColumnID);actionRow.children[1].setAttribute("data-column", firstColumnID.toString());headerRow.appendChild(clones.asideActionFirst.cloneNode(true));headerRow.appendChild(clones.headerCell.cloneNode(true));data[c].table.rows[firstRowID] = {};data[c].table.order.rows.push(firstRowID);headerRow.setAttribute("data-row", firstRowID.toString());headerRow.children[1].setAttribute("data-column", firstColumnID.toString());table.appendChild(actionRow);table.appendChild(headerRow);if (a !== undefined) {
      nameInput.value = a.table.name.trim();triggerEvent(nameInput, "input");var h = a.table.order.rows[0];var g = a.table.order.columns[0];var b = g + "." + h;if (a.table.header) {
        headerRow.children[1].innerText = a.table.header[b];triggerEvent(headerRow.children[1], "input");
      }if (a.table.hidden) {
        if (a.table.hidden.columns) {
          if (a.table.hidden.columns.indexOf(g) !== -1) {
            triggerEvent(actionRow.children[1].children[0], "click");
          }
        }if (a.table.hidden.rows) {
          if (a.table.hidden.rows.indexOf(h) !== -1) {
            triggerEvent(headerRow.children[0].children[0], "click");
          }
        }
      }for (var i = 0; i < a.dimensions[1]; ++i) {
        var f = a.table.order.rows[i + 1];var headerID = g + "." + f;var rowData = {};if (a.table.hidden) {
          if (a.table.hidden.rows) {
            rowData.hidden = a.table.hidden.rows.indexOf(f) !== -1;
          }
        }if (a.table.header) {
          rowData.header = a.table.header[headerID];
        }current.addRow(table, c, undefined, rowData);
      }
      var _loop = function _loop(_i) {
        var e = a.table.order.columns[_i + 1];var headerID = e + "." + h;var columnData = {};if (a.table.hidden) {
          if (a.table.hidden.columns) {
            columnData.hidden = a.table.hidden.columns.indexOf(e) !== -1;
          }
        }if (a.table.header) {
          columnData.header = a.table.header[headerID];
        }columnData.data = [];if (a.table.rows) {
          a.table.order.rows.forEach(function (j) {
            if (a.table.rows[j] === undefined) {
              return false;
            }if (a.table.rows[j][e]) {
              columnData.data.push(a.table.rows[j][e]);
            }
          });
        }current.addColumn(table, c, undefined, columnData);
      };

      for (var _i = 0; _i < a.dimensions[0]; ++_i) {
        _loop(_i);
      }
    } else {
      for (var _i2 = 0; _i2 < 4; ++_i2) {
        current.addRow(table, c);
      }for (var _i3 = 0; _i3 < 3; ++_i3) {
        current.addColumn(table, c);
      }
    }contentElement.appendChild(table);
  } };

/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.tags = {

    start: function start() {

        // Save elements
        var current = componentsModule.modules.tags;
        current.parentElement = document.querySelector('[data-component=tags]');
        current.inputElement = current.parentElement.querySelector('input');
        current.listElement = current.parentElement.querySelector('.tags-list');
        current.templateElement = current.parentElement.querySelector('#template_component_tags_item').childNodes[0];

        // Events
        componentsModule.initializeEvents([{
            // Delegate click event
            event: 'click',
            element: current.parentElement,
            content: function content(event) {

                // Remove tag
                if (event.target.matches('.tag-remove')) {

                    current.listElement.removeChild(event.target.parentNode);

                    reloadPackery();
                }
            }
        }, {
            // Add tags
            event: 'keyup',
            element: current.inputElement,
            content: function content(event) {

                if (!event.keyCode || event.keyCode !== 13) return true;

                current.addTag();
            }
        }]);
    },

    resume: function resume() {

        // Save current instance
        var current = componentsModule.modules.tags;
        var data = current.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var tags = JSON.parse(data).tags;

        if (tags === null) return true;

        current.addTag(tags.join(','));
    },

    addTag: function addTag(list) {

        var current = componentsModule.modules.tags;
        var tags = list || current.inputElement.value.trim();

        if (!validateTags(tags)) return true;

        var tagList = tags.split(',');

        tagList.map(function (tag) {

            tag = tag.trim();
            var currentTags = current.serialize().tags;

            if (~currentTags.indexOf(tag)) return true;

            var template = current.templateElement.cloneNode(true);
            template.innerHTML = '#' + tag + template.innerHTML;

            current.inputElement.value = '';
            current.listElement.appendChild(template);

            reloadPackery();
        });
    },

    validate: function validate() {

        var tags = componentsModule.modules.tags.serialize().tags;

        return validateTags(tags);
    },

    serialize: function serialize() {

        var tagElements = componentsModule.modules.tags.listElement.childNodes;

        var tagList = Array.from(tagElements).map(function (tagElement) {

            return tagElement.innerText.trim().replace('#', '');
        });

        return {

            tags: tagList

        };
    }

};

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.tags = { start: function start() {
    var current = componentsModule.modules.tags;current.parentElement = document.querySelector("[data-component=tags]");current.inputElement = current.parentElement.querySelector("input");current.listElement = current.parentElement.querySelector(".tags-list");current.templateElement = current.parentElement.querySelector("#template_component_tags_item").childNodes[0];componentsModule.initializeEvents([{ event: "click", element: current.parentElement, content: function content(a) {
        if (a.target.matches(".tag-remove")) {
          current.listElement.removeChild(a.target.parentNode);reloadPackery();
        }
      } }, { event: "keyup", element: current.inputElement, content: function content(a) {
        if (!a.keyCode || a.keyCode !== 13) {
          return true;
        }current.addTag();
      } }]);
  }, resume: function resume() {
    var current = componentsModule.modules.tags;var b = current.parentElement.getAttribute("data-resume");if (b === "") {
      return true;
    }var a = JSON.parse(b).tags;if (a === null) {
      return true;
    }current.addTag(a.join(","));
  }, addTag: function addTag(b) {
    var current = componentsModule.modules.tags;var a = b || current.inputElement.value.trim();if (!validateTags(a)) {
      return true;
    }var c = a.split(",");c.map(function (d) {
      d = d.trim();var e = current.serialize().tags;if (~e.indexOf(d)) {
        return true;
      }var template = current.templateElement.cloneNode(true);template.innerHTML = "#" + d + template.innerHTML;current.inputElement.value = "";current.listElement.appendChild(template);reloadPackery();
    });
  }, validate: function validate() {
    var a = componentsModule.modules.tags.serialize().tags;return validateTags(a);
  }, serialize: function serialize() {
    var a = componentsModule.modules.tags.listElement.childNodes;var tagList = Array.from(a).map(function (b) {
      return b.innerText.trim().replace("#", "");
    });return { tags: tagList };
  } };

/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.thumbnail = {

    start: function start() {

        // Save elements
        var current = componentsModule.modules.thumbnail;
        current.parentElement = document.querySelector('[data-component=thumbnail]');
        current.inputBox = current.parentElement.querySelector('.input-box');
        current.mediaButton = current.inputBox.querySelector('.image_manager');
        current.mediaInput = current.inputBox.querySelector('input');
        current.messageElement = current.inputBox.querySelector('.validate-message');
        current.templateElement = current.parentElement.querySelector('#template_component_thumbnail_image').childNodes[0];

        // Events
        componentsModule.initializeEvents([{
            // Delegate click events
            event: 'click',
            element: current.parentElement,
            content: function content(event) {

                // Open MediaManager
                if (event.target.matches('.image_manager')) {

                    managerActiveInstance = new MediaManager({
                        manager: 'images',
                        onSelect: function onSelect(path) {

                            current.addNew(path, false);
                        }
                    });
                }

                // Remove thumbnail
                else if (event.target.matches('.thumbnail-remove')) {

                        current.inputBox.classList.remove('hide');

                        current.parentElement.removeChild(current.parentElement.querySelector('div.component-instance'));

                        reloadPackery();
                    }
            }
        }, {
            // Enter custom URL to image
            event: 'keypress',
            element: current.mediaInput,
            content: function content(event) {

                if (!event.keyCode || event.keyCode !== 13) return false;

                var path = event.target.value.trim();

                current.validateInput(path, function () {

                    current.addNew(path, true);
                });
            }
        }, {
            // Real-time URL validation
            event: 'change keyup',
            element: current.mediaInput,
            content: function content(event) {

                current.validateInput(event.target.value.trim());
            }
        }]);
    },

    resume: function resume() {

        // Save current instance
        var current = componentsModule.modules.thumbnail;
        var data = current.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var thumbnail = JSON.parse(data).thumbnail;

        if (thumbnail === '') return true;

        current.addNew(thumbnail, !~thumbnail.indexOf('app/Data/Files/Images/'));
    },

    removeCurrent: function removeCurrent(parent) {

        if (parent.querySelector('div.thumbnail-image.component-instance')) parent.removeChild(parent.querySelector('div.thumbnail-image.component-instance'));
    },

    addNew: function addNew(path, outside) {

        path = path.replace('app/Data/Files/Images/', '');

        var current = componentsModule.modules.thumbnail;
        var text = path;
        var template = current.templateElement.cloneNode(true);

        current.removeCurrent(current.parentElement);
        current.inputBox.value = '';

        if (!outside) path = 'app/Data/Files/Images/' + path;

        template.setAttribute('data-path', path);
        template.classList.add('component-instance');

        template.childNodes[0].setAttribute('src', path);
        template.childNodes[0].setAttribute('alt', path);

        template.childNodes[1].innerText = text;

        current.parentElement.appendChild(template);

        current.inputBox.classList.add('hide');
        closeMediaManager();
        reloadPackery();
    },

    validateInput: function validateInput(path, onSuccess, onError) {

        var current = componentsModule.modules.thumbnail;

        if (!validateUrl(path)) return showValidationResult(current.messageElement, 'COMPONENT_URL_INVALID', false, reloadPackery);

        new Promise(function (resolve) {

            var image = new Image();

            image.onload = function () {
                resolve(true);
            };

            image.onerror = function () {
                resolve(false);
            };

            image.src = path;
        }).then(function (result) {

            if (result) {

                showValidationResult(current.messageElement, 'COMPONENT_URL_INVALID', true, reloadPackery);

                if (onSuccess) onSuccess();
            } else {

                showValidationResult(current.messageElement, 'COMPONENT_URL_INVALID', false, reloadPackery);

                if (onError) onError();
            }
        });
    },

    validate: function validate() {

        return true;
    },

    serialize: function serialize() {

        var current = componentsModule.modules.thumbnail;
        var instance = current.parentElement.querySelector('div.thumbnail-image.component-instance');
        var data = '';

        if (instance) data = instance.getAttribute('data-path');

        return {
            thumbnail: data
        };
    }

};

/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.thumbnail = { start: function start() {
    var current = componentsModule.modules.thumbnail;current.parentElement = document.querySelector("[data-component=thumbnail]");current.inputBox = current.parentElement.querySelector(".input-box");current.mediaButton = current.inputBox.querySelector(".image_manager");current.mediaInput = current.inputBox.querySelector("input");current.messageElement = current.inputBox.querySelector(".validate-message");current.templateElement = current.parentElement.querySelector("#template_component_thumbnail_image").childNodes[0];componentsModule.initializeEvents([{ event: "click", element: current.parentElement, content: function content(a) {
        if (a.target.matches(".image_manager")) {
          managerActiveInstance = new MediaManager({ manager: "images", onSelect: function onSelect(b) {
              current.addNew(b, false);
            } });
        } else {
          if (a.target.matches(".thumbnail-remove")) {
            current.inputBox.classList.remove("hide");current.parentElement.removeChild(current.parentElement.querySelector("div.component-instance"));reloadPackery();
          }
        }
      } }, { event: "keypress", element: current.mediaInput, content: function content(a) {
        if (!a.keyCode || a.keyCode !== 13) {
          return false;
        }var path = a.target.value.trim();current.validateInput(path, function () {
          current.addNew(path, true);
        });
      } }, { event: "change keyup", element: current.mediaInput, content: function content(a) {
        current.validateInput(a.target.value.trim());
      } }]);
  }, resume: function resume() {
    var current = componentsModule.modules.thumbnail;var a = current.parentElement.getAttribute("data-resume");if (a === "") {
      return true;
    }var b = JSON.parse(a).thumbnail;if (b === "") {
      return true;
    }current.addNew(b, !~b.indexOf("app/Data/Files/Images/"));
  }, removeCurrent: function removeCurrent(a) {
    if (a.querySelector("div.thumbnail-image.component-instance")) {
      a.removeChild(a.querySelector("div.thumbnail-image.component-instance"));
    }
  }, addNew: function addNew(b, a) {
    b = b.replace("app/Data/Files/Images/", "");var current = componentsModule.modules.thumbnail;var text = b;var template = current.templateElement.cloneNode(true);current.removeCurrent(current.parentElement);current.inputBox.value = "";if (!a) {
      b = "app/Data/Files/Images/" + b;
    }template.setAttribute("data-path", b);template.classList.add("component-instance");template.childNodes[0].setAttribute("src", b);template.childNodes[0].setAttribute("alt", b);template.childNodes[1].innerText = text;current.parentElement.appendChild(template);current.inputBox.classList.add("hide");closeMediaManager();reloadPackery();
  }, validateInput: function validateInput(b, c, a) {
    var current = componentsModule.modules.thumbnail;if (!validateUrl(b)) {
      return showValidationResult(current.messageElement, "COMPONENT_URL_INVALID", false, reloadPackery);
    }new Promise(function (d) {
      var image = new Image();image.onload = function () {
        d(true);
      };image.onerror = function () {
        d(false);
      };image.src = b;
    }).then(function (d) {
      if (d) {
        showValidationResult(current.messageElement, "COMPONENT_URL_INVALID", true, reloadPackery);if (c) {
          c();
        }
      } else {
        showValidationResult(current.messageElement, "COMPONENT_URL_INVALID", false, reloadPackery);if (a) {
          a();
        }
      }
    });
  }, validate: function validate() {
    return true;
  }, serialize: function serialize() {
    var current = componentsModule.modules.thumbnail;var instance = current.parentElement.querySelector("div.thumbnail-image.component-instance");var data = "";if (instance) {
      data = instance.getAttribute("data-path");
    }return { thumbnail: data };
  } };

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var title = {
    start: function start() {

        // Save elements
        title.parentElement = document.querySelector('[data-component=title]');
        title.inputElement = title.parentElement.querySelector('input');
        title.titleElement = document.querySelector('.mainline-heading');

        _Utils2.default.registerEvent({

            event: 'keydown keyup change',
            element: title.inputElement,
            content: function content(event) {

                title.titleElement.innerText = event.target.value.trim();
            }

        });
    },
    resume: function resume() {

        // Save current instance
        var data = title.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var object = JSON.parse(data);
        title.inputElement.value = object.title;

        _Utils2.default.triggerEvent(title.inputElement, 'change');
    },
    validate: function validate() {

        var data = title.serialize().title;

        return data.length < 101 && data.length > 0;
    },
    serialize: function serialize() {

        return {
            title: title.inputElement.value.trim()
        };
    }
};

module.exports = title;

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

var _Ajax = __webpack_require__(4);

var _Ajax2 = _interopRequireDefault(_Ajax);

var _Router = __webpack_require__(8);

var _Router2 = _interopRequireDefault(_Router);

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var url = {
    isFree: function isFree() {

        var response = true;

        // Check if slug is in use
        _Ajax2.default.post(_Router2.default.createLink('api/articles.exists.url'), {
            api: {
                url: url.serialize().url,
                ignore: document.querySelector('div.content-wrapper').getAttribute('data-id')
            }
        }, function (data, status) {

            if (status === 'success' && data.success === true) response = !data.data.result;
        });

        return response;
    },
    start: function start() {

        // Save elements
        url.parentElement = document.querySelector('[data-component=url]');
        url.inputElement = url.parentElement.querySelector('input');
        url.messageElement = url.parentElement.querySelector('.validate-message');

        // Real-time url validation
        _Utils2.default.registerEvent({

            event: 'keyup change',
            element: url.inputElement,
            content: function content() {

                _Utils2.default.showValidationResults(url.messageElement, 'COMPONENT_URL_INVALID', url.validate());
            }

        });
    },
    resume: function resume() {

        // Save current instance
        var data = url.parentElement.getAttribute('data-resume');

        if (data === '') return true;

        var object = JSON.parse(data);
        url.inputElement.value = object.url;

        _Utils2.default.triggerEvent(url.inputElement, 'change');
    },
    validate: function validate() {

        var data = url.serialize().url;

        if (!/^[a-z][a-z0-9\-]+[a-z]$/.test(data)) return false;

        if (data.length < 3 || data.length > 120) return false;

        return url.isFree();
    },
    serialize: function serialize() {

        return {
            url: url.inputElement.value.trim()
        };
    }
};

module.exports = url;

/***/ }),
/* 86 */,
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.video = {

    data: {},
    valid: {},

    YT_QUALITY: {
        'small': '240p (LQ)',
        'medium': '360p (SQ)',
        'large': '480p (HQ)',
        'hd720': '720p (HD)',
        'hd1080': '1080p (FullHD)',
        'highres': '1440p+ (QHD+)'
    },

    resumeInline: function resumeInline(identifier, element, resumeData) {

        var current = componentsModule.modules.video;
        var path = resumeData.video;

        current.create(identifier, element);

        current.onSelect(identifier, element, path, true, function (description, align) {

            var descriptionText = resumeData.video_description.trim();

            if (descriptionText === 'false') descriptionText = '';

            description.value = descriptionText;
            triggerEvent(description, 'change');

            align[resumeData.video_align].click();
        });
    },

    videoType: function videoType(path) {

        // Vimeo
        if (/^((?:https?:)?\/\/)?((?:www|m|player)\.)?((?:vimeo\.com))(?:$|\/|)(\S+)?$/gm.test(path)) return 1;

        // YouTube
        else if (/(https?:\/\/.*?youtube\.com)\/watch\?v=(.*)/igm.test(path)) return 0;

            // External videos
            else return -1;
    },

    registerEvents: function registerEvents(template, identifier, contentElement, callback) {

        var alignOptions = template.children[6].querySelectorAll('span');
        componentsModule.initializeEvents([{
            // Serialize description
            event: 'change keyup',
            element: template.children[4].children[1],
            content: function content(event) {
                componentsModule.modules.video.data[identifier].video_description = event.target.value.trim();
            }
        }, {
            // Serialize video position
            event: 'click',
            element: alignOptions,
            content: function content(event) {
                componentsModule.modules.video.data[identifier].video_align = +event.target.getAttribute('data-value');
                alignOptions.forEach(function (item) {
                    item.classList.remove('active');
                });
                event.target.classList.add('active');
            }
        }]);

        template.children[5].addEventListener('click', function () {
            componentsModule.modules.video.removeInstance(identifier, contentElement, template);
        });

        if (callback) callback(template.children[4].children[1], alignOptions);
    },

    loadExternalVideo: function loadExternalVideo(identifier, element, path, template, callback) {

        // Close media manager
        document.querySelector('div.media-manager span.close-manager').click();

        var video = document.createElement('video');
        video.setAttribute('src', path);
        video.classList.add('item-player');
        video.setAttribute('controls', 'true');
        video.volume = .5;

        var contentElement = element.querySelector('div.component-element-content');
        contentElement.classList.add('no-padding');
        contentElement.querySelector('div.select-image').classList.add('hide');

        template.insertBefore(video, template.children[0]);
        contentElement.appendChild(template);

        template.children[1].innerText = path.replace('app/Data/Files/Videos/', '');
        video.addEventListener('loadedmetadata', function () {

            var duration = video.duration;
            var minutes = parseInt(duration / 60, 10);
            var seconds = duration % 60;
            var time = minutes + ':' + pad(Math.round(seconds), 2);
            var width = video.videoWidth;
            var height = video.videoHeight;
            var dimensions = width + 'x' + height;

            template.children[2].innerText = time;
            template.children[3].innerText = dimensions;
        });

        componentsModule.modules.video.registerEvents(template, identifier, contentElement, callback);
    },

    loadYouTubeVideo: function loadYouTubeVideo(identifier, element, path, template, callback) {

        var video = document.createElement('div');
        var id = 'youtube-player-' + identifier;
        video.setAttribute('id', id);

        var contentElement = element.querySelector('div.component-element-content');
        contentElement.classList.add('no-padding');
        contentElement.querySelector('div.select-image').classList.add('hide');

        var container = document.createElement('div');
        container.classList.add('iframe-container');
        container.appendChild(video);

        template.insertBefore(container, template.children[0]);
        contentElement.appendChild(template);

        var videoId = path.split('v=')[1];
        var ampersandPosition = videoId.indexOf('&');
        if (ampersandPosition !== -1) videoId = videoId.substring(0, ampersandPosition);

        function createPlayer() {

            new YT.Player(id, {
                videoId: videoId,
                events: {
                    onReady: function onReady(event) {
                        tmp = event.target.getPlaylist();
                        template.children[1].innerText = event.target.getVideoData().title;
                        var duration = event.target.getDuration();
                        var minutes = parseInt(duration / 60, 10);
                        var seconds = duration % 60;
                        template.children[2].innerText = minutes + ':' + pad(Math.round(seconds), 2);
                        event.target.setPlaybackQuality('medium');
                    },
                    onStateChange: function onStateChange(event) {

                        template.children[3].innerText = event.target.getAvailableQualityLevels()[0] !== undefined ? componentsModule.modules.video.YT_QUALITY[event.target.getAvailableQualityLevels()[0]] : '';
                    }
                }
            });
        }

        setTimeout(createPlayer);

        componentsModule.modules.video.registerEvents(template, identifier, contentElement, callback);
    },

    loadVimeoVideo: function loadVimeoVideo(identifier, element, path, template, callback) {

        var video = getJson('https://vimeo.com/api/oembed.json?url=' + path);

        var contentElement = element.querySelector('div.component-element-content');
        contentElement.classList.add('no-padding');
        contentElement.querySelector('div.select-image').classList.add('hide');

        var container = document.createElement('div');
        container.classList.add('iframe-container');
        container.insertAdjacentHTML('afterbegin', video.html);

        template.insertBefore(container, template.children[0]);
        contentElement.appendChild(template);

        template.children[1].innerText = video.title;
        var duration = video.duration;
        var minutes = parseInt(duration / 60, 10);
        var seconds = duration % 60;
        template.children[2].innerText = minutes + ':' + pad(Math.round(seconds), 2);

        var channelURL = document.createElement('a');
        channelURL.setAttribute('href', video.author_url);
        channelURL.setAttribute('target', '_blank');
        channelURL.innerText = video.author_name;
        template.children[3].appendChild(channelURL);

        componentsModule.modules.video.registerEvents(template, identifier, contentElement, callback);
    },

    removeInstance: function removeInstance(identifier, contentElement, template) {

        contentElement.querySelector('div.input-box.select-image').classList.remove('hide');
        contentElement.removeChild(template);
        contentElement.classList.remove('no-padding');
        delete componentsModule.modules.video.data[identifier];
    },

    remove: function remove(element) {

        element.querySelectorAll('div.component-instance').forEach(function (item) {
            item.querySelector('span.item-remove').click();
        });
    },

    onSelect: function onSelect(identifier, element, path, outside, callback) {

        // Remove current video if any
        componentsModule.modules.video.remove(element);

        // Create path
        if (!outside) path = 'app/Data/Files/Videos/' + path;

        // Save image path and create instance data
        componentsModule.modules.video.data[identifier] = {
            title: '',
            video: path,
            video_description: false,
            video_align: 1,
            disabled: 0
        };

        // Get video type
        var type = componentsModule.modules.video.videoType(path);

        // Create template
        var template = element.querySelector('#template_component_content_video_item').children[0].cloneNode(true);
        template.setAttribute('data-path', path);

        // Load video by type
        switch (type) {
            case -1:
                componentsModule.modules.video.loadExternalVideo(identifier, element, path, template, callback);
                break;
            case 0:
                componentsModule.modules.video.loadYouTubeVideo(identifier, element, path, template, callback);
                break;
            case 1:
                componentsModule.modules.video.loadVimeoVideo(identifier, element, path, template, callback);
                break;
            default:
                return false;
                break;
        }
    },

    create: function create(identifier, element) {
        componentsModule.initializeEvents([{
            // Open media manager
            event: 'click',
            element: element.querySelector('button.inline-image_manager'),
            content: function content() {
                managerActiveInstance = new MediaManager({
                    manager: 'videos',
                    onSelect: function onSelect(path) {
                        componentsModule.modules.video.onSelect(identifier, element, path, false);
                    }
                });
            }
        }, {
            // Add external video with URL
            event: 'keyup',
            element: element.querySelector('input[name=component_inline_video_input]'),
            content: function content(event) {
                if (event.keyCode !== 13 || event.target.value.trim().length < 4) return false;
                componentsModule.modules.video.onSelect(identifier, element, event.target.value.trim(), true);
            }
        }]);
    },

    validate: function validate() {
        return true;
    },

    serialize: function serialize() {
        return componentsModule.modules.video.data;
    }

};

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


componentsModule.modules.video = { data: {}, valid: {}, YT_QUALITY: { small: "240p (LQ)", medium: "360p (SQ)", large: "480p (HQ)", hd720: "720p (HD)", hd1080: "1080p (FullHD)", highres: "1440p+ (QHD+)" }, resumeInline: function resumeInline(b, c, a) {
    var current = componentsModule.modules.video;var path = a.video;current.create(b, c);current.onSelect(b, c, path, true, function (d, e) {
      var descriptionText = a.video_description.trim();if (descriptionText === "false") {
        descriptionText = "";
      }d.value = descriptionText;triggerEvent(d, "change");e[a.video_align].click();
    });
  }, videoType: function videoType(a) {
    if (/^((?:https?:)?\/\/)?((?:www|m|player)\.)?((?:vimeo\.com))(?:$|\/|)(\S+)?$/gm.test(a)) {
      return 1;
    } else {
      if (/(https?:\/\/.*?youtube\.com)\/watch\?v=(.*)/igm.test(a)) {
        return 0;
      } else {
        return -1;
      }
    }
  }, registerEvents: function registerEvents(b, a, c, d) {
    var alignOptions = b.children[6].querySelectorAll("span");componentsModule.initializeEvents([{ event: "change keyup", element: b.children[4].children[1], content: function content(e) {
        componentsModule.modules.video.data[a].video_description = e.target.value.trim();
      } }, { event: "click", element: alignOptions, content: function content(e) {
        componentsModule.modules.video.data[a].video_align = +e.target.getAttribute("data-value");alignOptions.forEach(function (f) {
          f.classList.remove("active");
        });e.target.classList.add("active");
      } }]);b.children[5].addEventListener("click", function () {
      componentsModule.modules.video.removeInstance(a, c, b);
    });if (d) {
      d(b.children[4].children[1], alignOptions);
    }
  }, loadExternalVideo: function loadExternalVideo(a, b, d, c, e) {
    document.querySelector("div.media-manager span.close-manager").click();var video = document.createElement("video");video.setAttribute("src", d);video.classList.add("item-player");video.setAttribute("controls", "true");video.volume = 0.5;var contentElement = b.querySelector("div.component-element-content");contentElement.classList.add("no-padding");contentElement.querySelector("div.select-image").classList.add("hide");c.insertBefore(video, c.children[0]);contentElement.appendChild(c);c.children[1].innerText = d.replace("app/Data/Files/Videos/", "");video.addEventListener("loadedmetadata", function () {
      var duration = video.duration;var minutes = parseInt(duration / 60, 10);var seconds = duration % 60;var time = minutes + ":" + pad(Math.round(seconds), 2);var width = video.videoWidth;var height = video.videoHeight;var dimensions = width + "x" + height;c.children[2].innerText = time;c.children[3].innerText = dimensions;
    });componentsModule.modules.video.registerEvents(c, a, contentElement, e);
  }, loadYouTubeVideo: function loadYouTubeVideo(b, c, e, d, g) {
    var video = document.createElement("div");var f = "youtube-player-" + b;video.setAttribute("id", f);var contentElement = c.querySelector("div.component-element-content");contentElement.classList.add("no-padding");contentElement.querySelector("div.select-image").classList.add("hide");var container = document.createElement("div");container.classList.add("iframe-container");container.appendChild(video);d.insertBefore(container, d.children[0]);contentElement.appendChild(d);var videoId = e.split("v=")[1];var ampersandPosition = videoId.indexOf("&");if (ampersandPosition !== -1) {
      videoId = videoId.substring(0, ampersandPosition);
    }function a() {
      new YT.Player(f, { videoId: videoId, events: { onReady: function onReady(h) {
            tmp = h.target.getPlaylist();d.children[1].innerText = h.target.getVideoData().title;var duration = h.target.getDuration();var minutes = parseInt(duration / 60, 10);var seconds = duration % 60;d.children[2].innerText = minutes + ":" + pad(Math.round(seconds), 2);h.target.setPlaybackQuality("medium");
          }, onStateChange: function onStateChange(h) {
            d.children[3].innerText = h.target.getAvailableQualityLevels()[0] !== undefined ? componentsModule.modules.video.YT_QUALITY[h.target.getAvailableQualityLevels()[0]] : "";
          } } });
    }setTimeout(a);componentsModule.modules.video.registerEvents(d, b, contentElement, g);
  }, loadVimeoVideo: function loadVimeoVideo(a, b, d, c, e) {
    var video = getJson("https://vimeo.com/api/oembed.json?url=" + d);var contentElement = b.querySelector("div.component-element-content");contentElement.classList.add("no-padding");contentElement.querySelector("div.select-image").classList.add("hide");var container = document.createElement("div");container.classList.add("iframe-container");container.insertAdjacentHTML("afterbegin", video.html);c.insertBefore(container, c.children[0]);contentElement.appendChild(c);c.children[1].innerText = video.title;var duration = video.duration;var minutes = parseInt(duration / 60, 10);var seconds = duration % 60;c.children[2].innerText = minutes + ":" + pad(Math.round(seconds), 2);var channelURL = document.createElement("a");channelURL.setAttribute("href", video.author_url);channelURL.setAttribute("target", "_blank");channelURL.innerText = video.author_name;c.children[3].appendChild(channelURL);componentsModule.modules.video.registerEvents(c, a, contentElement, e);
  }, removeInstance: function removeInstance(a, c, b) {
    c.querySelector("div.input-box.select-image").classList.remove("hide");c.removeChild(b);c.classList.remove("no-padding");delete componentsModule.modules.video.data[a];
  }, remove: function remove(a) {
    a.querySelectorAll("div.component-instance").forEach(function (b) {
      b.querySelector("span.item-remove").click();
    });
  }, onSelect: function onSelect(a, b, d, c, e) {
    componentsModule.modules.video.remove(b);if (!c) {
      d = "app/Data/Files/Videos/" + d;
    }componentsModule.modules.video.data[a] = { title: "", video: d, video_description: false, video_align: 1, disabled: 0 };var type = componentsModule.modules.video.videoType(d);var template = b.querySelector("#template_component_content_video_item").children[0].cloneNode(true);template.setAttribute("data-path", d);switch (type) {case -1:
        componentsModule.modules.video.loadExternalVideo(a, b, d, template, e);break;case 0:
        componentsModule.modules.video.loadYouTubeVideo(a, b, d, template, e);break;case 1:
        componentsModule.modules.video.loadVimeoVideo(a, b, d, template, e);break;default:
        return false;break;}
  }, create: function create(a, b) {
    componentsModule.initializeEvents([{ event: "click", element: b.querySelector("button.inline-image_manager"), content: function content() {
        managerActiveInstance = new MediaManager({ manager: "videos", onSelect: function onSelect(c) {
            componentsModule.modules.video.onSelect(a, b, c, false);
          } });
      } }, { event: "keyup", element: b.querySelector("input[name=component_inline_video_input]"), content: function content(c) {
        if (c.keyCode !== 13 || c.target.value.trim().length < 4) {
          return false;
        }componentsModule.modules.video.onSelect(a, b, c.target.value.trim(), true);
      } }]);
  }, validate: function validate() {
    return true;
  }, serialize: function serialize() {
    return componentsModule.modules.video.data;
  } };

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _jquery = __webpack_require__(2);

var _jquery2 = _interopRequireDefault(_jquery);

var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

var _Csrf = __webpack_require__(7);

var _Csrf2 = _interopRequireDefault(_Csrf);

var _Translate = __webpack_require__(91);

var _Translate2 = _interopRequireDefault(_Translate);

var _Router = __webpack_require__(8);

var _Router2 = _interopRequireDefault(_Router);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Translate page
{

    var translations = ['system', 'response', 'admin_header', 'admin_menu'];
    _Global2.default.translate = new _Translate2.default(translations, false);
}

// CSRF updater
_Csrf2.default.constructor();

// Anchor link box
_Global2.default.$html.on('mouseover', '[data-link]', function () {

    if ('ontouchstart' in document.documentElement) return false;

    var link = _Global2.default.routePrefix + _Global2.default.route + '/' + this.getAttribute('data-link');
    _Global2.default.anchorBox.addClass('show').text(link);
});
_Global2.default.$html.on('mouseleave', '[data-link]', function () {
    _Global2.default.anchorBox.removeClass('show').text('');
});

// Execute Router
_Global2.default.router = new _Router2.default();

// Delegate body click events
_Utils2.default.registerEvent(['click', _Global2.default.body, function (event) {

    var target = event.target;

    // Close elements on click outside
    _Global2.default.closer.closeElements(target);

    // Focus inputs
    if (target.matches('div.mainline-search div.input-box')) (0, _jquery2.default)(target).find('input').focus();

    // Show / Hide Password Fields
    else if (target.matches('span.show-password')) {

            var action = target.getAttribute('data-action');
            var input = document.querySelector('input[name=' + action + ']');

            if (input.getAttribute('type') === 'password') {
                inputElement.setAttribute('type', 'text');
                target.classList.add('visible');
            } else {
                input.setAttribute('type', 'password');
                target.classList.remove('visible');
            }
        }

        // Logout
        else if (target.matches('.logout')) window.location.href = _Global2.default.URI + 'logout';

            // Link click event
            else if (target.matches('[data-link]') || (0, _jquery2.default)(target).parents('[data-link]').length > 0) {

                    var link = target.dataset.link;

                    if (!link) link = (0, _jquery2.default)(target).parents('[data-link]').data('link');

                    var linkAction = link.split('/')[0];
                    var menuLink = _Global2.default.nav.querySelector('[data-link="' + linkAction + '"]');
                    var activeLink = _Global2.default.nav.querySelector('.active[data-link]');

                    if (activeLink) activeLink.classList.remove('active');

                    if (menuLink) menuLink.classList.add('active');

                    _Global2.default.router.changeLocation(link);
                }
}]);

// Footer Open / Close
{

    var footer = (0, _jquery2.default)('footer');

    _Utils2.default.registerEvent(['click', document.querySelector('.footer-more'), function () {

        if (!footer.hasClass('open')) {
            footer.addClass('open');
            _Global2.default.closer.addElement(footer);
        } else footer.removeClass('open');
    }]);
}

// Account Menu Open / Close
{

    var dropdown = (0, _jquery2.default)('div.account-dropdown');

    _Utils2.default.registerEvent(['click', document.querySelector('.header-account'), function () {

        if (dropdown.hasClass('open')) return false;

        dropdown.addClass('open');
        _Global2.default.closer.addElement(dropdown);
    }]);
}

// Write Menu Open / Close
{

    var writeMenu = (0, _jquery2.default)('div.write-menu');

    _Utils2.default.registerEvents([['click', document.querySelector('div.header-write'), function () {
        writeMenu.addClass('open');
        _Global2.default.closer.addElement(writeMenu);
    }], ['click', document.querySelectorAll('div.write-menu span.header-close, div.write-menu div.tails-tail'), function () {
        return writeMenu.removeClass('open');
    }]]);
}

// Hide splash screen
_Utils2.default.hideSplash();

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _jquery = __webpack_require__(2);

var _jquery2 = _interopRequireDefault(_jquery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _class = function () {
    function _class() {
        _classCallCheck(this, _class);

        this.stack = [];
        this.counter = 0;
    }

    _createClass(_class, [{
        key: 'addElement',
        value: function addElement(element) {

            this.stack.push(element[0]);
            this.counter = 1;
        }
    }, {
        key: 'closeElements',
        value: function closeElements(target) {
            var _this = this;

            if (this.counter > 0) {
                this.counter = 0;
                return false;
            }

            this.stack.forEach(function (element) {

                if (!((0, _jquery2.default)(element).find(target).length > 0 || (0, _jquery2.default)(element).is((0, _jquery2.default)(target)))) {
                    (0, _jquery2.default)(element).removeClass('open');
                    _this.stack.splice(element, 1);
                }
            });
        }
    }]);

    return _class;
}();

exports.default = _class;

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Ajax = __webpack_require__(4);

var _Ajax2 = _interopRequireDefault(_Ajax);

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

var _jquery = __webpack_require__(2);

var _jquery2 = _interopRequireDefault(_jquery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _class = function () {
    function _class(domains, local) {
        var _this = this;

        _classCallCheck(this, _class);

        this.domains = domains;
        this.locale = {};
        var language = void 0;

        if (local !== false) this.local = local;

        if (localStorage.getItem('locale_' + this.local) && local !== false) language = localStorage.getItem('locale_' + this.local);else language = _Global2.default.html.getAttribute('lang');

        this.language = language;

        domains.forEach(function (domain) {

            _this.locale[domain] = _Ajax2.default.getJSON("app/Data/Locale/" + language + "/" + domain + ".json", false);
            _this.changeLanguage(language, _this.locale[domain]);
        });
    }

    _createClass(_class, [{
        key: 'getLanguage',
        value: function getLanguage() {
            return this.language;
        }
    }, {
        key: 'getLocale',
        value: function getLocale() {
            return this.locale;
        }
    }, {
        key: 'changeLanguage',
        value: function changeLanguage(language, locale) {

            // Change local storage
            if (this.local) localStorage.setItem('locale_' + this.local, language);

            // Change html element lang
            _Global2.default.html.setAttribute('lang', locale['LOCALE']);

            // Translate website
            (0, _jquery2.default)('[data-locale]').each(function () {

                var phrase = (0, _jquery2.default)(this).data('locale');
                (0, _jquery2.default)(this).html(locale[phrase]);
            });

            // Translate placeholders
            (0, _jquery2.default)('[data-placeholder]').each(function () {

                var phrase = (0, _jquery2.default)(this).data('placeholder');
                (0, _jquery2.default)('[data-placeholder="' + phrase + '"]').attr('placeholder', locale[phrase]);
            });

            // Translate title attributes
            (0, _jquery2.default)('[data-title]').each(function () {

                var phrase = (0, _jquery2.default)(this).data('title');
                (0, _jquery2.default)('[data-title="' + phrase + '"]').attr('title', locale[phrase]);
            });

            (0, _jquery2.default)('[data-sublocale]').each(function () {

                var phrase = (0, _jquery2.default)(this).data('sublocale');
                (0, _jquery2.default)('[data-sublocale="' + phrase + '"]').html(locale[phrase]);
            });
        }
    }, {
        key: 'translateLocales',
        value: function translateLocales(locales) {
            var _this2 = this;

            locales.forEach(function (locale) {
                _this2.addTranslation(locale);
            });
        }
    }, {
        key: 'addTranslation',
        value: function addTranslation(locale) {

            if (this.locale[locale]) {
                this.changeLanguage(this.language, this.locale[locale]);
                return true;
            }

            this.locale[locale] = _Ajax2.default.getJSON("app/Data/Locale/" + this.language + "/" + locale + ".json", false);
            this.changeLanguage(this.language, this.locale[locale]);
        }
    }]);

    return _class;
}();

exports.default = _class;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
    initialize: function initialize(router) {

        window.onpopstate = function (event) {
            var link = event.state.link;
            router.changeLocation(link, false);
        };
    },
    createURL: function createURL(route) {
        return _Global2.default.routePrefix + _Global2.default.route + '/' + route.join('/');
    },
    push: function push(route) {
        history.pushState({ link: route }, '', this.createURL(route));
    },
    replace: function replace(route) {
        history.replaceState({ link: route }, '', this.createURL(route));
    }
};

/***/ }),
/* 93 */
/***/ (function(module, exports) {

module.exports = {"404":"Error","dashboard":"Dashboard","articles":"Articles","new":"New","category":"Category","settings":"Settings","sorting":"Sorting","write":"Write"}

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./Articles.js": 95,
	"./Dashboard.js": 96,
	"./Error.js": 97,
	"./Main.js": 3,
	"./Write.js": 98
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number or string
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 94;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = {
    initialize: function initialize() {}
};

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

var _Main = __webpack_require__(3);

var _Main2 = _interopRequireDefault(_Main);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {

    LOCALES: ['admin_dashboard'],

    initialize: function initialize() {

        // Render content
        _Main2.default.createView(this.LOCALES);
    }
};

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Main = __webpack_require__(3);

var _Main2 = _interopRequireDefault(_Main);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
    initialize: function initialize(actions) {}
};

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

var _Main = __webpack_require__(3);

var _Main2 = _interopRequireDefault(_Main);

var _Counters = __webpack_require__(106);

var _Counters2 = _interopRequireDefault(_Counters);

var _Components = __webpack_require__(107);

var _Components2 = _interopRequireDefault(_Components);

var _Flatpickr = __webpack_require__(113);

var _Flatpickr2 = _interopRequireDefault(_Flatpickr);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {

    LOCALES: ['system', 'admin_write', 'components', 'admin_write/' + _Global2.default.routeAction[1]],
    components: [],

    initialize: function initialize() {
        var _this = this;

        // Render content
        _Main2.default.createView(this.LOCALES).then(function () {

            // Enable libraries
            _this.enableLibraries();

            // Register events
            _this.registerEvents();

            // Load and resume components
            _this.listComponents();
            _this.prepareComponents();
        });
    },
    listComponents: function listComponents() {

        var componentElements = document.querySelectorAll('.component-element');

        this.components = Array.from(componentElements).map(function (componentElement) {
            return componentElement.getAttribute('data-component');
        });
    },
    prepareComponents: function prepareComponents() {

        this.initializeComponents();
    },
    initializeComponents: function initializeComponents() {

        _Global2.default.componentsModule = new _Components2.default(this.components.slice(0, 5));
    },
    enableLibraries: function enableLibraries() {

        // Counters
        _Counters2.default.initialize();

        // Packery
        var Packery = __webpack_require__(100);

        _Global2.default.packery = new Packery('.content-settings', {
            itemSelector: '.component-element',
            gutter: 22
        });

        // Sortable
        var sortableElement = document.querySelector('div.content-builder-content');

        if (sortableElement) {

            // Initialize sortable

        }

        var Selector = __webpack_require__(165);
        console.log(Selector);

        // Flatpickr
        _Flatpickr2.default.initialize();
    },
    registerEvents: function registerEvents() {

        var contentSettings = document.querySelector('.content-settings');

        document.querySelector('.content-wrapper').addEventListener('click', function (event) {

            var target = event.target;

            // Open / Close Content Settings
            if (target.matches('.collapse-trigger *')) {
                contentSettings.classList.toggle('open');
                _Global2.default.packery.reloadItems();
            }

            // Add inline component
            else if (target.matches('.builder-tools .add-content')) {
                    var component = target.getAttribute('data-content');
                    _Global2.default.componentsModule.createComponent(component);
                }
        });
    }
};

/***/ }),
/* 99 */,
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * Packery v2.1.1
 * Gapless, draggable grid layouts
 *
 * Licensed GPLv3 for open source use
 * or Packery Commercial License for commercial use
 *
 * http://packery.metafizzy.co
 * Copyright 2016 Metafizzy
 */

( function( window, factory ) {
  // universal module definition
  /* jshint strict: false */ /* globals define, module, require */
  if ( true ) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(5),
        __webpack_require__(9),
        __webpack_require__(6),
        __webpack_require__(104),
        __webpack_require__(105)
      ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS
    module.exports = factory(
      require('get-size'),
      require('outlayer'),
      require('./rect'),
      require('./packer'),
      require('./item')
    );
  } else {
    // browser global
    window.Packery = factory(
      window.getSize,
      window.Outlayer,
      window.Packery.Rect,
      window.Packery.Packer,
      window.Packery.Item
    );
  }

}( window, function factory( getSize, Outlayer, Rect, Packer, Item ) {
'use strict';

// ----- Rect ----- //

// allow for pixel rounding errors IE8-IE11 & Firefox; #227
Rect.prototype.canFit = function( rect ) {
  return this.width >= rect.width - 1 && this.height >= rect.height - 1;
};

// -------------------------- Packery -------------------------- //

// create an Outlayer layout class
var Packery = Outlayer.create('packery');
Packery.Item = Item;

var proto = Packery.prototype;

proto._create = function() {
  // call super
  Outlayer.prototype._create.call( this );

  // initial properties
  this.packer = new Packer();
  // packer for drop targets
  this.shiftPacker = new Packer();
  this.isEnabled = true;

  this.dragItemCount = 0;

  // create drag handlers
  var _this = this;
  this.handleDraggabilly = {
    dragStart: function() {
      _this.itemDragStart( this.element );
    },
    dragMove: function() {
      _this.itemDragMove( this.element, this.position.x, this.position.y );
    },
    dragEnd: function() {
      _this.itemDragEnd( this.element );
    }
  };

  this.handleUIDraggable = {
    start: function handleUIDraggableStart( event, ui ) {
      // HTML5 may trigger dragstart, dismiss HTML5 dragging
      if ( !ui ) {
        return;
      }
      _this.itemDragStart( event.currentTarget );
    },
    drag: function handleUIDraggableDrag( event, ui ) {
      if ( !ui ) {
        return;
      }
      _this.itemDragMove( event.currentTarget, ui.position.left, ui.position.top );
    },
    stop: function handleUIDraggableStop( event, ui ) {
      if ( !ui ) {
        return;
      }
      _this.itemDragEnd( event.currentTarget );
    }
  };

};


// ----- init & layout ----- //

/**
 * logic before any new layout
 */
proto._resetLayout = function() {
  this.getSize();

  this._getMeasurements();

  // reset packer
  var width, height, sortDirection;
  // packer settings, if horizontal or vertical
  if ( this._getOption('horizontal') ) {
    width = Infinity;
    height = this.size.innerHeight + this.gutter;
    sortDirection = 'rightwardTopToBottom';
  } else {
    width = this.size.innerWidth + this.gutter;
    height = Infinity;
    sortDirection = 'downwardLeftToRight';
  }

  this.packer.width = this.shiftPacker.width = width;
  this.packer.height = this.shiftPacker.height = height;
  this.packer.sortDirection = this.shiftPacker.sortDirection = sortDirection;

  this.packer.reset();

  // layout
  this.maxY = 0;
  this.maxX = 0;
};

/**
 * update columnWidth, rowHeight, & gutter
 * @private
 */
proto._getMeasurements = function() {
  this._getMeasurement( 'columnWidth', 'width' );
  this._getMeasurement( 'rowHeight', 'height' );
  this._getMeasurement( 'gutter', 'width' );
};

proto._getItemLayoutPosition = function( item ) {
  this._setRectSize( item.element, item.rect );
  if ( this.isShifting || this.dragItemCount > 0 ) {
    var packMethod = this._getPackMethod();
    this.packer[ packMethod ]( item.rect );
  } else {
    this.packer.pack( item.rect );
  }

  this._setMaxXY( item.rect );
  return item.rect;
};

proto.shiftLayout = function() {
  this.isShifting = true;
  this.layout();
  delete this.isShifting;
};

proto._getPackMethod = function() {
  return this._getOption('horizontal') ? 'rowPack' : 'columnPack';
};


/**
 * set max X and Y value, for size of container
 * @param {Packery.Rect} rect
 * @private
 */
proto._setMaxXY = function( rect ) {
  this.maxX = Math.max( rect.x + rect.width, this.maxX );
  this.maxY = Math.max( rect.y + rect.height, this.maxY );
};

/**
 * set the width and height of a rect, applying columnWidth and rowHeight
 * @param {Element} elem
 * @param {Packery.Rect} rect
 */
proto._setRectSize = function( elem, rect ) {
  var size = getSize( elem );
  var w = size.outerWidth;
  var h = size.outerHeight;
  // size for columnWidth and rowHeight, if available
  // only check if size is non-zero, #177
  if ( w || h ) {
    w = this._applyGridGutter( w, this.columnWidth );
    h = this._applyGridGutter( h, this.rowHeight );
  }
  // rect must fit in packer
  rect.width = Math.min( w, this.packer.width );
  rect.height = Math.min( h, this.packer.height );
};

/**
 * fits item to columnWidth/rowHeight and adds gutter
 * @param {Number} measurement - item width or height
 * @param {Number} gridSize - columnWidth or rowHeight
 * @returns measurement
 */
proto._applyGridGutter = function( measurement, gridSize ) {
  // just add gutter if no gridSize
  if ( !gridSize ) {
    return measurement + this.gutter;
  }
  gridSize += this.gutter;
  // fit item to columnWidth/rowHeight
  var remainder = measurement % gridSize;
  var mathMethod = remainder && remainder < 1 ? 'round' : 'ceil';
  measurement = Math[ mathMethod ]( measurement / gridSize ) * gridSize;
  return measurement;
};

proto._getContainerSize = function() {
  if ( this._getOption('horizontal') ) {
    return {
      width: this.maxX - this.gutter
    };
  } else {
    return {
      height: this.maxY - this.gutter
    };
  }
};


// -------------------------- stamp -------------------------- //

/**
 * makes space for element
 * @param {Element} elem
 */
proto._manageStamp = function( elem ) {

  var item = this.getItem( elem );
  var rect;
  if ( item && item.isPlacing ) {
    rect = item.rect;
  } else {
    var offset = this._getElementOffset( elem );
    rect = new Rect({
      x: this._getOption('originLeft') ? offset.left : offset.right,
      y: this._getOption('originTop') ? offset.top : offset.bottom
    });
  }

  this._setRectSize( elem, rect );
  // save its space in the packer
  this.packer.placed( rect );
  this._setMaxXY( rect );
};

// -------------------------- methods -------------------------- //

function verticalSorter( a, b ) {
  return a.position.y - b.position.y || a.position.x - b.position.x;
}

function horizontalSorter( a, b ) {
  return a.position.x - b.position.x || a.position.y - b.position.y;
}

proto.sortItemsByPosition = function() {
  var sorter = this._getOption('horizontal') ? horizontalSorter : verticalSorter;
  this.items.sort( sorter );
};

/**
 * Fit item element in its current position
 * Packery will position elements around it
 * useful for expanding elements
 *
 * @param {Element} elem
 * @param {Number} x - horizontal destination position, optional
 * @param {Number} y - vertical destination position, optional
 */
proto.fit = function( elem, x, y ) {
  var item = this.getItem( elem );
  if ( !item ) {
    return;
  }

  // stamp item to get it out of layout
  this.stamp( item.element );
  // set placing flag
  item.enablePlacing();
  this.updateShiftTargets( item );
  // fall back to current position for fitting
  x = x === undefined ? item.rect.x: x;
  y = y === undefined ? item.rect.y: y;
  // position it best at its destination
  this.shift( item, x, y );
  this._bindFitEvents( item );
  item.moveTo( item.rect.x, item.rect.y );
  // layout everything else
  this.shiftLayout();
  // return back to regularly scheduled programming
  this.unstamp( item.element );
  this.sortItemsByPosition();
  item.disablePlacing();
};

/**
 * emit event when item is fit and other items are laid out
 * @param {Packery.Item} item
 * @private
 */
proto._bindFitEvents = function( item ) {
  var _this = this;
  var ticks = 0;
  function onLayout() {
    ticks++;
    if ( ticks != 2 ) {
      return;
    }
    _this.dispatchEvent( 'fitComplete', null, [ item ] );
  }
  // when item is laid out
  item.once( 'layout', onLayout );
  // when all items are laid out
  this.once( 'layoutComplete', onLayout );
};

// -------------------------- resize -------------------------- //

// debounced, layout on resize
proto.resize = function() {
  // don't trigger if size did not change
  // or if resize was unbound. See #285, outlayer#9
  if ( !this.isResizeBound || !this.needsResizeLayout() ) {
    return;
  }

  if ( this.options.shiftPercentResize ) {
    this.resizeShiftPercentLayout();
  } else {
    this.layout();
  }
};

/**
 * check if layout is needed post layout
 * @returns Boolean
 */
proto.needsResizeLayout = function() {
  var size = getSize( this.element );
  var innerSize = this._getOption('horizontal') ? 'innerHeight' : 'innerWidth';
  return size[ innerSize ] != this.size[ innerSize ];
};

proto.resizeShiftPercentLayout = function() {
  var items = this._getItemsForLayout( this.items );

  var isHorizontal = this._getOption('horizontal');
  var coord = isHorizontal ? 'y' : 'x';
  var measure = isHorizontal ? 'height' : 'width';
  var segmentName = isHorizontal ? 'rowHeight' : 'columnWidth';
  var innerSize = isHorizontal ? 'innerHeight' : 'innerWidth';

  // proportional re-align items
  var previousSegment = this[ segmentName ];
  previousSegment = previousSegment && previousSegment + this.gutter;

  if ( previousSegment ) {
    this._getMeasurements();
    var currentSegment = this[ segmentName ] + this.gutter;
    items.forEach( function( item ) {
      var seg = Math.round( item.rect[ coord ] / previousSegment );
      item.rect[ coord ] = seg * currentSegment;
    });
  } else {
    var currentSize = getSize( this.element )[ innerSize ] + this.gutter;
    var previousSize = this.packer[ measure ];
    items.forEach( function( item ) {
      item.rect[ coord ] = ( item.rect[ coord ] / previousSize ) * currentSize;
    });
  }

  this.shiftLayout();
};

// -------------------------- drag -------------------------- //

/**
 * handle an item drag start event
 * @param {Element} elem
 */
proto.itemDragStart = function( elem ) {
  if ( !this.isEnabled ) {
    return;
  }
  this.stamp( elem );
  // this.ignore( elem );
  var item = this.getItem( elem );
  if ( !item ) {
    return;
  }

  item.enablePlacing();
  item.showDropPlaceholder();
  this.dragItemCount++;
  this.updateShiftTargets( item );
};

proto.updateShiftTargets = function( dropItem ) {
  this.shiftPacker.reset();

  // pack stamps
  this._getBoundingRect();
  var isOriginLeft = this._getOption('originLeft');
  var isOriginTop = this._getOption('originTop');
  this.stamps.forEach( function( stamp ) {
    // ignore dragged item
    var item = this.getItem( stamp );
    if ( item && item.isPlacing ) {
      return;
    }
    var offset = this._getElementOffset( stamp );
    var rect = new Rect({
      x: isOriginLeft ? offset.left : offset.right,
      y: isOriginTop ? offset.top : offset.bottom
    });
    this._setRectSize( stamp, rect );
    // save its space in the packer
    this.shiftPacker.placed( rect );
  }, this );

  // reset shiftTargets
  var isHorizontal = this._getOption('horizontal');
  var segmentName = isHorizontal ? 'rowHeight' : 'columnWidth';
  var measure = isHorizontal ? 'height' : 'width';

  this.shiftTargetKeys = [];
  this.shiftTargets = [];
  var boundsSize;
  var segment = this[ segmentName ];
  segment = segment && segment + this.gutter;

  if ( segment ) {
    var segmentSpan = Math.ceil( dropItem.rect[ measure ] / segment );
    var segs = Math.floor( ( this.shiftPacker[ measure ] + this.gutter ) / segment );
    boundsSize = ( segs - segmentSpan ) * segment;
    // add targets on top
    for ( var i=0; i < segs; i++ ) {
      var initialX = isHorizontal ? 0 : i * segment;
      var initialY = isHorizontal ? i * segment : 0;
      this._addShiftTarget( initialX, initialY, boundsSize );
    }
  } else {
    boundsSize = ( this.shiftPacker[ measure ] + this.gutter ) - dropItem.rect[ measure ];
    this._addShiftTarget( 0, 0, boundsSize );
  }

  // pack each item to measure where shiftTargets are
  var items = this._getItemsForLayout( this.items );
  var packMethod = this._getPackMethod();
  items.forEach( function( item ) {
    var rect = item.rect;
    this._setRectSize( item.element, rect );
    this.shiftPacker[ packMethod ]( rect );

    // add top left corner
    this._addShiftTarget( rect.x, rect.y, boundsSize );
    // add bottom left / top right corner
    var cornerX = isHorizontal ? rect.x + rect.width : rect.x;
    var cornerY = isHorizontal ? rect.y : rect.y + rect.height;
    this._addShiftTarget( cornerX, cornerY, boundsSize );

    if ( segment ) {
      // add targets for each column on bottom / row on right
      var segSpan = Math.round( rect[ measure ] / segment );
      for ( var i=1; i < segSpan; i++ ) {
        var segX = isHorizontal ? cornerX : rect.x + segment * i;
        var segY = isHorizontal ? rect.y + segment * i : cornerY;
        this._addShiftTarget( segX, segY, boundsSize );
      }
    }
  }, this );

};

proto._addShiftTarget = function( x, y, boundsSize ) {
  var checkCoord = this._getOption('horizontal') ? y : x;
  if ( checkCoord !== 0 && checkCoord > boundsSize ) {
    return;
  }
  // create string for a key, easier to keep track of what targets
  var key = x + ',' + y;
  var hasKey = this.shiftTargetKeys.indexOf( key ) != -1;
  if ( hasKey ) {
    return;
  }
  this.shiftTargetKeys.push( key );
  this.shiftTargets.push({ x: x, y: y });
};

// -------------------------- drop -------------------------- //

proto.shift = function( item, x, y ) {
  var shiftPosition;
  var minDistance = Infinity;
  var position = { x: x, y: y };
  this.shiftTargets.forEach( function( target ) {
    var distance = getDistance( target, position );
    if ( distance < minDistance ) {
      shiftPosition = target;
      minDistance = distance;
    }
  });
  item.rect.x = shiftPosition.x;
  item.rect.y = shiftPosition.y;
};

function getDistance( a, b ) {
  var dx = b.x - a.x;
  var dy = b.y - a.y;
  return Math.sqrt( dx * dx + dy * dy );
}

// -------------------------- drag move -------------------------- //

var DRAG_THROTTLE_TIME = 120;

/**
 * handle an item drag move event
 * @param {Element} elem
 * @param {Number} x - horizontal change in position
 * @param {Number} y - vertical change in position
 */
proto.itemDragMove = function( elem, x, y ) {
  var item = this.isEnabled && this.getItem( elem );
  if ( !item ) {
    return;
  }

  x -= this.size.paddingLeft;
  y -= this.size.paddingTop;

  var _this = this;
  function onDrag() {
    _this.shift( item, x, y );
    item.positionDropPlaceholder();
    _this.layout();
  }

  // throttle
  var now = new Date();
  if ( this._itemDragTime && now - this._itemDragTime < DRAG_THROTTLE_TIME ) {
    clearTimeout( this.dragTimeout );
    this.dragTimeout = setTimeout( onDrag, DRAG_THROTTLE_TIME );
  } else {
    onDrag();
    this._itemDragTime = now;
  }
};

// -------------------------- drag end -------------------------- //

/**
 * handle an item drag end event
 * @param {Element} elem
 */
proto.itemDragEnd = function( elem ) {
  var item = this.isEnabled && this.getItem( elem );
  if ( !item ) {
    return;
  }

  clearTimeout( this.dragTimeout );
  item.element.classList.add('is-positioning-post-drag');

  var completeCount = 0;
  var _this = this;
  function onDragEndLayoutComplete() {
    completeCount++;
    if ( completeCount != 2 ) {
      return;
    }
    // reset drag item
    item.element.classList.remove('is-positioning-post-drag');
    item.hideDropPlaceholder();
    _this.dispatchEvent( 'dragItemPositioned', null, [ item ] );
  }

  item.once( 'layout', onDragEndLayoutComplete );
  this.once( 'layoutComplete', onDragEndLayoutComplete );
  item.moveTo( item.rect.x, item.rect.y );
  this.layout();
  this.dragItemCount = Math.max( 0, this.dragItemCount - 1 );
  this.sortItemsByPosition();
  item.disablePlacing();
  this.unstamp( item.element );
};

/**
 * binds Draggabilly events
 * @param {Draggabilly} draggie
 */
proto.bindDraggabillyEvents = function( draggie ) {
  this._bindDraggabillyEvents( draggie, 'on' );
};

proto.unbindDraggabillyEvents = function( draggie ) {
  this._bindDraggabillyEvents( draggie, 'off' );
};

proto._bindDraggabillyEvents = function( draggie, method ) {
  var handlers = this.handleDraggabilly;
  draggie[ method ]( 'dragStart', handlers.dragStart );
  draggie[ method ]( 'dragMove', handlers.dragMove );
  draggie[ method ]( 'dragEnd', handlers.dragEnd );
};

/**
 * binds jQuery UI Draggable events
 * @param {jQuery} $elems
 */
proto.bindUIDraggableEvents = function( $elems ) {
  this._bindUIDraggableEvents( $elems, 'on' );
};

proto.unbindUIDraggableEvents = function( $elems ) {
  this._bindUIDraggableEvents( $elems, 'off' );
};

proto._bindUIDraggableEvents = function( $elems, method ) {
  var handlers = this.handleUIDraggable;
  $elems
    [ method ]( 'dragstart', handlers.start )
    [ method ]( 'drag', handlers.drag )
    [ method ]( 'dragstop', handlers.stop );
};

// ----- destroy ----- //

var _destroy = proto.destroy;
proto.destroy = function() {
  _destroy.apply( this, arguments );
  // disable flag; prevent drag events from triggering. #72
  this.isEnabled = false;
};

// -----  ----- //

Packery.Rect = Rect;
Packery.Packer = Packer;

return Packery;

}));


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * Fizzy UI utils v2.0.5
 * MIT license
 */

/*jshint browser: true, undef: true, unused: true, strict: true */

( function( window, factory ) {
  // universal module definition
  /*jshint strict: false */ /*globals define, module, require */

  if ( true ) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
      __webpack_require__(102)
    ], __WEBPACK_AMD_DEFINE_RESULT__ = function( matchesSelector ) {
      return factory( window, matchesSelector );
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS
    module.exports = factory(
      window,
      require('desandro-matches-selector')
    );
  } else {
    // browser global
    window.fizzyUIUtils = factory(
      window,
      window.matchesSelector
    );
  }

}( window, function factory( window, matchesSelector ) {

'use strict';

var utils = {};

// ----- extend ----- //

// extends objects
utils.extend = function( a, b ) {
  for ( var prop in b ) {
    a[ prop ] = b[ prop ];
  }
  return a;
};

// ----- modulo ----- //

utils.modulo = function( num, div ) {
  return ( ( num % div ) + div ) % div;
};

// ----- makeArray ----- //

// turn element or nodeList into an array
utils.makeArray = function( obj ) {
  var ary = [];
  if ( Array.isArray( obj ) ) {
    // use object if already an array
    ary = obj;
  } else if ( obj && typeof obj == 'object' &&
    typeof obj.length == 'number' ) {
    // convert nodeList to array
    for ( var i=0; i < obj.length; i++ ) {
      ary.push( obj[i] );
    }
  } else {
    // array of single index
    ary.push( obj );
  }
  return ary;
};

// ----- removeFrom ----- //

utils.removeFrom = function( ary, obj ) {
  var index = ary.indexOf( obj );
  if ( index != -1 ) {
    ary.splice( index, 1 );
  }
};

// ----- getParent ----- //

utils.getParent = function( elem, selector ) {
  while ( elem.parentNode && elem != document.body ) {
    elem = elem.parentNode;
    if ( matchesSelector( elem, selector ) ) {
      return elem;
    }
  }
};

// ----- getQueryElement ----- //

// use element as selector string
utils.getQueryElement = function( elem ) {
  if ( typeof elem == 'string' ) {
    return document.querySelector( elem );
  }
  return elem;
};

// ----- handleEvent ----- //

// enable .ontype to trigger from .addEventListener( elem, 'type' )
utils.handleEvent = function( event ) {
  var method = 'on' + event.type;
  if ( this[ method ] ) {
    this[ method ]( event );
  }
};

// ----- filterFindElements ----- //

utils.filterFindElements = function( elems, selector ) {
  // make array of elems
  elems = utils.makeArray( elems );
  var ffElems = [];

  elems.forEach( function( elem ) {
    // check that elem is an actual element
    if ( !( elem instanceof HTMLElement ) ) {
      return;
    }
    // add elem if no selector
    if ( !selector ) {
      ffElems.push( elem );
      return;
    }
    // filter & find items if we have a selector
    // filter
    if ( matchesSelector( elem, selector ) ) {
      ffElems.push( elem );
    }
    // find children
    var childElems = elem.querySelectorAll( selector );
    // concat childElems to filterFound array
    for ( var i=0; i < childElems.length; i++ ) {
      ffElems.push( childElems[i] );
    }
  });

  return ffElems;
};

// ----- debounceMethod ----- //

utils.debounceMethod = function( _class, methodName, threshold ) {
  // original method
  var method = _class.prototype[ methodName ];
  var timeoutName = methodName + 'Timeout';

  _class.prototype[ methodName ] = function() {
    var timeout = this[ timeoutName ];
    if ( timeout ) {
      clearTimeout( timeout );
    }
    var args = arguments;

    var _this = this;
    this[ timeoutName ] = setTimeout( function() {
      method.apply( _this, args );
      delete _this[ timeoutName ];
    }, threshold || 100 );
  };
};

// ----- docReady ----- //

utils.docReady = function( callback ) {
  var readyState = document.readyState;
  if ( readyState == 'complete' || readyState == 'interactive' ) {
    // do async to allow for other scripts to run. metafizzy/flickity#441
    setTimeout( callback );
  } else {
    document.addEventListener( 'DOMContentLoaded', callback );
  }
};

// ----- htmlInit ----- //

// http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/
utils.toDashed = function( str ) {
  return str.replace( /(.)([A-Z])/g, function( match, $1, $2 ) {
    return $1 + '-' + $2;
  }).toLowerCase();
};

var console = window.console;
/**
 * allow user to initialize classes via [data-namespace] or .js-namespace class
 * htmlInit( Widget, 'widgetName' )
 * options are parsed from data-namespace-options
 */
utils.htmlInit = function( WidgetClass, namespace ) {
  utils.docReady( function() {
    var dashedNamespace = utils.toDashed( namespace );
    var dataAttr = 'data-' + dashedNamespace;
    var dataAttrElems = document.querySelectorAll( '[' + dataAttr + ']' );
    var jsDashElems = document.querySelectorAll( '.js-' + dashedNamespace );
    var elems = utils.makeArray( dataAttrElems )
      .concat( utils.makeArray( jsDashElems ) );
    var dataOptionsAttr = dataAttr + '-options';
    var jQuery = window.jQuery;

    elems.forEach( function( elem ) {
      var attr = elem.getAttribute( dataAttr ) ||
        elem.getAttribute( dataOptionsAttr );
      var options;
      try {
        options = attr && JSON.parse( attr );
      } catch ( error ) {
        // log error, do not initialize
        if ( console ) {
          console.error( 'Error parsing ' + dataAttr + ' on ' + elem.className +
          ': ' + error );
        }
        return;
      }
      // initialize
      var instance = new WidgetClass( elem, options );
      // make available via $().data('namespace')
      if ( jQuery ) {
        jQuery.data( elem, namespace, instance );
      }
    });

  });
};

// -----  ----- //

return utils;

}));


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * matchesSelector v2.0.2
 * matchesSelector( element, '.selector' )
 * MIT license
 */

/*jshint browser: true, strict: true, undef: true, unused: true */

( function( window, factory ) {
  /*global define: false, module: false */
  'use strict';
  // universal module definition
  if ( true ) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS
    module.exports = factory();
  } else {
    // browser global
    window.matchesSelector = factory();
  }

}( window, function factory() {
  'use strict';

  var matchesMethod = ( function() {
    var ElemProto = window.Element.prototype;
    // check for the standard method name first
    if ( ElemProto.matches ) {
      return 'matches';
    }
    // check un-prefixed
    if ( ElemProto.matchesSelector ) {
      return 'matchesSelector';
    }
    // check vendor prefixes
    var prefixes = [ 'webkit', 'moz', 'ms', 'o' ];

    for ( var i=0; i < prefixes.length; i++ ) {
      var prefix = prefixes[i];
      var method = prefix + 'MatchesSelector';
      if ( ElemProto[ method ] ) {
        return method;
      }
    }
  })();

  return function matchesSelector( elem, selector ) {
    return elem[ matchesMethod ]( selector );
  };

}));


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * Outlayer Item
 */

( function( window, factory ) {
  // universal module definition
  /* jshint strict: false */ /* globals define, module, require */
  if ( true ) {
    // AMD - RequireJS
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(10),
        __webpack_require__(5)
      ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS - Browserify, Webpack
    module.exports = factory(
      require('ev-emitter'),
      require('get-size')
    );
  } else {
    // browser global
    window.Outlayer = {};
    window.Outlayer.Item = factory(
      window.EvEmitter,
      window.getSize
    );
  }

}( window, function factory( EvEmitter, getSize ) {
'use strict';

// ----- helpers ----- //

function isEmptyObj( obj ) {
  for ( var prop in obj ) {
    return false;
  }
  prop = null;
  return true;
}

// -------------------------- CSS3 support -------------------------- //


var docElemStyle = document.documentElement.style;

var transitionProperty = typeof docElemStyle.transition == 'string' ?
  'transition' : 'WebkitTransition';
var transformProperty = typeof docElemStyle.transform == 'string' ?
  'transform' : 'WebkitTransform';

var transitionEndEvent = {
  WebkitTransition: 'webkitTransitionEnd',
  transition: 'transitionend'
}[ transitionProperty ];

// cache all vendor properties that could have vendor prefix
var vendorProperties = {
  transform: transformProperty,
  transition: transitionProperty,
  transitionDuration: transitionProperty + 'Duration',
  transitionProperty: transitionProperty + 'Property',
  transitionDelay: transitionProperty + 'Delay'
};

// -------------------------- Item -------------------------- //

function Item( element, layout ) {
  if ( !element ) {
    return;
  }

  this.element = element;
  // parent layout class, i.e. Masonry, Isotope, or Packery
  this.layout = layout;
  this.position = {
    x: 0,
    y: 0
  };

  this._create();
}

// inherit EvEmitter
var proto = Item.prototype = Object.create( EvEmitter.prototype );
proto.constructor = Item;

proto._create = function() {
  // transition objects
  this._transn = {
    ingProperties: {},
    clean: {},
    onEnd: {}
  };

  this.css({
    position: 'absolute'
  });
};

// trigger specified handler for event type
proto.handleEvent = function( event ) {
  var method = 'on' + event.type;
  if ( this[ method ] ) {
    this[ method ]( event );
  }
};

proto.getSize = function() {
  this.size = getSize( this.element );
};

/**
 * apply CSS styles to element
 * @param {Object} style
 */
proto.css = function( style ) {
  var elemStyle = this.element.style;

  for ( var prop in style ) {
    // use vendor property if available
    var supportedProp = vendorProperties[ prop ] || prop;
    elemStyle[ supportedProp ] = style[ prop ];
  }
};

 // measure position, and sets it
proto.getPosition = function() {
  var style = getComputedStyle( this.element );
  var isOriginLeft = this.layout._getOption('originLeft');
  var isOriginTop = this.layout._getOption('originTop');
  var xValue = style[ isOriginLeft ? 'left' : 'right' ];
  var yValue = style[ isOriginTop ? 'top' : 'bottom' ];
  var x = parseFloat( xValue );
  var y = parseFloat( yValue );
  // convert percent to pixels
  var layoutSize = this.layout.size;
  if ( xValue.indexOf('%') != -1 ) {
    x = ( x / 100 ) * layoutSize.width;
  }
  if ( yValue.indexOf('%') != -1 ) {
    y = ( y / 100 ) * layoutSize.height;
  }
  // clean up 'auto' or other non-integer values
  x = isNaN( x ) ? 0 : x;
  y = isNaN( y ) ? 0 : y;
  // remove padding from measurement
  x -= isOriginLeft ? layoutSize.paddingLeft : layoutSize.paddingRight;
  y -= isOriginTop ? layoutSize.paddingTop : layoutSize.paddingBottom;

  this.position.x = x;
  this.position.y = y;
};

// set settled position, apply padding
proto.layoutPosition = function() {
  var layoutSize = this.layout.size;
  var style = {};
  var isOriginLeft = this.layout._getOption('originLeft');
  var isOriginTop = this.layout._getOption('originTop');

  // x
  var xPadding = isOriginLeft ? 'paddingLeft' : 'paddingRight';
  var xProperty = isOriginLeft ? 'left' : 'right';
  var xResetProperty = isOriginLeft ? 'right' : 'left';

  var x = this.position.x + layoutSize[ xPadding ];
  // set in percentage or pixels
  style[ xProperty ] = this.getXValue( x );
  // reset other property
  style[ xResetProperty ] = '';

  // y
  var yPadding = isOriginTop ? 'paddingTop' : 'paddingBottom';
  var yProperty = isOriginTop ? 'top' : 'bottom';
  var yResetProperty = isOriginTop ? 'bottom' : 'top';

  var y = this.position.y + layoutSize[ yPadding ];
  // set in percentage or pixels
  style[ yProperty ] = this.getYValue( y );
  // reset other property
  style[ yResetProperty ] = '';

  this.css( style );
  this.emitEvent( 'layout', [ this ] );
};

proto.getXValue = function( x ) {
  var isHorizontal = this.layout._getOption('horizontal');
  return this.layout.options.percentPosition && !isHorizontal ?
    ( ( x / this.layout.size.width ) * 100 ) + '%' : x + 'px';
};

proto.getYValue = function( y ) {
  var isHorizontal = this.layout._getOption('horizontal');
  return this.layout.options.percentPosition && isHorizontal ?
    ( ( y / this.layout.size.height ) * 100 ) + '%' : y + 'px';
};

proto._transitionTo = function( x, y ) {
  this.getPosition();
  // get current x & y from top/left
  var curX = this.position.x;
  var curY = this.position.y;

  var didNotMove = x == this.position.x && y == this.position.y;

  // save end position
  this.setPosition( x, y );

  // if did not move and not transitioning, just go to layout
  if ( didNotMove && !this.isTransitioning ) {
    this.layoutPosition();
    return;
  }

  var transX = x - curX;
  var transY = y - curY;
  var transitionStyle = {};
  transitionStyle.transform = this.getTranslate( transX, transY );

  this.transition({
    to: transitionStyle,
    onTransitionEnd: {
      transform: this.layoutPosition
    },
    isCleaning: true
  });
};

proto.getTranslate = function( x, y ) {
  // flip cooridinates if origin on right or bottom
  var isOriginLeft = this.layout._getOption('originLeft');
  var isOriginTop = this.layout._getOption('originTop');
  x = isOriginLeft ? x : -x;
  y = isOriginTop ? y : -y;
  return 'translate3d(' + x + 'px, ' + y + 'px, 0)';
};

// non transition + transform support
proto.goTo = function( x, y ) {
  this.setPosition( x, y );
  this.layoutPosition();
};

proto.moveTo = proto._transitionTo;

proto.setPosition = function( x, y ) {
  this.position.x = parseFloat( x );
  this.position.y = parseFloat( y );
};

// ----- transition ----- //

/**
 * @param {Object} style - CSS
 * @param {Function} onTransitionEnd
 */

// non transition, just trigger callback
proto._nonTransition = function( args ) {
  this.css( args.to );
  if ( args.isCleaning ) {
    this._removeStyles( args.to );
  }
  for ( var prop in args.onTransitionEnd ) {
    args.onTransitionEnd[ prop ].call( this );
  }
};

/**
 * proper transition
 * @param {Object} args - arguments
 *   @param {Object} to - style to transition to
 *   @param {Object} from - style to start transition from
 *   @param {Boolean} isCleaning - removes transition styles after transition
 *   @param {Function} onTransitionEnd - callback
 */
proto.transition = function( args ) {
  // redirect to nonTransition if no transition duration
  if ( !parseFloat( this.layout.options.transitionDuration ) ) {
    this._nonTransition( args );
    return;
  }

  var _transition = this._transn;
  // keep track of onTransitionEnd callback by css property
  for ( var prop in args.onTransitionEnd ) {
    _transition.onEnd[ prop ] = args.onTransitionEnd[ prop ];
  }
  // keep track of properties that are transitioning
  for ( prop in args.to ) {
    _transition.ingProperties[ prop ] = true;
    // keep track of properties to clean up when transition is done
    if ( args.isCleaning ) {
      _transition.clean[ prop ] = true;
    }
  }

  // set from styles
  if ( args.from ) {
    this.css( args.from );
    // force redraw. http://blog.alexmaccaw.com/css-transitions
    var h = this.element.offsetHeight;
    // hack for JSHint to hush about unused var
    h = null;
  }
  // enable transition
  this.enableTransition( args.to );
  // set styles that are transitioning
  this.css( args.to );

  this.isTransitioning = true;

};

// dash before all cap letters, including first for
// WebkitTransform => -webkit-transform
function toDashedAll( str ) {
  return str.replace( /([A-Z])/g, function( $1 ) {
    return '-' + $1.toLowerCase();
  });
}

var transitionProps = 'opacity,' + toDashedAll( transformProperty );

proto.enableTransition = function(/* style */) {
  // HACK changing transitionProperty during a transition
  // will cause transition to jump
  if ( this.isTransitioning ) {
    return;
  }

  // make `transition: foo, bar, baz` from style object
  // HACK un-comment this when enableTransition can work
  // while a transition is happening
  // var transitionValues = [];
  // for ( var prop in style ) {
  //   // dash-ify camelCased properties like WebkitTransition
  //   prop = vendorProperties[ prop ] || prop;
  //   transitionValues.push( toDashedAll( prop ) );
  // }
  // munge number to millisecond, to match stagger
  var duration = this.layout.options.transitionDuration;
  duration = typeof duration == 'number' ? duration + 'ms' : duration;
  // enable transition styles
  this.css({
    transitionProperty: transitionProps,
    transitionDuration: duration,
    transitionDelay: this.staggerDelay || 0
  });
  // listen for transition end event
  this.element.addEventListener( transitionEndEvent, this, false );
};

// ----- events ----- //

proto.onwebkitTransitionEnd = function( event ) {
  this.ontransitionend( event );
};

proto.onotransitionend = function( event ) {
  this.ontransitionend( event );
};

// properties that I munge to make my life easier
var dashedVendorProperties = {
  '-webkit-transform': 'transform'
};

proto.ontransitionend = function( event ) {
  // disregard bubbled events from children
  if ( event.target !== this.element ) {
    return;
  }
  var _transition = this._transn;
  // get property name of transitioned property, convert to prefix-free
  var propertyName = dashedVendorProperties[ event.propertyName ] || event.propertyName;

  // remove property that has completed transitioning
  delete _transition.ingProperties[ propertyName ];
  // check if any properties are still transitioning
  if ( isEmptyObj( _transition.ingProperties ) ) {
    // all properties have completed transitioning
    this.disableTransition();
  }
  // clean style
  if ( propertyName in _transition.clean ) {
    // clean up style
    this.element.style[ event.propertyName ] = '';
    delete _transition.clean[ propertyName ];
  }
  // trigger onTransitionEnd callback
  if ( propertyName in _transition.onEnd ) {
    var onTransitionEnd = _transition.onEnd[ propertyName ];
    onTransitionEnd.call( this );
    delete _transition.onEnd[ propertyName ];
  }

  this.emitEvent( 'transitionEnd', [ this ] );
};

proto.disableTransition = function() {
  this.removeTransitionStyles();
  this.element.removeEventListener( transitionEndEvent, this, false );
  this.isTransitioning = false;
};

/**
 * removes style property from element
 * @param {Object} style
**/
proto._removeStyles = function( style ) {
  // clean up transition styles
  var cleanStyle = {};
  for ( var prop in style ) {
    cleanStyle[ prop ] = '';
  }
  this.css( cleanStyle );
};

var cleanTransitionStyle = {
  transitionProperty: '',
  transitionDuration: '',
  transitionDelay: ''
};

proto.removeTransitionStyles = function() {
  // remove transition
  this.css( cleanTransitionStyle );
};

// ----- stagger ----- //

proto.stagger = function( delay ) {
  delay = isNaN( delay ) ? 0 : delay;
  this.staggerDelay = delay + 'ms';
};

// ----- show/hide/remove ----- //

// remove element from DOM
proto.removeElem = function() {
  this.element.parentNode.removeChild( this.element );
  // remove display: none
  this.css({ display: '' });
  this.emitEvent( 'remove', [ this ] );
};

proto.remove = function() {
  // just remove element if no transition support or no transition
  if ( !transitionProperty || !parseFloat( this.layout.options.transitionDuration ) ) {
    this.removeElem();
    return;
  }

  // start transition
  this.once( 'transitionEnd', function() {
    this.removeElem();
  });
  this.hide();
};

proto.reveal = function() {
  delete this.isHidden;
  // remove display: none
  this.css({ display: '' });

  var options = this.layout.options;

  var onTransitionEnd = {};
  var transitionEndProperty = this.getHideRevealTransitionEndProperty('visibleStyle');
  onTransitionEnd[ transitionEndProperty ] = this.onRevealTransitionEnd;

  this.transition({
    from: options.hiddenStyle,
    to: options.visibleStyle,
    isCleaning: true,
    onTransitionEnd: onTransitionEnd
  });
};

proto.onRevealTransitionEnd = function() {
  // check if still visible
  // during transition, item may have been hidden
  if ( !this.isHidden ) {
    this.emitEvent('reveal');
  }
};

/**
 * get style property use for hide/reveal transition end
 * @param {String} styleProperty - hiddenStyle/visibleStyle
 * @returns {String}
 */
proto.getHideRevealTransitionEndProperty = function( styleProperty ) {
  var optionStyle = this.layout.options[ styleProperty ];
  // use opacity
  if ( optionStyle.opacity ) {
    return 'opacity';
  }
  // get first property
  for ( var prop in optionStyle ) {
    return prop;
  }
};

proto.hide = function() {
  // set flag
  this.isHidden = true;
  // remove display: none
  this.css({ display: '' });

  var options = this.layout.options;

  var onTransitionEnd = {};
  var transitionEndProperty = this.getHideRevealTransitionEndProperty('hiddenStyle');
  onTransitionEnd[ transitionEndProperty ] = this.onHideTransitionEnd;

  this.transition({
    from: options.visibleStyle,
    to: options.hiddenStyle,
    // keep hidden stuff hidden
    isCleaning: true,
    onTransitionEnd: onTransitionEnd
  });
};

proto.onHideTransitionEnd = function() {
  // check if still hidden
  // during transition, item may have been un-hidden
  if ( this.isHidden ) {
    this.css({ display: 'none' });
    this.emitEvent('hide');
  }
};

proto.destroy = function() {
  this.css({
    position: '',
    left: '',
    right: '',
    top: '',
    bottom: '',
    transition: '',
    transform: ''
  });
};

return Item;

}));


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * Packer
 * bin-packing algorithm
 */

( function( window, factory ) {
  // universal module definition
  /* jshint strict: false */ /* globals define, module, require */
  if ( true ) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(6) ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS
    module.exports = factory(
      require('./rect')
    );
  } else {
    // browser global
    var Packery = window.Packery = window.Packery || {};
    Packery.Packer = factory( Packery.Rect );
  }

}( window, function factory( Rect ) {
'use strict';

// -------------------------- Packer -------------------------- //

/**
 * @param {Number} width
 * @param {Number} height
 * @param {String} sortDirection
 *   topLeft for vertical, leftTop for horizontal
 */
function Packer( width, height, sortDirection ) {
  this.width = width || 0;
  this.height = height || 0;
  this.sortDirection = sortDirection || 'downwardLeftToRight';

  this.reset();
}

var proto = Packer.prototype;

proto.reset = function() {
  this.spaces = [];

  var initialSpace = new Rect({
    x: 0,
    y: 0,
    width: this.width,
    height: this.height
  });

  this.spaces.push( initialSpace );
  // set sorter
  this.sorter = sorters[ this.sortDirection ] || sorters.downwardLeftToRight;
};

// change x and y of rect to fit with in Packer's available spaces
proto.pack = function( rect ) {
  for ( var i=0; i < this.spaces.length; i++ ) {
    var space = this.spaces[i];
    if ( space.canFit( rect ) ) {
      this.placeInSpace( rect, space );
      break;
    }
  }
};

proto.columnPack = function( rect ) {
  for ( var i=0; i < this.spaces.length; i++ ) {
    var space = this.spaces[i];
    var canFitInSpaceColumn = space.x <= rect.x &&
      space.x + space.width >= rect.x + rect.width &&
      space.height >= rect.height - 0.01; // fudge number for rounding error
    if ( canFitInSpaceColumn ) {
      rect.y = space.y;
      this.placed( rect );
      break;
    }
  }
};

proto.rowPack = function( rect ) {
  for ( var i=0; i < this.spaces.length; i++ ) {
    var space = this.spaces[i];
    var canFitInSpaceRow = space.y <= rect.y &&
      space.y + space.height >= rect.y + rect.height &&
      space.width >= rect.width - 0.01; // fudge number for rounding error
    if ( canFitInSpaceRow ) {
      rect.x = space.x;
      this.placed( rect );
      break;
    }
  }
};

proto.placeInSpace = function( rect, space ) {
  // place rect in space
  rect.x = space.x;
  rect.y = space.y;

  this.placed( rect );
};

// update spaces with placed rect
proto.placed = function( rect ) {
  // update spaces
  var revisedSpaces = [];
  for ( var i=0; i < this.spaces.length; i++ ) {
    var space = this.spaces[i];
    var newSpaces = space.getMaximalFreeRects( rect );
    // add either the original space or the new spaces to the revised spaces
    if ( newSpaces ) {
      revisedSpaces.push.apply( revisedSpaces, newSpaces );
    } else {
      revisedSpaces.push( space );
    }
  }

  this.spaces = revisedSpaces;

  this.mergeSortSpaces();
};

proto.mergeSortSpaces = function() {
  // remove redundant spaces
  Packer.mergeRects( this.spaces );
  this.spaces.sort( this.sorter );
};

// add a space back
proto.addSpace = function( rect ) {
  this.spaces.push( rect );
  this.mergeSortSpaces();
};

// -------------------------- utility functions -------------------------- //

/**
 * Remove redundant rectangle from array of rectangles
 * @param {Array} rects: an array of Rects
 * @returns {Array} rects: an array of Rects
**/
Packer.mergeRects = function( rects ) {
  var i = 0;
  var rect = rects[i];

  rectLoop:
  while ( rect ) {
    var j = 0;
    var compareRect = rects[ i + j ];

    while ( compareRect ) {
      if  ( compareRect == rect ) {
        j++; // next
      } else if ( compareRect.contains( rect ) ) {
        // remove rect
        rects.splice( i, 1 );
        rect = rects[i]; // set next rect
        continue rectLoop; // bail on compareLoop
      } else if ( rect.contains( compareRect ) ) {
        // remove compareRect
        rects.splice( i + j, 1 );
      } else {
        j++;
      }
      compareRect = rects[ i + j ]; // set next compareRect
    }
    i++;
    rect = rects[i];
  }

  return rects;
};


// -------------------------- sorters -------------------------- //

// functions for sorting rects in order
var sorters = {
  // top down, then left to right
  downwardLeftToRight: function( a, b ) {
    return a.y - b.y || a.x - b.x;
  },
  // left to right, then top down
  rightwardTopToBottom: function( a, b ) {
    return a.x - b.x || a.y - b.y;
  }
};


// --------------------------  -------------------------- //

return Packer;

}));


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * Packery Item Element
**/

( function( window, factory ) {
  // universal module definition
  /* jshint strict: false */ /* globals define, module, require */
  if ( true ) {
    // AMD
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
        __webpack_require__(9),
        __webpack_require__(6)
      ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if ( typeof module == 'object' && module.exports ) {
    // CommonJS
    module.exports = factory(
      require('outlayer'),
      require('./rect')
    );
  } else {
    // browser global
    window.Packery.Item = factory(
      window.Outlayer,
      window.Packery.Rect
    );
  }

}( window, function factory( Outlayer, Rect ) {
'use strict';

// -------------------------- Item -------------------------- //

var docElemStyle = document.documentElement.style;

var transformProperty = typeof docElemStyle.transform == 'string' ?
  'transform' : 'WebkitTransform';

// sub-class Item
var Item = function PackeryItem() {
  Outlayer.Item.apply( this, arguments );
};

var proto = Item.prototype = Object.create( Outlayer.Item.prototype );

var __create = proto._create;
proto._create = function() {
  // call default _create logic
  __create.call( this );
  this.rect = new Rect();
};

var _moveTo = proto.moveTo;
proto.moveTo = function( x, y ) {
  // don't shift 1px while dragging
  var dx = Math.abs( this.position.x - x );
  var dy = Math.abs( this.position.y - y );

  var canHackGoTo = this.layout.dragItemCount && !this.isPlacing &&
    !this.isTransitioning && dx < 1 && dy < 1;
  if ( canHackGoTo ) {
    this.goTo( x, y );
    return;
  }
  _moveTo.apply( this, arguments );
};

// -------------------------- placing -------------------------- //

proto.enablePlacing = function() {
  this.removeTransitionStyles();
  // remove transform property from transition
  if ( this.isTransitioning && transformProperty ) {
    this.element.style[ transformProperty ] = 'none';
  }
  this.isTransitioning = false;
  this.getSize();
  this.layout._setRectSize( this.element, this.rect );
  this.isPlacing = true;
};

proto.disablePlacing = function() {
  this.isPlacing = false;
};

// -----  ----- //

// remove element from DOM
proto.removeElem = function() {
  this.element.parentNode.removeChild( this.element );
  // add space back to packer
  this.layout.packer.addSpace( this.rect );
  this.emitEvent( 'remove', [ this ] );
};

// ----- dropPlaceholder ----- //

proto.showDropPlaceholder = function() {
  var dropPlaceholder = this.dropPlaceholder;
  if ( !dropPlaceholder ) {
    // create dropPlaceholder
    dropPlaceholder = this.dropPlaceholder = document.createElement('div');
    dropPlaceholder.className = 'packery-drop-placeholder';
    dropPlaceholder.style.position = 'absolute';
  }

  dropPlaceholder.style.width = this.size.width + 'px';
  dropPlaceholder.style.height = this.size.height + 'px';
  this.positionDropPlaceholder();
  this.layout.element.appendChild( dropPlaceholder );
};

proto.positionDropPlaceholder = function() {
  this.dropPlaceholder.style[ transformProperty ] = 'translate(' +
    this.rect.x + 'px, ' + this.rect.y + 'px)';
};

proto.hideDropPlaceholder = function() {
  // only remove once, #333
  var parent = this.dropPlaceholder.parentNode;
  if ( parent ) {
    parent.removeChild( this.dropPlaceholder );
  }
};

// -----  ----- //

return Item;

}));


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = {
    initialize: function initialize() {

        var counterElements = document.querySelectorAll('.counter');

        counterElements.forEach(function (counterElement) {

            var maxLength = counterElement.getAttribute('data-length') || 0;
            var target = counterElement.getAttribute('data-input') || 'input';
            var inputElement = counterElement.parentNode.querySelector(target);

            counterElement.innerText = maxLength;
            inputElement.addEventListener('input', function () {

                var charactersLeft = +maxLength - inputElement.value.trim().length;
                counterElement.innerText = charactersLeft;

                if (charactersLeft < 0) counterElement.classList.add('minus');else counterElement.classList.remove('minus');
            });
        });
    }
};

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

var _Utils = __webpack_require__(1);

var _Utils2 = _interopRequireDefault(_Utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _class = function () {

    /*
     * COMPONENT INITIALIZATION
     */

    /**
     * Start the component system and prepare components for use
     */
    function _class(components) {
        _classCallCheck(this, _class);

        this.components = [];
        this.modules = {};

        this.components = components;
        this.initializeComponents();
        this.resumeComponents();
    }

    /**
     * Initialize single component with all events
     */


    _createClass(_class, [{
        key: "initializeComponent",
        value: function initializeComponent(component) {

            // Select component
            var componentData = __webpack_require__(108)("./" + component);

            if (componentData.start) componentData.start();

            if (componentData.resume) componentData.resume();

            this.modules[component] = componentData;

            if (!componentData.events) return false;

            var eventsData = componentData.events;
            _Utils2.default.registerEvents(eventsData);
        }

        /**
         * Initialize all components needed
         */

    }, {
        key: "initializeComponents",
        value: function initializeComponents() {
            var _this = this;

            this.components.forEach(function (component) {
                return _this.initializeComponent(component);
            });
        }

        /*
         * DATA MANIPULATION
         */

        /**
         * Validate data of all components
         */

    }, {
        key: "validate",
        value: function validate() {

            for (var component = 0; component < this.components.length; ++component) {
                if (!this.modules[this.components[component]].validate()) return false;
            }return true;
        }

        /**
         * Serialize data from all components
         */

    }, {
        key: "serialize",
        value: function serialize() {
            var _this2 = this;

            var result = {};

            this.components.forEach(function (component) {
                result[component] = _this2.modules[component].serialize();
            });

            return result;
        }

        /*
         * COMPONENT INSTANCES
         */

        /**
         * Create component element from template
         * @param componentName
         * @return {*}
         */

    }, {
        key: "createFromTemplate",
        value: function createFromTemplate(componentName) {

            var templateElement = document.querySelector('#component_' + componentName + '_template');

            if (!templateElement) return false;

            return templateElement.children[0].cloneNode(true);
        }

        /**
         * Create new component instance
         */

    }, {
        key: "createComponent",
        value: function createComponent(componentName) {

            var inlineElement = document.querySelector('div.content-builder-content');

            if (typeof inlineElement === 'undefined') return false;

            if (!(componentName in this.modules)) return false;

            if (!("create" in this.modules[componentName])) return false;

            var template = this.createFromTemplate(componentName);

            if (!template) return false;

            var identifier = +new Date();
            template.setAttribute('data-id', identifier);

            this.modules[componentName].create(identifier, template);
            this.registerEvents(componentName, identifier, template);
            inlineElement.appendChild(template);

            if ('onCreate' in this.modules[componentName]) this.modules[componentName].onCreate(identifier);
        }

        /**
         * Register default events for new component instance
         */

    }, {
        key: "registerEvents",
        value: function registerEvents(name, identifier, parentElement, data) {

            var headerElement = parentElement.querySelector('div.component-element-header');
            var contentElement = parentElement.querySelector('div.component-element-content');
            var titleElement = headerElement.children[1];
            var titleDefault = titleElement.innerText;

            if (data && data.title !== '') titleElement.innerText = data.title.trim();

            // Delegate default events
            _Utils2.default.registerEvents([{
                event: 'click',
                element: headerElement,
                content: function content(event) {
                    var _this3 = this;

                    if (!event.target) return false;

                    var element = event.target;

                    // Select component title and focus
                    if (element.matches('.component-inline-label')) {
                        element.focus();
                        document.execCommand('selectAll', false, null);
                    }

                    // Collapse / Show component content
                    else if (element.matches('.component-inline-collapse')) contentElement.classList.toggle('hide');

                        // Disable / Enable component
                        else if (element.matches('.component-inline-disable')) {
                                parentElement.classList.toggle('disabled');
                                element.classList.toggle('icon-off');
                                this.modules[name].data[identifier].disabled ^= true;
                            }

                            // Remove component instance
                            else if (element.matches('.component-inline-remove')) {

                                    var componentName = headerElement.querySelector('.component-inline-label').innerText.trim();
                                    var actionText = _Global2.default.translate.locale.response['ACTION_CONFIRM_REMOVE_COMPONENT'].replace('%component%', componentName);

                                    confirmAction(actionText, function () {
                                        parentElement.parentNode.removeChild(parentElement);
                                        delete _this3.modules[name].data[identifier];
                                    });
                                }
                }
            }, {
                // Show placeholder when empty title
                event: 'blur',
                element: titleElement,
                content: function content() {
                    if (titleElement.innerText.trim() === '') titleElement.innerText = titleDefault;
                }
            }, {
                // Submit title on enter
                event: 'keypress',
                element: titleElement,
                content: function content(event) {

                    if (!event.keyCode || event.keyCode !== 13) return false;

                    titleElement.blur();
                    window.getSelection().removeAllRanges();
                    event.preventDefault();
                }
            }, {
                // Serialize component title
                event: 'keyup change',
                element: titleElement,
                content: function content(event) {
                    this.modules[name].data[identifier].title = event.target.innerText.trim();
                }
            }]);

            if (data && data.disabled !== 0) triggerEvent(headerElement.querySelector('.component-inline-disable'), 'click');
        }

        /*
         * RESUME MULTI INSTANCE COMPONENTS
         */

        /**
         * Resume multi instance components into content element
         */

    }, {
        key: "resumeComponents",
        value: function resumeComponents() {

            // Get components order
            var contentElement = document.querySelector('[data-order]');

            if (!contentElement) return true;

            var json = contentElement.getAttribute('data-order');

            if (!json || json === '') return false;

            var order = JSON.parse(contentElement.getAttribute('data-order'));

            if (!order || order === '') return true;

            // Save resume data
            var componentsResumeData = {};
            this.components.forEach(function (componentName) {

                var template = this.createFromTemplate(componentName);

                if (!template) return false;

                var resumeData = template.getAttribute('data-resume');

                if (!resumeData) return false;

                componentsResumeData[componentName] = {
                    template: template,
                    resume: JSON.parse(resumeData)
                };
            });

            // Resume each component
            if ((typeof order === "undefined" ? "undefined" : _typeof(order)) !== 'object') return true;

            order.forEach(function (componentID) {

                this.components.some(function (componentName) {

                    if (!componentsResumeData[componentName] || !componentsResumeData[componentName].template || !componentsResumeData[componentName].resume || !componentsResumeData[componentName].resume[componentID]) return false;

                    var current = this.modules[componentName];
                    var data = componentsResumeData[componentName];
                    var template = data.template.cloneNode(true);
                    var resumeData = data.resume[componentID];

                    template.setAttribute('data-id', componentID);

                    if (!current.resumeInline) return false;

                    current.resumeInline(componentID, template, resumeData);
                    this.registerEvents(componentName, componentID, template, resumeData);
                    contentElement.appendChild(template);

                    if (current.onCreate) current.onCreate(componentID);

                    return true;
                });
            });
        }
    }]);

    return _class;
}();

exports.default = _class;
;

/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./accessibility": 11,
	"./accessibility.js": 11,
	"./accessibility.min": 12,
	"./accessibility.min.js": 12,
	"./analytics": 13,
	"./analytics.js": 13,
	"./analytics.min": 14,
	"./analytics.min.js": 14,
	"./attachments": 15,
	"./attachments.js": 15,
	"./attachments.min": 16,
	"./attachments.min.js": 16,
	"./audio": 17,
	"./audio.js": 17,
	"./audio.min": 18,
	"./audio.min.js": 18,
	"./author": 19,
	"./author.js": 19,
	"./author.min": 20,
	"./author.min.js": 20,
	"./categories": 21,
	"./categories.js": 21,
	"./categories.min": 22,
	"./categories.min.js": 22,
	"./code": 23,
	"./code.js": 23,
	"./code.min": 24,
	"./code.min.js": 24,
	"./comments": 25,
	"./comments.js": 25,
	"./comments.min": 26,
	"./comments.min.js": 26,
	"./copyright": 27,
	"./copyright.js": 27,
	"./copyright.min": 28,
	"./copyright.min.js": 28,
	"./created_at": 29,
	"./created_at.js": 29,
	"./created_at.min": 30,
	"./created_at.min.js": 30,
	"./custom_fields": 31,
	"./custom_fields.js": 31,
	"./custom_fields.min": 32,
	"./custom_fields.min.js": 32,
	"./excerpt": 33,
	"./excerpt.js": 33,
	"./gallery": 34,
	"./gallery.js": 34,
	"./gallery.min": 35,
	"./gallery.min.js": 35,
	"./header_image": 36,
	"./header_image.js": 36,
	"./header_image.min": 37,
	"./header_image.min.js": 37,
	"./heading": 38,
	"./heading.js": 38,
	"./heading.min": 39,
	"./heading.min.js": 39,
	"./languages": 40,
	"./languages.js": 40,
	"./languages.min": 41,
	"./languages.min.js": 41,
	"./last_update": 42,
	"./last_update.js": 42,
	"./last_update.min": 43,
	"./last_update.min.js": 43,
	"./link": 44,
	"./link.js": 44,
	"./link.min": 45,
	"./link.min.js": 45,
	"./list": 46,
	"./list.js": 46,
	"./list.min": 47,
	"./list.min.js": 47,
	"./menu_link": 48,
	"./menu_link.js": 48,
	"./menu_link.min": 49,
	"./menu_link.min.js": 49,
	"./meta": 50,
	"./meta.js": 50,
	"./meta.min": 51,
	"./meta.min.js": 51,
	"./mistakes": 52,
	"./mistakes.js": 52,
	"./mistakes.min": 53,
	"./mistakes.min.js": 53,
	"./note": 54,
	"./note.js": 54,
	"./note.min": 55,
	"./note.min.js": 55,
	"./perex": 56,
	"./perex.js": 56,
	"./perex.min": 57,
	"./perex.min.js": 57,
	"./picture": 58,
	"./picture.js": 58,
	"./picture.min": 59,
	"./picture.min.js": 59,
	"./pin": 60,
	"./pin.js": 60,
	"./planner": 62,
	"./planner.js": 62,
	"./planner.min": 63,
	"./planner.min.js": 63,
	"./poll": 64,
	"./poll.js": 64,
	"./poll.min": 65,
	"./poll.min.js": 65,
	"./quote": 66,
	"./quote.js": 66,
	"./quote.min": 67,
	"./quote.min.js": 67,
	"./rating": 68,
	"./rating.js": 68,
	"./rating.min": 69,
	"./rating.min.js": 69,
	"./revisions": 70,
	"./revisions.js": 70,
	"./revisions.min": 71,
	"./revisions.min.js": 71,
	"./rich_text": 72,
	"./rich_text.js": 72,
	"./rich_text.min": 73,
	"./rich_text.min.js": 73,
	"./sources": 74,
	"./sources.js": 74,
	"./sources.min": 75,
	"./sources.min.js": 75,
	"./status": 76,
	"./status.js": 76,
	"./status.min": 77,
	"./status.min.js": 77,
	"./table": 78,
	"./table.js": 78,
	"./table.min": 79,
	"./table.min.js": 79,
	"./tags": 80,
	"./tags.js": 80,
	"./tags.min": 81,
	"./tags.min.js": 81,
	"./thumbnail": 82,
	"./thumbnail.js": 82,
	"./thumbnail.min": 83,
	"./thumbnail.min.js": 83,
	"./title": 84,
	"./title.js": 84,
	"./url": 85,
	"./url.js": 85,
	"./video": 87,
	"./video.js": 87,
	"./video.min": 88,
	"./video.min.js": 88
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number or string
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 108;

/***/ }),
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _flatpickr = __webpack_require__(114);

var _flatpickr2 = _interopRequireDefault(_flatpickr);

var _Global = __webpack_require__(0);

var _Global2 = _interopRequireDefault(_Global);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {

    locale: __webpack_require__(162)("./" + _Global2.default.translate.language),

    initialize: function initialize() {

        this.dateTimePicker();
        this.dateTimePickerMin();
        this.dateTimePickerMax();
        this.datePicker();
        this.datePickerMax();
        this.datePickerMin();
    },
    dateTimePicker: function dateTimePicker() {

        (0, _flatpickr2.default)(".datetime-picker", {
            altFormat: true,
            dateFormat: 'd.m.Y H:i:s',
            enableTime: true,
            enableSeconds: true,
            locale: this.locale,
            disableMobile: true,
            time_24hr: true
        });
    },
    dateTimePickerMin: function dateTimePickerMin() {

        (0, _flatpickr2.default)(".datetime-picker-min", {
            altFormat: true,
            dateFormat: 'd.m.Y H:i:s',
            enableTime: true,
            enableSeconds: true,
            minDate: 'today',
            locale: this.locale,
            disableMobile: true,
            time_24hr: true
        });
    },
    dateTimePickerMax: function dateTimePickerMax() {

        (0, _flatpickr2.default)(".datetime-picker-max", {
            altFormat: true,
            dateFormat: 'd.m.Y H:i:s',
            enableTime: true,
            enableSeconds: true,
            maxDate: 'today',
            locale: this.locale,
            disableMobile: true,
            time_24hr: true
        });
    },
    datePicker: function datePicker() {

        (0, _flatpickr2.default)(".date-picker", {
            altFormat: true,
            dateFormat: 'd.m.Y',
            locale: this.locale,
            disableMobile: true
        });
    },
    datePickerMax: function datePickerMax() {

        (0, _flatpickr2.default)(".date-picker-max", {
            altFormat: true,
            dateFormat: 'd.m.Y',
            maxDate: 'today',
            locale: this.locale,
            disableMobile: true
        });
    },
    datePickerMin: function datePickerMin() {

        (0, _flatpickr2.default)(".date-picker-min", {
            altFormat: true,
            dateFormat: 'd.m.Y',
            minDate: 'today',
            locale: this.locale,
            disableMobile: true
        });
    }
};

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*! flatpickr v3.0.6, @license MIT */
function FlatpickrInstance(element, config) {
	var self = this;

	self._ = {};
	self._.afterDayAnim = afterDayAnim;
	self._bind = bind;
	self._compareDates = compareDates;
	self._setHoursFromDate = setHoursFromDate;
	self.changeMonth = changeMonth;
	self.changeYear = changeYear;
	self.clear = clear;
	self.close = close;
	self._createElement = createElement;
	self.destroy = destroy;
	self.isEnabled = isEnabled;
	self.jumpToDate = jumpToDate;
	self.open = open;
	self.redraw = redraw;
	self.set = set;
	self.setDate = setDate;
	self.toggle = toggle;

	function init() {
		self.element = self.input = element;
		self.instanceConfig = config || {};
		self.parseDate = FlatpickrInstance.prototype.parseDate.bind(self);
		self.formatDate = FlatpickrInstance.prototype.formatDate.bind(self);

		setupFormats();
		parseConfig();
		setupLocale();
		setupInputs();
		setupDates();
		setupHelperFunctions();

		self.isOpen = false;

		self.isMobile = !self.config.disableMobile && !self.config.inline && self.config.mode === "single" && !self.config.disable.length && !self.config.enable.length && !self.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

		if (!self.isMobile) build();

		bindEvents();

		if (self.selectedDates.length || self.config.noCalendar) {
			if (self.config.enableTime) {
				setHoursFromDate(self.config.noCalendar ? self.latestSelectedDateObj || self.config.minDate : null);
			}
			updateValue(false);
		}

		self.showTimeInput = self.selectedDates.length > 0 || self.config.noCalendar;

		if (self.config.weekNumbers) {
			self.calendarContainer.style.width = self.daysContainer.offsetWidth + self.weekWrapper.offsetWidth + "px";
		}

		if (!self.isMobile) positionCalendar();

		triggerEvent("Ready");
	}

	/**
  * Binds a function to the current flatpickr instance
  * @param {Function} fn the function
  * @return {Function} the function bound to the instance
  */
	function bindToInstance(fn) {
		return fn.bind(self);
	}

	/**
  * The handler for all events targeting the time inputs
  * @param {Event} e the event - "input", "wheel", "increment", etc
  */
	function updateTime(e) {
		if (self.config.noCalendar && !self.selectedDates.length)
			// picking time only
			self.selectedDates = [self.now];

		timeWrapper(e);

		if (!self.selectedDates.length) return;

		if (!self.minDateHasTime || e.type !== "input" || e.target.value.length >= 2) {
			setHoursFromInputs();
			updateValue();
		} else {
			setTimeout(function () {
				setHoursFromInputs();
				updateValue();
			}, 1000);
		}
	}

	/**
  * Syncs the selected date object time with user's time input
  */
	function setHoursFromInputs() {
		if (!self.config.enableTime) return;

		var hours = (parseInt(self.hourElement.value, 10) || 0) % (self.amPM ? 12 : 24),
		    minutes = (parseInt(self.minuteElement.value, 10) || 0) % 60,
		    seconds = self.config.enableSeconds ? (parseInt(self.secondElement.value, 10) || 0) % 60 : 0;

		if (self.amPM !== undefined) hours = hours % 12 + 12 * (self.amPM.textContent === "PM");

		if (self.minDateHasTime && compareDates(self.latestSelectedDateObj, self.config.minDate) === 0) {

			hours = Math.max(hours, self.config.minDate.getHours());
			if (hours === self.config.minDate.getHours()) minutes = Math.max(minutes, self.config.minDate.getMinutes());
		}

		if (self.maxDateHasTime && compareDates(self.latestSelectedDateObj, self.config.maxDate) === 0) {
			hours = Math.min(hours, self.config.maxDate.getHours());
			if (hours === self.config.maxDate.getHours()) minutes = Math.min(minutes, self.config.maxDate.getMinutes());
		}

		setHours(hours, minutes, seconds);
	}

	/**
  * Syncs time input values with a date
  * @param {Date} dateObj the date to sync with
  */
	function setHoursFromDate(dateObj) {
		var date = dateObj || self.latestSelectedDateObj;

		if (date) setHours(date.getHours(), date.getMinutes(), date.getSeconds());
	}

	/**
  * Sets the hours, minutes, and optionally seconds
  * of the latest selected date object and the
  * corresponding time inputs
  * @param {Number} hours the hour. whether its military
  *                 or am-pm gets inferred from config
  * @param {Number} minutes the minutes
  * @param {Number} seconds the seconds (optional)
  */
	function setHours(hours, minutes, seconds) {
		if (self.selectedDates.length) {
			self.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
		}

		if (!self.config.enableTime || self.isMobile) return;

		self.hourElement.value = self.pad(!self.config.time_24hr ? (12 + hours) % 12 + 12 * (hours % 12 === 0) : hours);

		self.minuteElement.value = self.pad(minutes);

		if (!self.config.time_24hr) self.amPM.textContent = hours >= 12 ? "PM" : "AM";

		if (self.config.enableSeconds === true) self.secondElement.value = self.pad(seconds);
	}

	/**
  * Handles the year input and incrementing events
  * @param {Event} event the keyup or increment event
  */
	function onYearInput(event) {
		var year = event.target.value;
		if (event.delta) year = (parseInt(year) + event.delta).toString();

		if (year.length === 4 || event.key === "Enter") {
			self.currentYearElement.blur();
			if (!/[^\d]/.test(year)) changeYear(year);
		}
	}

	/**
  * Essentially addEventListener + tracking
  * @param {Element} element the element to addEventListener to
  * @param {String} event the event name
  * @param {Function} handler the event handler
  */
	function bind(element, event, handler) {
		if (event instanceof Array) return event.forEach(function (ev) {
			return bind(element, ev, handler);
		});

		if (element instanceof Array) return element.forEach(function (el) {
			return bind(el, event, handler);
		});

		element.addEventListener(event, handler);
		self._handlers.push({ element: element, event: event, handler: handler });
	}

	/**
  * A mousedown handler which mimics click.
  * Minimizes latency, since we don't need to wait for mouseup in most cases.
  * Also, avoids handling right clicks.
  *
  * @param {Function} handler the event handler
  */
	function onClick(handler) {
		return function (evt) {
			return evt.which === 1 && handler(evt);
		};
	}

	/**
  * Adds all the necessary event listeners
  */
	function bindEvents() {
		self._handlers = [];
		self._animationLoop = [];
		if (self.config.wrap) {
			["open", "close", "toggle", "clear"].forEach(function (evt) {
				Array.prototype.forEach.call(self.element.querySelectorAll("[data-" + evt + "]"), function (el) {
					return bind(el, "mousedown", onClick(self[evt]));
				});
			});
		}

		if (self.isMobile) return setupMobile();

		self.debouncedResize = debounce(onResize, 50);
		self.triggerChange = function () {
			triggerEvent("Change");
		};
		self.debouncedChange = debounce(self.triggerChange, 300);

		if (self.config.mode === "range" && self.daysContainer) bind(self.daysContainer, "mouseover", function (e) {
			return onMouseOver(e.target);
		});

		bind(window.document.body, "keydown", onKeyDown);

		if (!self.config.static) bind(self._input, "keydown", onKeyDown);

		if (!self.config.inline && !self.config.static) bind(window, "resize", self.debouncedResize);

		if (window.ontouchstart !== undefined) bind(window.document, "touchstart", documentClick);

		bind(window.document, "mousedown", onClick(documentClick));
		bind(self._input, "blur", documentClick);

		if (self.config.clickOpens === true) {
			bind(self._input, "focus", self.open);
			bind(self._input, "mousedown", onClick(self.open));
		}

		if (!self.config.noCalendar) {
			self.monthNav.addEventListener("wheel", function (e) {
				return e.preventDefault();
			});
			bind(self.monthNav, "wheel", debounce(onMonthNavScroll, 10));
			bind(self.monthNav, "mousedown", onClick(onMonthNavClick));

			bind(self.monthNav, ["keyup", "increment"], onYearInput);
			bind(self.daysContainer, "mousedown", onClick(selectDate));

			if (self.config.animate) {
				bind(self.daysContainer, ["webkitAnimationEnd", "animationend"], animateDays);
				bind(self.monthNav, ["webkitAnimationEnd", "animationend"], animateMonths);
			}
		}

		if (self.config.enableTime) {
			var selText = function selText(e) {
				return e.target.select();
			};
			bind(self.timeContainer, ["wheel", "input", "increment"], updateTime);
			bind(self.timeContainer, "mousedown", onClick(timeIncrement));

			bind(self.timeContainer, ["wheel", "increment"], self.debouncedChange);
			bind(self.timeContainer, "input", self.triggerChange);

			bind([self.hourElement, self.minuteElement], "focus", selText);

			if (self.secondElement !== undefined) bind(self.secondElement, "focus", function () {
				return self.secondElement.select();
			});

			if (self.amPM !== undefined) {
				bind(self.amPM, "mousedown", onClick(function (e) {
					updateTime(e);
					self.triggerChange(e);
				}));
			}
		}
	}

	function processPostDayAnimation() {
		for (var i = self._animationLoop.length; i--;) {
			self._animationLoop[i]();
			self._animationLoop.splice(i, 1);
		}
	}

	/**
  * Removes the day container that slided out of view
  * @param {Event} e the animation event
  */
	function animateDays(e) {
		if (self.daysContainer.childNodes.length > 1) {
			switch (e.animationName) {
				case "fpSlideLeft":
					self.daysContainer.lastChild.classList.remove("slideLeftNew");
					self.daysContainer.removeChild(self.daysContainer.firstChild);
					self.days = self.daysContainer.firstChild;
					processPostDayAnimation();

					break;

				case "fpSlideRight":
					self.daysContainer.firstChild.classList.remove("slideRightNew");
					self.daysContainer.removeChild(self.daysContainer.lastChild);
					self.days = self.daysContainer.firstChild;
					processPostDayAnimation();

					break;

				default:
					break;
			}
		}
	}

	/**
  * Removes the month element that animated out of view
  * @param {Event} e the animation event
  */
	function animateMonths(e) {
		switch (e.animationName) {
			case "fpSlideLeftNew":
			case "fpSlideRightNew":
				self.navigationCurrentMonth.classList.remove("slideLeftNew");
				self.navigationCurrentMonth.classList.remove("slideRightNew");
				var nav = self.navigationCurrentMonth;

				while (nav.nextSibling && /curr/.test(nav.nextSibling.className)) {
					self.monthNav.removeChild(nav.nextSibling);
				}while (nav.previousSibling && /curr/.test(nav.previousSibling.className)) {
					self.monthNav.removeChild(nav.previousSibling);
				}self.oldCurMonth = null;
				break;
		}
	}

	/**
  * Set the calendar view to a particular date.
  * @param {Date} jumpDate the date to set the view to
  */
	function jumpToDate(jumpDate) {
		jumpDate = jumpDate ? self.parseDate(jumpDate) : self.latestSelectedDateObj || (self.config.minDate > self.now ? self.config.minDate : self.config.maxDate && self.config.maxDate < self.now ? self.config.maxDate : self.now);

		try {
			self.currentYear = jumpDate.getFullYear();
			self.currentMonth = jumpDate.getMonth();
		} catch (e) {
			/* istanbul ignore next */
			console.error(e.stack);
			/* istanbul ignore next */
			console.warn("Invalid date supplied: " + jumpDate);
		}

		self.redraw();
	}

	/**
  * The up/down arrow handler for time inputs
  * @param {Event} e the click event
  */
	function timeIncrement(e) {
		if (~e.target.className.indexOf("arrow")) incrementNumInput(e, e.target.classList.contains("arrowUp") ? 1 : -1);
	}

	/**
  * Increments/decrements the value of input associ-
  * ated with the up/down arrow by dispatching an
  * "increment" event on the input.
  *
  * @param {Event} e the click event
  * @param {Number} delta the diff (usually 1 or -1)
  * @param {Element} inputElem the input element
  */
	function incrementNumInput(e, delta, inputElem) {
		var input = inputElem || e.target.parentNode.childNodes[0];
		var event = createEvent("increment");
		event.delta = delta;
		input.dispatchEvent(event);
	}

	function createNumberInput(inputClassName) {
		var wrapper = createElement("div", "numInputWrapper"),
		    numInput = createElement("input", "numInput " + inputClassName),
		    arrowUp = createElement("span", "arrowUp"),
		    arrowDown = createElement("span", "arrowDown");

		numInput.type = "text";
		numInput.pattern = "\\d*";

		wrapper.appendChild(numInput);
		wrapper.appendChild(arrowUp);
		wrapper.appendChild(arrowDown);

		return wrapper;
	}

	function build() {
		var fragment = window.document.createDocumentFragment();
		self.calendarContainer = createElement("div", "flatpickr-calendar");
		self.calendarContainer.tabIndex = -1;

		if (!self.config.noCalendar) {
			fragment.appendChild(buildMonthNav());
			self.innerContainer = createElement("div", "flatpickr-innerContainer");

			if (self.config.weekNumbers) self.innerContainer.appendChild(buildWeeks());

			self.rContainer = createElement("div", "flatpickr-rContainer");
			self.rContainer.appendChild(buildWeekdays());

			if (!self.daysContainer) {
				self.daysContainer = createElement("div", "flatpickr-days");
				self.daysContainer.tabIndex = -1;
			}

			buildDays();
			self.rContainer.appendChild(self.daysContainer);

			self.innerContainer.appendChild(self.rContainer);
			fragment.appendChild(self.innerContainer);
		}

		if (self.config.enableTime) fragment.appendChild(buildTime());

		toggleClass(self.calendarContainer, "rangeMode", self.config.mode === "range");
		toggleClass(self.calendarContainer, "animate", self.config.animate);

		self.calendarContainer.appendChild(fragment);

		var customAppend = self.config.appendTo && self.config.appendTo.nodeType;

		if (self.config.inline || self.config.static) {
			self.calendarContainer.classList.add(self.config.inline ? "inline" : "static");

			if (self.config.inline && !customAppend) {
				return self.element.parentNode.insertBefore(self.calendarContainer, self._input.nextSibling);
			}

			if (self.config.static) {
				var wrapper = createElement("div", "flatpickr-wrapper");
				self.element.parentNode.insertBefore(wrapper, self.element);
				wrapper.appendChild(self.element);

				if (self.altInput) wrapper.appendChild(self.altInput);

				wrapper.appendChild(self.calendarContainer);
				return;
			}
		}

		(customAppend ? self.config.appendTo : window.document.body).appendChild(self.calendarContainer);
	}

	function createDay(className, date, dayNumber, i) {
		var dateIsEnabled = isEnabled(date, true),
		    dayElement = createElement("span", "flatpickr-day " + className, date.getDate());

		dayElement.dateObj = date;
		dayElement.$i = i;
		dayElement.setAttribute("aria-label", self.formatDate(date, self.config.ariaDateFormat));

		if (compareDates(date, self.now) === 0) {
			self.todayDateElem = dayElement;
			dayElement.classList.add("today");
		}

		if (dateIsEnabled) {
			dayElement.tabIndex = -1;
			if (isDateSelected(date)) {
				dayElement.classList.add("selected");
				self.selectedDateElem = dayElement;
				if (self.config.mode === "range") {
					toggleClass(dayElement, "startRange", compareDates(date, self.selectedDates[0]) === 0);

					toggleClass(dayElement, "endRange", compareDates(date, self.selectedDates[1]) === 0);
				}
			}
		} else {
			dayElement.classList.add("disabled");
			if (self.selectedDates[0] && date > self.minRangeDate && date < self.selectedDates[0]) self.minRangeDate = date;else if (self.selectedDates[0] && date < self.maxRangeDate && date > self.selectedDates[0]) self.maxRangeDate = date;
		}

		if (self.config.mode === "range") {
			if (isDateInRange(date) && !isDateSelected(date)) dayElement.classList.add("inRange");

			if (self.selectedDates.length === 1 && (date < self.minRangeDate || date > self.maxRangeDate)) dayElement.classList.add("notAllowed");
		}

		if (self.config.weekNumbers && className !== "prevMonthDay" && dayNumber % 7 === 1) {
			self.weekNumbers.insertAdjacentHTML("beforeend", "<span class='disabled flatpickr-day'>" + self.config.getWeek(date) + "</span>");
		}

		triggerEvent("DayCreate", dayElement);

		return dayElement;
	}

	function focusOnDay(currentIndex, offset) {
		var newIndex = currentIndex + offset || 0,
		    targetNode = currentIndex !== undefined ? self.days.childNodes[newIndex] : self.selectedDateElem || self.todayDateElem || self.days.childNodes[0],
		    focus = function focus() {
			targetNode = targetNode || self.days.childNodes[newIndex];
			targetNode.focus();

			if (self.config.mode === "range") onMouseOver(targetNode);
		};

		if (targetNode === undefined && offset !== 0) {
			if (offset > 0) {
				self.changeMonth(1);
				newIndex = newIndex % 42;
			} else if (offset < 0) {
				self.changeMonth(-1);
				newIndex += 42;
			}

			return afterDayAnim(focus);
		}

		focus();
	}

	function afterDayAnim(fn) {
		if (self.config.animate === true) return self._animationLoop.push(fn);
		fn();
	}

	function buildDays(delta) {
		var firstOfMonth = (new Date(self.currentYear, self.currentMonth, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7,
		    isRangeMode = self.config.mode === "range";

		self.prevMonthDays = self.utils.getDaysinMonth((self.currentMonth - 1 + 12) % 12);
		self.selectedDateElem = undefined;
		self.todayDateElem = undefined;

		var daysInMonth = self.utils.getDaysinMonth(),
		    days = window.document.createDocumentFragment();

		var dayNumber = self.prevMonthDays + 1 - firstOfMonth,
		    dayIndex = 0;

		if (self.config.weekNumbers && self.weekNumbers.firstChild) self.weekNumbers.textContent = "";

		if (isRangeMode) {
			// const dateLimits = self.config.enable.length || self.config.disable.length || self.config.mixDate || self.config.maxDate;
			self.minRangeDate = new Date(self.currentYear, self.currentMonth - 1, dayNumber);
			self.maxRangeDate = new Date(self.currentYear, self.currentMonth + 1, (42 - firstOfMonth) % daysInMonth);
		}

		// prepend days from the ending of previous month
		for (; dayNumber <= self.prevMonthDays; dayNumber++, dayIndex++) {
			days.appendChild(createDay("prevMonthDay", new Date(self.currentYear, self.currentMonth - 1, dayNumber), dayNumber, dayIndex));
		}

		// Start at 1 since there is no 0th day
		for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
			days.appendChild(createDay("", new Date(self.currentYear, self.currentMonth, dayNumber), dayNumber, dayIndex));
		}

		// append days from the next month
		for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth; dayNum++, dayIndex++) {
			days.appendChild(createDay("nextMonthDay", new Date(self.currentYear, self.currentMonth + 1, dayNum % daysInMonth), dayNum, dayIndex));
		}

		if (isRangeMode && self.selectedDates.length === 1 && days.childNodes[0]) {
			self._hidePrevMonthArrow = self._hidePrevMonthArrow || self.minRangeDate > days.childNodes[0].dateObj;

			self._hideNextMonthArrow = self._hideNextMonthArrow || self.maxRangeDate < new Date(self.currentYear, self.currentMonth + 1, 1);
		} else updateNavigationCurrentMonth();

		var dayContainer = createElement("div", "dayContainer");
		dayContainer.appendChild(days);

		if (!self.config.animate || delta === undefined) clearNode(self.daysContainer);else {
			while (self.daysContainer.childNodes.length > 1) {
				self.daysContainer.removeChild(self.daysContainer.firstChild);
			}
		}

		if (delta >= 0) self.daysContainer.appendChild(dayContainer);else self.daysContainer.insertBefore(dayContainer, self.daysContainer.firstChild);

		self.days = self.daysContainer.firstChild;
		return self.daysContainer;
	}

	function clearNode(node) {
		while (node.firstChild) {
			node.removeChild(node.firstChild);
		}
	}

	function buildMonthNav() {
		var monthNavFragment = window.document.createDocumentFragment();
		self.monthNav = createElement("div", "flatpickr-month");

		self.prevMonthNav = createElement("span", "flatpickr-prev-month");
		self.prevMonthNav.innerHTML = self.config.prevArrow;

		self.currentMonthElement = createElement("span", "cur-month");
		self.currentMonthElement.title = self.l10n.scrollTitle;

		var yearInput = createNumberInput("cur-year");
		self.currentYearElement = yearInput.childNodes[0];
		self.currentYearElement.title = self.l10n.scrollTitle;

		if (self.config.minDate) self.currentYearElement.min = self.config.minDate.getFullYear();

		if (self.config.maxDate) {
			self.currentYearElement.max = self.config.maxDate.getFullYear();

			self.currentYearElement.disabled = self.config.minDate && self.config.minDate.getFullYear() === self.config.maxDate.getFullYear();
		}

		self.nextMonthNav = createElement("span", "flatpickr-next-month");
		self.nextMonthNav.innerHTML = self.config.nextArrow;

		self.navigationCurrentMonth = createElement("span", "flatpickr-current-month");
		self.navigationCurrentMonth.appendChild(self.currentMonthElement);
		self.navigationCurrentMonth.appendChild(yearInput);

		monthNavFragment.appendChild(self.prevMonthNav);
		monthNavFragment.appendChild(self.navigationCurrentMonth);
		monthNavFragment.appendChild(self.nextMonthNav);
		self.monthNav.appendChild(monthNavFragment);

		Object.defineProperty(self, "_hidePrevMonthArrow", {
			get: function get() {
				return this.__hidePrevMonthArrow;
			},
			set: function set(bool) {
				if (this.__hidePrevMonthArrow !== bool) self.prevMonthNav.style.display = bool ? "none" : "block";
				this.__hidePrevMonthArrow = bool;
			}
		});

		Object.defineProperty(self, "_hideNextMonthArrow", {
			get: function get() {
				return this.__hideNextMonthArrow;
			},
			set: function set(bool) {
				if (this.__hideNextMonthArrow !== bool) self.nextMonthNav.style.display = bool ? "none" : "block";
				this.__hideNextMonthArrow = bool;
			}
		});

		updateNavigationCurrentMonth();

		return self.monthNav;
	}

	function buildTime() {
		self.calendarContainer.classList.add("hasTime");
		if (self.config.noCalendar) self.calendarContainer.classList.add("noCalendar");
		self.timeContainer = createElement("div", "flatpickr-time");
		self.timeContainer.tabIndex = -1;
		var separator = createElement("span", "flatpickr-time-separator", ":");

		var hourInput = createNumberInput("flatpickr-hour");
		self.hourElement = hourInput.childNodes[0];

		var minuteInput = createNumberInput("flatpickr-minute");
		self.minuteElement = minuteInput.childNodes[0];

		self.hourElement.tabIndex = self.minuteElement.tabIndex = -1;

		self.hourElement.value = self.pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getHours() : self.config.defaultHour % (self.time_24hr ? 24 : 12));

		self.minuteElement.value = self.pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getMinutes() : self.config.defaultMinute);

		self.hourElement.step = self.config.hourIncrement;
		self.minuteElement.step = self.config.minuteIncrement;

		self.hourElement.min = self.config.time_24hr ? 0 : 1;
		self.hourElement.max = self.config.time_24hr ? 23 : 12;

		self.minuteElement.min = 0;
		self.minuteElement.max = 59;

		self.hourElement.title = self.minuteElement.title = self.l10n.scrollTitle;

		self.timeContainer.appendChild(hourInput);
		self.timeContainer.appendChild(separator);
		self.timeContainer.appendChild(minuteInput);

		if (self.config.time_24hr) self.timeContainer.classList.add("time24hr");

		if (self.config.enableSeconds) {
			self.timeContainer.classList.add("hasSeconds");

			var secondInput = createNumberInput("flatpickr-second");
			self.secondElement = secondInput.childNodes[0];

			self.secondElement.value = self.pad(self.latestSelectedDateObj ? self.latestSelectedDateObj.getSeconds() : self.config.defaultSeconds);

			self.secondElement.step = self.minuteElement.step;
			self.secondElement.min = self.minuteElement.min;
			self.secondElement.max = self.minuteElement.max;

			self.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
			self.timeContainer.appendChild(secondInput);
		}

		if (!self.config.time_24hr) {
			// add self.amPM if appropriate
			self.amPM = createElement("span", "flatpickr-am-pm", ["AM", "PM"][(self.latestSelectedDateObj ? self.hourElement.value : self.config.defaultHour) > 11 | 0]);
			self.amPM.title = self.l10n.toggleTitle;
			self.amPM.tabIndex = -1;
			self.timeContainer.appendChild(self.amPM);
		}

		return self.timeContainer;
	}

	function buildWeekdays() {
		if (!self.weekdayContainer) self.weekdayContainer = createElement("div", "flatpickr-weekdays");

		var firstDayOfWeek = self.l10n.firstDayOfWeek;
		var weekdays = self.l10n.weekdays.shorthand.slice();

		if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
			weekdays = [].concat(weekdays.splice(firstDayOfWeek, weekdays.length), weekdays.splice(0, firstDayOfWeek));
		}

		self.weekdayContainer.innerHTML = "\n\t\t<span class=flatpickr-weekday>\n\t\t\t" + weekdays.join("</span><span class=flatpickr-weekday>") + "\n\t\t</span>\n\t\t";

		return self.weekdayContainer;
	}

	/* istanbul ignore next */
	function buildWeeks() {
		self.calendarContainer.classList.add("hasWeeks");
		self.weekWrapper = createElement("div", "flatpickr-weekwrapper");
		self.weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self.l10n.weekAbbreviation));
		self.weekNumbers = createElement("div", "flatpickr-weeks");
		self.weekWrapper.appendChild(self.weekNumbers);

		return self.weekWrapper;
	}

	function changeMonth(value, is_offset, animate) {
		is_offset = is_offset === undefined || is_offset;
		var delta = is_offset ? value : value - self.currentMonth;
		var skipAnimations = !self.config.animate || animate === false;

		if (delta < 0 && self._hidePrevMonthArrow || delta > 0 && self._hideNextMonthArrow) return;

		self.currentMonth += delta;

		if (self.currentMonth < 0 || self.currentMonth > 11) {
			self.currentYear += self.currentMonth > 11 ? 1 : -1;
			self.currentMonth = (self.currentMonth + 12) % 12;

			triggerEvent("YearChange");
		}

		buildDays(!skipAnimations ? delta : undefined);

		if (skipAnimations) {
			triggerEvent("MonthChange");
			return updateNavigationCurrentMonth();
		}

		// remove possible remnants from clicking too fast
		var nav = self.navigationCurrentMonth;
		if (delta < 0) {
			while (nav.nextSibling && /curr/.test(nav.nextSibling.className)) {
				self.monthNav.removeChild(nav.nextSibling);
			}
		} else if (delta > 0) {
			while (nav.previousSibling && /curr/.test(nav.previousSibling.className)) {
				self.monthNav.removeChild(nav.previousSibling);
			}
		}

		self.oldCurMonth = self.navigationCurrentMonth;

		self.navigationCurrentMonth = self.monthNav.insertBefore(self.oldCurMonth.cloneNode(true), delta > 0 ? self.oldCurMonth.nextSibling : self.oldCurMonth);

		if (delta > 0) {
			self.daysContainer.firstChild.classList.add("slideLeft");
			self.daysContainer.lastChild.classList.add("slideLeftNew");

			self.oldCurMonth.classList.add("slideLeft");
			self.navigationCurrentMonth.classList.add("slideLeftNew");
		} else if (delta < 0) {
			self.daysContainer.firstChild.classList.add("slideRightNew");
			self.daysContainer.lastChild.classList.add("slideRight");

			self.oldCurMonth.classList.add("slideRight");
			self.navigationCurrentMonth.classList.add("slideRightNew");
		}

		self.currentMonthElement = self.navigationCurrentMonth.firstChild;
		self.currentYearElement = self.navigationCurrentMonth.lastChild.childNodes[0];

		updateNavigationCurrentMonth();
		self.oldCurMonth.firstChild.textContent = self.utils.monthToStr(self.currentMonth - delta);

		triggerEvent("MonthChange");

		if (document.activeElement && document.activeElement.$i) {
			var index = document.activeElement.$i;
			afterDayAnim(function () {
				focusOnDay(index, 0);
			});
		}
	}

	function clear(triggerChangeEvent) {
		self.input.value = "";

		if (self.altInput) self.altInput.value = "";

		if (self.mobileInput) self.mobileInput.value = "";

		self.selectedDates = [];
		self.latestSelectedDateObj = undefined;
		self.showTimeInput = false;

		self.redraw();

		if (triggerChangeEvent !== false)
			// triggerChangeEvent is true (default) or an Event
			triggerEvent("Change");
	}

	function close() {
		self.isOpen = false;

		if (!self.isMobile) {
			self.calendarContainer.classList.remove("open");
			self._input.classList.remove("active");
		}

		triggerEvent("Close");
	}

	function destroy() {
		if (self.config !== undefined) triggerEvent("Destroy");

		for (var i = self._handlers.length; i--;) {
			var h = self._handlers[i];
			h.element.removeEventListener(h.event, h.handler);
		}

		self._handlers = [];

		if (self.mobileInput) {
			if (self.mobileInput.parentNode) self.mobileInput.parentNode.removeChild(self.mobileInput);
			self.mobileInput = null;
		} else if (self.calendarContainer && self.calendarContainer.parentNode) self.calendarContainer.parentNode.removeChild(self.calendarContainer);

		if (self.altInput) {
			self.input.type = "text";
			if (self.altInput.parentNode) self.altInput.parentNode.removeChild(self.altInput);
			delete self.altInput;
		}

		if (self.input) {
			self.input.type = self.input._type;
			self.input.classList.remove("flatpickr-input");
			self.input.removeAttribute("readonly");
			self.input.value = "";
		}

		["_showTimeInput", "latestSelectedDateObj", "_hideNextMonthArrow", "_hidePrevMonthArrow", "__hideNextMonthArrow", "__hidePrevMonthArrow", "isMobile", "isOpen", "selectedDateElem", "minDateHasTime", "maxDateHasTime", "days", "daysContainer", "_input", "_positionElement", "innerContainer", "rContainer", "monthNav", "todayDateElem", "calendarContainer", "weekdayContainer", "prevMonthNav", "nextMonthNav", "currentMonthElement", "currentYearElement", "navigationCurrentMonth", "selectedDateElem", "config"].forEach(function (k) {
			try {
				delete self[k];
			} catch (e) {}
		});
	}

	function isCalendarElem(elem) {
		if (self.config.appendTo && self.config.appendTo.contains(elem)) return true;

		return self.calendarContainer.contains(elem);
	}

	function documentClick(e) {
		if (self.isOpen && !self.config.inline) {
			var isCalendarElement = isCalendarElem(e.target);
			var isInput = e.target === self.input || e.target === self.altInput || self.element.contains(e.target) ||
			// web components
			e.path && e.path.indexOf && (~e.path.indexOf(self.input) || ~e.path.indexOf(self.altInput));

			var lostFocus = e.type === "blur" ? isInput && e.relatedTarget && !isCalendarElem(e.relatedTarget) : !isInput && !isCalendarElement;

			if (lostFocus && self.config.ignoredFocusElements.indexOf(e.target) === -1) {
				self.close();

				if (self.config.mode === "range" && self.selectedDates.length === 1) {
					self.clear(false);
					self.redraw();
				}
			}
		}
	}

	function changeYear(newYear) {
		if (!newYear || self.currentYearElement.min && newYear < self.currentYearElement.min || self.currentYearElement.max && newYear > self.currentYearElement.max) return;

		var newYearNum = parseInt(newYear, 10),
		    isNewYear = self.currentYear !== newYearNum;

		self.currentYear = newYearNum || self.currentYear;

		if (self.config.maxDate && self.currentYear === self.config.maxDate.getFullYear()) {
			self.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth);
		} else if (self.config.minDate && self.currentYear === self.config.minDate.getFullYear()) {
			self.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth);
		}

		if (isNewYear) {
			self.redraw();
			triggerEvent("YearChange");
		}
	}

	function isEnabled(date, timeless) {
		if (self.config.minDate && compareDates(date, self.config.minDate, timeless !== undefined ? timeless : !self.minDateHasTime) < 0 || self.config.maxDate && compareDates(date, self.config.maxDate, timeless !== undefined ? timeless : !self.maxDateHasTime) > 0) return false;

		if (!self.config.enable.length && !self.config.disable.length) return true;

		var dateToCheck = self.parseDate(date, null, true); // timeless

		var bool = self.config.enable.length > 0,
		    array = bool ? self.config.enable : self.config.disable;

		for (var i = 0, d; i < array.length; i++) {
			d = array[i];

			if (d instanceof Function && d(dateToCheck)) // disabled by function
				return bool;else if (d instanceof Date && d.getTime() === dateToCheck.getTime())
				// disabled by date
				return bool;else if (typeof d === "string" && self.parseDate(d, null, true).getTime() === dateToCheck.getTime())
				// disabled by date string
				return bool;else if ( // disabled by range
			(typeof d === "undefined" ? "undefined" : _typeof(d)) === "object" && d.from && d.to && dateToCheck >= d.from && dateToCheck <= d.to) return bool;
		}

		return !bool;
	}

	function onKeyDown(e) {
		var isInput = e.target === self._input;
		var calendarElem = isCalendarElem(e.target);
		var allowInput = self.config.allowInput;
		var allowKeydown = self.isOpen && (!allowInput || !isInput);
		var allowInlineKeydown = self.config.inline && isInput && !allowInput;

		if (e.key === "Enter" && allowInput && isInput) {
			self.setDate(self._input.value, true, e.target === self.altInput ? self.config.altFormat : self.config.dateFormat);
			return e.target.blur();
		} else if (calendarElem || allowKeydown || allowInlineKeydown) {
			var isTimeObj = self.timeContainer && self.timeContainer.contains(e.target);
			switch (e.key) {
				case "Enter":
					if (isTimeObj) updateValue();else selectDate(e);

					break;

				case "Escape":
					// escape
					e.preventDefault();
					self.close();
					break;

				case "Backspace":
				case "Delete":
					if (!self.config.allowInput) self.clear();
					break;

				case "ArrowLeft":
				case "ArrowRight":
					if (!isTimeObj) {
						e.preventDefault();

						if (self.daysContainer) {
							var _delta = e.key === "ArrowRight" ? 1 : -1;

							if (!e.ctrlKey) focusOnDay(e.target.$i, _delta);else changeMonth(_delta, true);
						} else if (self.config.enableTime && !isTimeObj) self.hourElement.focus();
					}

					break;

				case "ArrowUp":
				case "ArrowDown":
					e.preventDefault();
					var delta = e.key === "ArrowDown" ? 1 : -1;

					if (self.daysContainer) {
						if (e.ctrlKey) {
							changeYear(self.currentYear - delta);
							focusOnDay(e.target.$i, 0);
						} else if (!isTimeObj) focusOnDay(e.target.$i, delta * 7);
					} else if (self.config.enableTime) {
						if (!isTimeObj) self.hourElement.focus();
						updateTime(e);
						self.debouncedChange();
					}

					break;

				case "Tab":
					if (e.target === self.hourElement) {
						e.preventDefault();
						self.minuteElement.select();
					} else if (e.target === self.minuteElement && (self.secondElement || self.amPM)) {
						e.preventDefault();
						(self.secondElement || self.amPM).focus();
					} else if (e.target === self.secondElement) {
						e.preventDefault();
						self.amPM.focus();
					}

					break;

				case "a":
					if (e.target === self.amPM) {
						self.amPM.textContent = "AM";
						setHoursFromInputs();
						updateValue();
					}
					break;

				case "p":
					if (e.target === self.amPM) {
						self.amPM.textContent = "PM";
						setHoursFromInputs();
						updateValue();
					}
					break;

				default:
					break;

			}

			triggerEvent("KeyDown", e);
		}
	}

	function onMouseOver(elem) {
		if (self.selectedDates.length !== 1 || !elem.classList.contains("flatpickr-day")) return;

		var hoverDate = elem.dateObj,
		    initialDate = self.parseDate(self.selectedDates[0], null, true),
		    rangeStartDate = Math.min(hoverDate.getTime(), self.selectedDates[0].getTime()),
		    rangeEndDate = Math.max(hoverDate.getTime(), self.selectedDates[0].getTime()),
		    containsDisabled = false;

		for (var t = rangeStartDate; t < rangeEndDate; t += self.utils.duration.DAY) {
			if (!isEnabled(new Date(t))) {
				containsDisabled = true;
				break;
			}
		}

		var _loop = function _loop(timestamp, i) {
			var outOfRange = timestamp < self.minRangeDate.getTime() || timestamp > self.maxRangeDate.getTime(),
			    dayElem = self.days.childNodes[i];

			if (outOfRange) {
				self.days.childNodes[i].classList.add("notAllowed");
				["inRange", "startRange", "endRange"].forEach(function (c) {
					dayElem.classList.remove(c);
				});
				return "continue";
			} else if (containsDisabled && !outOfRange) return "continue";

			["startRange", "inRange", "endRange", "notAllowed"].forEach(function (c) {
				dayElem.classList.remove(c);
			});

			var minRangeDate = Math.max(self.minRangeDate.getTime(), rangeStartDate),
			    maxRangeDate = Math.min(self.maxRangeDate.getTime(), rangeEndDate);

			elem.classList.add(hoverDate < self.selectedDates[0] ? "startRange" : "endRange");

			if (initialDate < hoverDate && timestamp === initialDate.getTime()) dayElem.classList.add("startRange");else if (initialDate > hoverDate && timestamp === initialDate.getTime()) dayElem.classList.add("endRange");

			if (timestamp >= minRangeDate && timestamp <= maxRangeDate) dayElem.classList.add("inRange");
		};

		for (var timestamp = self.days.childNodes[0].dateObj.getTime(), i = 0; i < 42; i++, timestamp += self.utils.duration.DAY) {
			var _ret = _loop(timestamp, i);

			if (_ret === "continue") continue;
		}
	}

	function onResize() {
		if (self.isOpen && !self.config.static && !self.config.inline) positionCalendar();
	}

	function open(e, positionElement) {
		if (self.isMobile) {
			if (e) {
				e.preventDefault();
				e.target.blur();
			}

			setTimeout(function () {
				self.mobileInput.click();
			}, 0);

			triggerEvent("Open");
			return;
		}

		if (self.isOpen || self._input.disabled || self.config.inline) return;

		self.isOpen = true;
		self.calendarContainer.classList.add("open");
		positionCalendar(positionElement);
		self._input.classList.add("active");

		triggerEvent("Open");
	}

	function minMaxDateSetter(type) {
		return function (date) {
			var dateObj = self.config["_" + type + "Date"] = self.parseDate(date);

			var inverseDateObj = self.config["_" + (type === "min" ? "max" : "min") + "Date"];
			var isValidDate = date && dateObj instanceof Date;

			if (isValidDate) {
				self[type + "DateHasTime"] = dateObj.getHours() || dateObj.getMinutes() || dateObj.getSeconds();
			}

			if (self.selectedDates) {
				self.selectedDates = self.selectedDates.filter(function (d) {
					return isEnabled(d);
				});
				if (!self.selectedDates.length && type === "min") setHoursFromDate(dateObj);
				updateValue();
			}

			if (self.daysContainer) {
				redraw();

				if (isValidDate) self.currentYearElement[type] = dateObj.getFullYear();else self.currentYearElement.removeAttribute(type);

				self.currentYearElement.disabled = inverseDateObj && dateObj && inverseDateObj.getFullYear() === dateObj.getFullYear();
			}
		};
	}

	function parseConfig() {
		var boolOpts = ["wrap", "weekNumbers", "allowInput", "clickOpens", "time_24hr", "enableTime", "noCalendar", "altInput", "shorthandCurrentMonth", "inline", "static", "enableSeconds", "disableMobile"];

		var hooks = ["onChange", "onClose", "onDayCreate", "onDestroy", "onKeyDown", "onMonthChange", "onOpen", "onParseConfig", "onReady", "onValueUpdate", "onYearChange"];

		self.config = Object.create(flatpickr.defaultConfig);

		var userConfig = _extends({}, self.instanceConfig, JSON.parse(JSON.stringify(self.element.dataset || {})));

		self.config.parseDate = userConfig.parseDate;
		self.config.formatDate = userConfig.formatDate;

		Object.defineProperty(self.config, "enable", {
			get: function get() {
				return self.config._enable || [];
			},
			set: function set(dates) {
				return self.config._enable = parseDateRules(dates);
			}
		});

		Object.defineProperty(self.config, "disable", {
			get: function get() {
				return self.config._disable || [];
			},
			set: function set(dates) {
				return self.config._disable = parseDateRules(dates);
			}
		});

		_extends(self.config, userConfig);

		if (!userConfig.dateFormat && userConfig.enableTime) {
			self.config.dateFormat = self.config.noCalendar ? "H:i" + (self.config.enableSeconds ? ":S" : "") : flatpickr.defaultConfig.dateFormat + " H:i" + (self.config.enableSeconds ? ":S" : "");
		}

		if (userConfig.altInput && userConfig.enableTime && !userConfig.altFormat) {
			self.config.altFormat = self.config.noCalendar ? "h:i" + (self.config.enableSeconds ? ":S K" : " K") : flatpickr.defaultConfig.altFormat + (" h:i" + (self.config.enableSeconds ? ":S" : "") + " K");
		}

		Object.defineProperty(self.config, "minDate", {
			get: function get() {
				return this._minDate;
			},
			set: minMaxDateSetter("min")
		});

		Object.defineProperty(self.config, "maxDate", {
			get: function get() {
				return this._maxDate;
			},
			set: minMaxDateSetter("max")
		});

		self.config.minDate = userConfig.minDate;
		self.config.maxDate = userConfig.maxDate;

		for (var i = 0; i < boolOpts.length; i++) {
			self.config[boolOpts[i]] = self.config[boolOpts[i]] === true || self.config[boolOpts[i]] === "true";
		}for (var _i = hooks.length; _i--;) {
			if (self.config[hooks[_i]] !== undefined) {
				self.config[hooks[_i]] = arrayify(self.config[hooks[_i]] || []).map(bindToInstance);
			}
		}

		for (var _i2 = 0; _i2 < self.config.plugins.length; _i2++) {
			var pluginConf = self.config.plugins[_i2](self) || {};
			for (var key in pluginConf) {

				if (self.config[key] instanceof Array || ~hooks.indexOf(key)) {
					self.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self.config[key]);
				} else if (typeof userConfig[key] === "undefined") self.config[key] = pluginConf[key];
			}
		}

		triggerEvent("ParseConfig");
	}

	function setupLocale() {
		if (_typeof(self.config.locale) !== "object" && typeof flatpickr.l10ns[self.config.locale] === "undefined") console.warn("flatpickr: invalid locale " + self.config.locale);

		self.l10n = _extends(Object.create(flatpickr.l10ns.default), _typeof(self.config.locale) === "object" ? self.config.locale : self.config.locale !== "default" ? flatpickr.l10ns[self.config.locale] || {} : {});
	}

	function positionCalendar() {
		var positionElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : self._positionElement;

		if (self.calendarContainer === undefined) return;

		var calendarHeight = self.calendarContainer.offsetHeight,
		    calendarWidth = self.calendarContainer.offsetWidth,
		    configPos = self.config.position,
		    inputBounds = positionElement.getBoundingClientRect(),
		    distanceFromBottom = window.innerHeight - inputBounds.bottom,
		    showOnTop = configPos === "above" || configPos !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;

		var top = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);

		toggleClass(self.calendarContainer, "arrowTop", !showOnTop);
		toggleClass(self.calendarContainer, "arrowBottom", showOnTop);

		if (self.config.inline) return;

		var left = window.pageXOffset + inputBounds.left;
		var right = window.document.body.offsetWidth - inputBounds.right;
		var rightMost = left + calendarWidth > window.document.body.offsetWidth;

		toggleClass(self.calendarContainer, "rightMost", rightMost);

		if (self.config.static) return;

		self.calendarContainer.style.top = top + "px";

		if (!rightMost) {
			self.calendarContainer.style.left = left + "px";
			self.calendarContainer.style.right = "auto";
		} else {
			self.calendarContainer.style.left = "auto";
			self.calendarContainer.style.right = right + "px";
		}
	}

	function redraw() {
		if (self.config.noCalendar || self.isMobile) return;

		buildWeekdays();
		updateNavigationCurrentMonth();
		buildDays();
	}

	function selectDate(e) {
		e.preventDefault();
		e.stopPropagation();

		if (!e.target.classList.contains("flatpickr-day") || e.target.classList.contains("disabled") || e.target.classList.contains("notAllowed")) return;

		var selectedDate = self.latestSelectedDateObj = new Date(e.target.dateObj.getTime());

		var shouldChangeMonth = selectedDate.getMonth() !== self.currentMonth && self.config.mode !== "range";

		self.selectedDateElem = e.target;

		if (self.config.mode === "single") self.selectedDates = [selectedDate];else if (self.config.mode === "multiple") {
			var selectedIndex = isDateSelected(selectedDate);
			if (selectedIndex) self.selectedDates.splice(selectedIndex, 1);else self.selectedDates.push(selectedDate);
		} else if (self.config.mode === "range") {
			if (self.selectedDates.length === 2) self.clear();

			self.selectedDates.push(selectedDate);

			// unless selecting same date twice, sort ascendingly
			if (compareDates(selectedDate, self.selectedDates[0], true) !== 0) self.selectedDates.sort(function (a, b) {
				return a.getTime() - b.getTime();
			});
		}

		setHoursFromInputs();

		if (shouldChangeMonth) {
			var isNewYear = self.currentYear !== selectedDate.getFullYear();
			self.currentYear = selectedDate.getFullYear();
			self.currentMonth = selectedDate.getMonth();

			if (isNewYear) triggerEvent("YearChange");

			triggerEvent("MonthChange");
		}

		buildDays();

		if (self.minDateHasTime && self.config.enableTime && compareDates(selectedDate, self.config.minDate) === 0) setHoursFromDate(self.config.minDate);

		updateValue();

		if (self.config.enableTime) setTimeout(function () {
			return self.showTimeInput = true;
		}, 50);

		if (self.config.mode === "range") {
			if (self.selectedDates.length === 1) {
				onMouseOver(e.target);

				self._hidePrevMonthArrow = self._hidePrevMonthArrow || self.minRangeDate > self.days.childNodes[0].dateObj;

				self._hideNextMonthArrow = self._hideNextMonthArrow || self.maxRangeDate < new Date(self.currentYear, self.currentMonth + 1, 1);
			} else updateNavigationCurrentMonth();
		}

		triggerEvent("Change");

		// maintain focus
		if (!shouldChangeMonth) focusOnDay(e.target.$i, 0);else afterDayAnim(function () {
			return self.selectedDateElem && self.selectedDateElem.focus();
		});

		if (self.config.enableTime) setTimeout(function () {
			return self.hourElement.select();
		}, 451);

		if (self.config.closeOnSelect) {
			var single = self.config.mode === "single" && !self.config.enableTime;
			var range = self.config.mode === "range" && self.selectedDates.length === 2 && !self.config.enableTime;

			if (single || range) self.close();
		}
	}

	function set(option, value) {
		if (option !== null && (typeof option === "undefined" ? "undefined" : _typeof(option)) === "object") _extends(self.config, option);else self.config[option] = value;

		self.redraw();
		jumpToDate();
	}

	function setSelectedDate(inputDate, format) {
		if (inputDate instanceof Array) self.selectedDates = inputDate.map(function (d) {
			return self.parseDate(d, format);
		});else if (inputDate instanceof Date || !isNaN(inputDate)) self.selectedDates = [self.parseDate(inputDate, format)];else if (inputDate && inputDate.substring) {
			switch (self.config.mode) {
				case "single":
					self.selectedDates = [self.parseDate(inputDate, format)];
					break;

				case "multiple":
					self.selectedDates = inputDate.split("; ").map(function (date) {
						return self.parseDate(date, format);
					});
					break;

				case "range":
					self.selectedDates = inputDate.split(self.l10n.rangeSeparator).map(function (date) {
						return self.parseDate(date, format);
					});

					break;

				default:
					break;
			}
		}

		self.selectedDates = self.selectedDates.filter(function (d) {
			return d instanceof Date && isEnabled(d, false);
		});

		self.selectedDates.sort(function (a, b) {
			return a.getTime() - b.getTime();
		});
	}

	function setDate(date, triggerChange, format) {
		if (date !== 0 && !date) return self.clear(triggerChange);

		setSelectedDate(date, format);

		self.showTimeInput = self.selectedDates.length > 0;
		self.latestSelectedDateObj = self.selectedDates[0];

		self.redraw();
		jumpToDate();

		setHoursFromDate();
		updateValue(triggerChange);

		if (triggerChange) triggerEvent("Change");
	}

	function parseDateRules(arr) {
		for (var i = arr.length; i--;) {
			if (typeof arr[i] === "string" || +arr[i]) arr[i] = self.parseDate(arr[i], null, true);else if (arr[i] && arr[i].from && arr[i].to) {
				arr[i].from = self.parseDate(arr[i].from);
				arr[i].to = self.parseDate(arr[i].to);
			}
		}

		return arr.filter(function (x) {
			return x;
		}); // remove falsy values
	}

	function setupDates() {
		self.selectedDates = [];
		self.now = new Date();

		var preloadedDate = self.config.defaultDate || self.input.value;
		if (preloadedDate) setSelectedDate(preloadedDate, self.config.dateFormat);

		var initialDate = self.selectedDates.length ? self.selectedDates[0] : self.config.minDate && self.config.minDate.getTime() > self.now ? self.config.minDate : self.config.maxDate && self.config.maxDate.getTime() < self.now ? self.config.maxDate : self.now;

		self.currentYear = initialDate.getFullYear();
		self.currentMonth = initialDate.getMonth();

		if (self.selectedDates.length) self.latestSelectedDateObj = self.selectedDates[0];

		self.minDateHasTime = self.config.minDate && (self.config.minDate.getHours() || self.config.minDate.getMinutes() || self.config.minDate.getSeconds());

		self.maxDateHasTime = self.config.maxDate && (self.config.maxDate.getHours() || self.config.maxDate.getMinutes() || self.config.maxDate.getSeconds());

		Object.defineProperty(self, "latestSelectedDateObj", {
			get: function get() {
				return self._selectedDateObj || self.selectedDates[self.selectedDates.length - 1];
			},
			set: function set(date) {
				self._selectedDateObj = date;
			}
		});

		if (!self.isMobile) {
			Object.defineProperty(self, "showTimeInput", {
				get: function get() {
					return self._showTimeInput;
				},
				set: function set(bool) {
					self._showTimeInput = bool;
					if (self.calendarContainer) toggleClass(self.calendarContainer, "showTimeInput", bool);
					positionCalendar();
				}
			});
		}
	}

	function setupHelperFunctions() {
		self.utils = {
			duration: {
				DAY: 86400000
			},
			getDaysinMonth: function getDaysinMonth(month, yr) {
				month = typeof month === "undefined" ? self.currentMonth : month;

				yr = typeof yr === "undefined" ? self.currentYear : yr;

				if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0)) return 29;

				return self.l10n.daysInMonth[month];
			},
			monthToStr: function monthToStr(monthNumber, shorthand) {
				shorthand = typeof shorthand === "undefined" ? self.config.shorthandCurrentMonth : shorthand;

				return self.l10n.months[(shorthand ? "short" : "long") + "hand"][monthNumber];
			}
		};
	}

	/* istanbul ignore next */
	function setupFormats() {
		self.formats = Object.create(FlatpickrInstance.prototype.formats);
		["D", "F", "J", "M", "W", "l"].forEach(function (f) {
			self.formats[f] = FlatpickrInstance.prototype.formats[f].bind(self);
		});

		self.revFormat.F = FlatpickrInstance.prototype.revFormat.F.bind(self);
		self.revFormat.M = FlatpickrInstance.prototype.revFormat.M.bind(self);
	}

	function setupInputs() {
		self.input = self.config.wrap ? self.element.querySelector("[data-input]") : self.element;

		/* istanbul ignore next */
		if (!self.input) return console.warn("Error: invalid input element specified", self.input);

		self.input._type = self.input.type;
		self.input.type = "text";

		self.input.classList.add("flatpickr-input");
		self._input = self.input;

		if (self.config.altInput) {
			// replicate self.element
			self.altInput = createElement(self.input.nodeName, self.input.className + " " + self.config.altInputClass);
			self._input = self.altInput;
			self.altInput.placeholder = self.input.placeholder;
			self.altInput.disabled = self.input.disabled;
			self.altInput.required = self.input.required;
			self.altInput.type = "text";
			self.input.type = "hidden";

			if (!self.config.static && self.input.parentNode) self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);
		}

		if (!self.config.allowInput) self._input.setAttribute("readonly", "readonly");

		self._positionElement = self.config.positionElement || self._input;
	}

	function setupMobile() {
		var inputType = self.config.enableTime ? self.config.noCalendar ? "time" : "datetime-local" : "date";

		self.mobileInput = createElement("input", self.input.className + " flatpickr-mobile");
		self.mobileInput.step = self.input.getAttribute("step") || "any";
		self.mobileInput.tabIndex = 1;
		self.mobileInput.type = inputType;
		self.mobileInput.disabled = self.input.disabled;
		self.mobileInput.placeholder = self.input.placeholder;

		self.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";

		if (self.selectedDates.length) {
			self.mobileInput.defaultValue = self.mobileInput.value = self.formatDate(self.selectedDates[0], self.mobileFormatStr);
		}

		if (self.config.minDate) self.mobileInput.min = self.formatDate(self.config.minDate, "Y-m-d");

		if (self.config.maxDate) self.mobileInput.max = self.formatDate(self.config.maxDate, "Y-m-d");

		self.input.type = "hidden";
		if (self.config.altInput) self.altInput.type = "hidden";

		try {
			self.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);
		} catch (e) {
			//
		}

		self.mobileInput.addEventListener("change", function (e) {
			self.setDate(e.target.value, false, self.mobileFormatStr);
			triggerEvent("Change");
			triggerEvent("Close");
		});
	}

	function toggle() {
		if (self.isOpen) return self.close();
		self.open();
	}

	function triggerEvent(event, data) {
		var hooks = self.config["on" + event];

		if (hooks !== undefined && hooks.length > 0) {
			for (var i = 0; hooks[i] && i < hooks.length; i++) {
				hooks[i](self.selectedDates, self.input.value, self, data);
			}
		}

		if (event === "Change") {
			self.input.dispatchEvent(createEvent("change"));

			// many front-end frameworks bind to the input event
			self.input.dispatchEvent(createEvent("input"));
		}
	}

	/**
  * Creates an Event, normalized across browsers
  * @param {String} name the event name, e.g. "click"
  * @return {Event} the created event
  */
	function createEvent(name) {
		if (self._supportsEvents) return new Event(name, { bubbles: true });

		self._[name + "Event"] = document.createEvent("Event");
		self._[name + "Event"].initEvent(name, true, true);
		return self._[name + "Event"];
	}

	function isDateSelected(date) {
		for (var i = 0; i < self.selectedDates.length; i++) {
			if (compareDates(self.selectedDates[i], date) === 0) return "" + i;
		}

		return false;
	}

	function isDateInRange(date) {
		if (self.config.mode !== "range" || self.selectedDates.length < 2) return false;
		return compareDates(date, self.selectedDates[0]) >= 0 && compareDates(date, self.selectedDates[1]) <= 0;
	}

	function updateNavigationCurrentMonth() {
		if (self.config.noCalendar || self.isMobile || !self.monthNav) return;

		self.currentMonthElement.textContent = self.utils.monthToStr(self.currentMonth) + " ";
		self.currentYearElement.value = self.currentYear;

		self._hidePrevMonthArrow = self.config.minDate && (self.currentYear === self.config.minDate.getFullYear() ? self.currentMonth <= self.config.minDate.getMonth() : self.currentYear < self.config.minDate.getFullYear());

		self._hideNextMonthArrow = self.config.maxDate && (self.currentYear === self.config.maxDate.getFullYear() ? self.currentMonth + 1 > self.config.maxDate.getMonth() : self.currentYear > self.config.maxDate.getFullYear());
	}

	/**
  * Updates the values of inputs associated with the calendar
  * @return {void}
  */
	function updateValue(triggerChange) {
		if (!self.selectedDates.length) return self.clear(triggerChange);

		if (self.isMobile) {
			self.mobileInput.value = self.selectedDates.length ? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr) : "";
		}

		var joinChar = self.config.mode !== "range" ? "; " : self.l10n.rangeSeparator;

		self.input.value = self.selectedDates.map(function (dObj) {
			return self.formatDate(dObj, self.config.dateFormat);
		}).join(joinChar);

		if (self.config.altInput) {
			self.altInput.value = self.selectedDates.map(function (dObj) {
				return self.formatDate(dObj, self.config.altFormat);
			}).join(joinChar);
		}

		if (triggerChange !== false) triggerEvent("ValueUpdate");
	}

	function mouseDelta(e) {
		return Math.max(-1, Math.min(1, e.wheelDelta || -e.deltaY));
	}

	function onMonthNavScroll(e) {
		e.preventDefault();
		var isYear = self.currentYearElement.parentNode.contains(e.target);

		if (e.target === self.currentMonthElement || isYear) {

			var delta = mouseDelta(e);

			if (isYear) {
				changeYear(self.currentYear + delta);
				e.target.value = self.currentYear;
			} else self.changeMonth(delta, true, false);
		}
	}

	function onMonthNavClick(e) {
		var isPrevMonth = self.prevMonthNav.contains(e.target);
		var isNextMonth = self.nextMonthNav.contains(e.target);

		if (isPrevMonth || isNextMonth) changeMonth(isPrevMonth ? -1 : 1);else if (e.target === self.currentYearElement) {
			e.preventDefault();
			self.currentYearElement.select();
		} else if (e.target.className === "arrowUp") self.changeYear(self.currentYear + 1);else if (e.target.className === "arrowDown") self.changeYear(self.currentYear - 1);
	}

	/**
  * Creates an HTMLElement with given tag, class, and textual content
  * @param {String} tag the HTML tag
  * @param {String} className the new element's class name
  * @param {String} content The new element's text content
  * @return {HTMLElement} the created HTML element
  */
	function createElement(tag, className, content) {
		var e = window.document.createElement(tag);
		className = className || "";
		content = content || "";

		e.className = className;

		if (content !== undefined) e.textContent = content;

		return e;
	}

	function arrayify(obj) {
		if (obj instanceof Array) return obj;
		return [obj];
	}

	function toggleClass(elem, className, bool) {
		if (bool) return elem.classList.add(className);
		elem.classList.remove(className);
	}

	/* istanbul ignore next */
	function debounce(func, wait, immediate) {
		var timeout = void 0;
		return function () {
			var context = this,
			    args = arguments;
			clearTimeout(timeout);
			timeout = setTimeout(function () {
				timeout = null;
				if (!immediate) func.apply(context, args);
			}, wait);
			if (immediate && !timeout) func.apply(context, args);
		};
	}

	/**
  * Compute the difference in dates, measured in ms
  * @param {Date} date1
  * @param {Date} date2
  * @param {Boolean} timeless whether to reset times of both dates to 00:00
  * @return {Number} the difference in ms
  */
	function compareDates(date1, date2, timeless) {
		if (!(date1 instanceof Date) || !(date2 instanceof Date)) return false;

		if (timeless !== false) {
			return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
		}

		return date1.getTime() - date2.getTime();
	}

	function timeWrapper(e) {
		e.preventDefault();

		var isKeyDown = e.type === "keydown",
		    isWheel = e.type === "wheel",
		    isIncrement = e.type === "increment",
		    input = e.target;

		if (self.amPM && e.target === self.amPM) return e.target.textContent = ["AM", "PM"][e.target.textContent === "AM" | 0];

		var min = Number(input.min),
		    max = Number(input.max),
		    step = Number(input.step),
		    curValue = parseInt(input.value, 10),
		    delta = e.delta || (!isKeyDown ? Math.max(-1, Math.min(1, e.wheelDelta || -e.deltaY)) || 0 : e.which === 38 ? 1 : -1);

		var newValue = curValue + step * delta;

		if (typeof input.value !== "undefined" && input.value.length === 2) {
			var isHourElem = input === self.hourElement,
			    isMinuteElem = input === self.minuteElement;

			if (newValue < min) {
				newValue = max + newValue + !isHourElem + (isHourElem && !self.amPM);

				if (isMinuteElem) incrementNumInput(null, -1, self.hourElement);
			} else if (newValue > max) {
				newValue = input === self.hourElement ? newValue - max - !self.amPM : min;

				if (isMinuteElem) incrementNumInput(null, 1, self.hourElement);
			}

			if (self.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) self.amPM.textContent = self.amPM.textContent === "PM" ? "AM" : "PM";

			input.value = self.pad(newValue);
		}
	}

	init();
	return self;
}

FlatpickrInstance.prototype = {
	formats: {
		// get the date in UTC
		Z: function Z(date) {
			return date.toISOString();
		},

		// weekday name, short, e.g. Thu
		D: function D(date) {
			return this.l10n.weekdays.shorthand[this.formats.w(date)];
		},

		// full month name e.g. January
		F: function F(date) {
			return this.utils.monthToStr(this.formats.n(date) - 1, false);
		},

		// padded hour 1-12
		G: function G(date) {
			return FlatpickrInstance.prototype.pad(FlatpickrInstance.prototype.formats.h(date));
		},

		// hours with leading zero e.g. 03
		H: function H(date) {
			return FlatpickrInstance.prototype.pad(date.getHours());
		},

		// day (1-30) with ordinal suffix e.g. 1st, 2nd
		J: function J(date) {
			return date.getDate() + this.l10n.ordinal(date.getDate());
		},

		// AM/PM
		K: function K(date) {
			return date.getHours() > 11 ? "PM" : "AM";
		},

		// shorthand month e.g. Jan, Sep, Oct, etc
		M: function M(date) {
			return this.utils.monthToStr(date.getMonth(), true);
		},

		// seconds 00-59
		S: function S(date) {
			return FlatpickrInstance.prototype.pad(date.getSeconds());
		},

		// unix timestamp
		U: function U(date) {
			return date.getTime() / 1000;
		},

		W: function W(date) {
			return this.config.getWeek(date);
		},

		// full year e.g. 2016
		Y: function Y(date) {
			return date.getFullYear();
		},

		// day in month, padded (01-30)
		d: function d(date) {
			return FlatpickrInstance.prototype.pad(date.getDate());
		},

		// hour from 1-12 (am/pm)
		h: function h(date) {
			return date.getHours() % 12 ? date.getHours() % 12 : 12;
		},

		// minutes, padded with leading zero e.g. 09
		i: function i(date) {
			return FlatpickrInstance.prototype.pad(date.getMinutes());
		},

		// day in month (1-30)
		j: function j(date) {
			return date.getDate();
		},

		// weekday name, full, e.g. Thursday
		l: function l(date) {
			return this.l10n.weekdays.longhand[date.getDay()];
		},

		// padded month number (01-12)
		m: function m(date) {
			return FlatpickrInstance.prototype.pad(date.getMonth() + 1);
		},

		// the month number (1-12)
		n: function n(date) {
			return date.getMonth() + 1;
		},

		// seconds 0-59
		s: function s(date) {
			return date.getSeconds();
		},

		// number of the day of the week
		w: function w(date) {
			return date.getDay();
		},

		// last two digits of year e.g. 16 for 2016
		y: function y(date) {
			return String(date.getFullYear()).substring(2);
		}
	},

	/**
  * Formats a given Date object into a string based on supplied format
  * @param {Date} dateObj the date object
  * @param {String} frmt a string composed of formatting tokens e.g. "Y-m-d"
  * @return {String} The textual representation of the date e.g. 2017-02-03
  */
	formatDate: function formatDate(dateObj, frmt) {
		var _this = this;

		if (this.config !== undefined && this.config.formatDate !== undefined) return this.config.formatDate(dateObj, frmt);

		return frmt.split("").map(function (c, i, arr) {
			return _this.formats[c] && arr[i - 1] !== "\\" ? _this.formats[c](dateObj) : c !== "\\" ? c : "";
		}).join("");
	},


	revFormat: {
		D: function D() {},
		F: function F(dateObj, monthName) {
			dateObj.setMonth(this.l10n.months.longhand.indexOf(monthName));
		},
		G: function G(dateObj, hour) {
			dateObj.setHours(parseFloat(hour));
		},
		H: function H(dateObj, hour) {
			dateObj.setHours(parseFloat(hour));
		},
		J: function J(dateObj, day) {
			dateObj.setDate(parseFloat(day));
		},
		K: function K(dateObj, amPM) {
			var hours = dateObj.getHours();

			if (hours !== 12) dateObj.setHours(hours % 12 + 12 * /pm/i.test(amPM));
		},
		M: function M(dateObj, shortMonth) {
			dateObj.setMonth(this.l10n.months.shorthand.indexOf(shortMonth));
		},
		S: function S(dateObj, seconds) {
			dateObj.setSeconds(seconds);
		},
		U: function U(dateObj, unixSeconds) {
			return new Date(parseFloat(unixSeconds) * 1000);
		},

		W: function W(dateObj, weekNumber) {
			weekNumber = parseInt(weekNumber);
			return new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0, 0);
		},
		Y: function Y(dateObj, year) {
			dateObj.setFullYear(year);
		},
		Z: function Z(dateObj, ISODate) {
			return new Date(ISODate);
		},

		d: function d(dateObj, day) {
			dateObj.setDate(parseFloat(day));
		},
		h: function h(dateObj, hour) {
			dateObj.setHours(parseFloat(hour));
		},
		i: function i(dateObj, minutes) {
			dateObj.setMinutes(parseFloat(minutes));
		},
		j: function j(dateObj, day) {
			dateObj.setDate(parseFloat(day));
		},
		l: function l() {},
		m: function m(dateObj, month) {
			dateObj.setMonth(parseFloat(month) - 1);
		},
		n: function n(dateObj, month) {
			dateObj.setMonth(parseFloat(month) - 1);
		},
		s: function s(dateObj, seconds) {
			dateObj.setSeconds(parseFloat(seconds));
		},
		w: function w() {},
		y: function y(dateObj, year) {
			dateObj.setFullYear(2000 + parseFloat(year));
		}
	},

	tokenRegex: {
		D: "(\\w+)",
		F: "(\\w+)",
		G: "(\\d\\d|\\d)",
		H: "(\\d\\d|\\d)",
		J: "(\\d\\d|\\d)\\w+",
		K: "(am|AM|Am|aM|pm|PM|Pm|pM)",
		M: "(\\w+)",
		S: "(\\d\\d|\\d)",
		U: "(.+)",
		W: "(\\d\\d|\\d)",
		Y: "(\\d{4})",
		Z: "(.+)",
		d: "(\\d\\d|\\d)",
		h: "(\\d\\d|\\d)",
		i: "(\\d\\d|\\d)",
		j: "(\\d\\d|\\d)",
		l: "(\\w+)",
		m: "(\\d\\d|\\d)",
		n: "(\\d\\d|\\d)",
		s: "(\\d\\d|\\d)",
		w: "(\\d\\d|\\d)",
		y: "(\\d{2})"
	},

	pad: function pad(number) {
		return ("0" + number).slice(-2);
	},

	/**
  * Parses a date(+time) string into a Date object
  * @param {String} date the date string, e.g. 2017-02-03 14:45
  * @param {String} givenFormat the date format, e.g. Y-m-d H:i
  * @param {Boolean} timeless whether to reset the time of Date object
  * @return {Date} the parsed Date object
  */
	parseDate: function parseDate(date, givenFormat, timeless) {
		var _this2 = this;

		if (date !== 0 && !date) return null;

		var date_orig = date;

		if (date instanceof Date) date = new Date(date.getTime()); // create a copy

		else if (date.toFixed !== undefined) // timestamp
				date = new Date(date);else {
				// date string
				var format = givenFormat || (this.config || flatpickr.defaultConfig).dateFormat;
				date = String(date).trim();

				if (date === "today") {
					date = new Date();
					timeless = true;
				} else if (/Z$/.test(date) || /GMT$/.test(date)) // datestrings w/ timezone
					date = new Date(date);else if (this.config && this.config.parseDate) date = this.config.parseDate(date, format);else {
					(function () {
						var parsedDate = !_this2.config || !_this2.config.noCalendar ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0) : new Date(new Date().setHours(0, 0, 0, 0));

						var matched = void 0,
						    ops = [];

						for (var i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {
							var token = format[i];
							var isBackSlash = token === "\\";
							var escaped = format[i - 1] === "\\" || isBackSlash;

							if (_this2.tokenRegex[token] && !escaped) {
								regexStr += _this2.tokenRegex[token];
								var match = new RegExp(regexStr).exec(date);
								if (match && (matched = true)) {
									ops[token !== "Y" ? "push" : "unshift"]({
										fn: _this2.revFormat[token],
										val: match[++matchIndex]
									});
								}
							} else if (!isBackSlash) regexStr += "."; // don't really care

							ops.forEach(function (_ref) {
								var fn = _ref.fn,
								    val = _ref.val;
								return parsedDate = fn(parsedDate, val) || parsedDate;
							});
						}

						date = matched ? parsedDate : null;
					})();
				}
			}

		/* istanbul ignore next */
		if (!(date instanceof Date)) {
			console.warn("flatpickr: invalid date " + date_orig);
			console.info(this.element);
			return null;
		}

		if (timeless === true) date.setHours(0, 0, 0, 0);

		return date;
	}
};

/* istanbul ignore next */
function _flatpickr(nodeList, config) {
	var nodes = Array.prototype.slice.call(nodeList); // static list
	var instances = [];
	for (var i = 0; i < nodes.length; i++) {
		try {
			if (nodes[i].getAttribute("data-fp-omit") !== null) continue;

			if (nodes[i]._flatpickr) {
				nodes[i]._flatpickr.destroy();
				nodes[i]._flatpickr = null;
			}

			nodes[i]._flatpickr = new FlatpickrInstance(nodes[i], config || {});
			instances.push(nodes[i]._flatpickr);
		} catch (e) {
			console.warn(e, e.stack);
		}
	}

	return instances.length === 1 ? instances[0] : instances;
}

/* istanbul ignore next */
if (typeof HTMLElement !== "undefined") {
	// browser env
	HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function (config) {
		return _flatpickr(this, config);
	};

	HTMLElement.prototype.flatpickr = function (config) {
		return _flatpickr([this], config);
	};
}

/* istanbul ignore next */
function flatpickr(selector, config) {
	if (selector instanceof NodeList) return _flatpickr(selector, config);else if (!(selector instanceof HTMLElement)) return _flatpickr(window.document.querySelectorAll(selector), config);

	return _flatpickr([selector], config);
}

/* istanbul ignore next */
flatpickr.defaultConfig = FlatpickrInstance.defaultConfig = {
	mode: "single",

	position: "auto",

	animate: typeof window !== "undefined" && window.navigator.userAgent.indexOf("MSIE") === -1,

	// wrap: see https://chmln.github.io/flatpickr/examples/#flatpickr-external-elements
	wrap: false,

	// enables week numbers
	weekNumbers: false,

	// allow manual datetime input
	allowInput: false,

	/*
 	clicking on input opens the date(time)picker.
 	disable if you wish to open the calendar manually with .open()
 */
	clickOpens: true,

	/*
 	closes calendar after date selection,
 	unless 'mode' is 'multiple' or enableTime is true
 */
	closeOnSelect: true,

	// display time picker in 24 hour mode
	time_24hr: false,

	// enables the time picker functionality
	enableTime: false,

	// noCalendar: true will hide the calendar. use for a time picker along w/ enableTime
	noCalendar: false,

	// more date format chars at https://chmln.github.io/flatpickr/#dateformat
	dateFormat: "Y-m-d",

	// date format used in aria-label for days
	ariaDateFormat: "F j, Y",

	// altInput - see https://chmln.github.io/flatpickr/#altinput
	altInput: false,

	// the created altInput element will have this class.
	altInputClass: "form-control input",

	// same as dateFormat, but for altInput
	altFormat: "F j, Y", // defaults to e.g. June 10, 2016

	// defaultDate - either a datestring or a date object. used for datetimepicker"s initial value
	defaultDate: null,

	// the minimum date that user can pick (inclusive)
	minDate: null,

	// the maximum date that user can pick (inclusive)
	maxDate: null,

	// dateparser that transforms a given string to a date object
	parseDate: null,

	// dateformatter that transforms a given date object to a string, according to passed format
	formatDate: null,

	getWeek: function getWeek(givenDate) {
		var date = new Date(givenDate.getTime());
		var onejan = new Date(date.getFullYear(), 0, 1);
		return Math.ceil(((date - onejan) / 86400000 + onejan.getDay() + 1) / 7);
	},


	// see https://chmln.github.io/flatpickr/#disable
	enable: [],

	// see https://chmln.github.io/flatpickr/#disable
	disable: [],

	// display the short version of month names - e.g. Sep instead of September
	shorthandCurrentMonth: false,

	// displays calendar inline. see https://chmln.github.io/flatpickr/#inline-calendar
	inline: false,

	// position calendar inside wrapper and next to the input element
	// leave at false unless you know what you"re doing
	"static": false,

	// DOM node to append the calendar to in *static* mode
	appendTo: null,

	// code for previous/next icons. this is where you put your custom icon code e.g. fontawesome
	prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
	nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",

	// enables seconds in the time picker
	enableSeconds: false,

	// step size used when scrolling/incrementing the hour element
	hourIncrement: 1,

	// step size used when scrolling/incrementing the minute element
	minuteIncrement: 5,

	// initial value in the hour element
	defaultHour: 12,

	// initial value in the minute element
	defaultMinute: 0,

	// initial value in the seconds element
	defaultSeconds: 0,

	// disable native mobile datetime input support
	disableMobile: false,

	// default locale
	locale: "default",

	plugins: [],

	ignoredFocusElements: [],

	// called every time calendar is closed
	onClose: undefined, // function (dateObj, dateStr) {}

	// onChange callback when user selects a date or time
	onChange: undefined, // function (dateObj, dateStr) {}

	// called for every day element
	onDayCreate: undefined,

	// called every time the month is changed
	onMonthChange: undefined,

	// called every time calendar is opened
	onOpen: undefined, // function (dateObj, dateStr) {}

	// called after the configuration has been parsed
	onParseConfig: undefined,

	// called after calendar is ready
	onReady: undefined, // function (dateObj, dateStr) {}

	// called after input value updated
	onValueUpdate: undefined,

	// called every time the year is changed
	onYearChange: undefined,

	onKeyDown: undefined,

	onDestroy: undefined
};

/* istanbul ignore next */
flatpickr.l10ns = {
	en: {
		weekdays: {
			shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
			longhand: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
		},
		months: {
			shorthand: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
			longhand: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
		},
		daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
		firstDayOfWeek: 0,
		ordinal: function ordinal(nth) {
			var s = nth % 100;
			if (s > 3 && s < 21) return "th";
			switch (s % 10) {
				case 1:
					return "st";
				case 2:
					return "nd";
				case 3:
					return "rd";
				default:
					return "th";
			}
		},
		rangeSeparator: " to ",
		weekAbbreviation: "Wk",
		scrollTitle: "Scroll to increment",
		toggleTitle: "Click to toggle"
	}
};

flatpickr.l10ns.default = Object.create(flatpickr.l10ns.en);
flatpickr.localize = function (l10n) {
	return _extends(flatpickr.l10ns.default, l10n || {});
};
flatpickr.setDefaults = function (config) {
	return _extends(flatpickr.defaultConfig, config || {});
};

/* istanbul ignore next */
if (typeof jQuery !== "undefined") {
	jQuery.fn.flatpickr = function (config) {
		return _flatpickr(this, config);
	};
}

Date.prototype.fp_incr = function (days) {
	return new Date(this.getFullYear(), this.getMonth(), this.getDate() + parseInt(days, 10));
};

if (true) module.exports = flatpickr;

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

/* Slovak locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.sk = {};

flatpickr.l10ns.sk.weekdays = {
	shorthand: ["Ned", "Pon", "Ut", "Str", "tv", "Pia", "Sob"],
	longhand: ["Nedea", "Pondelok", "Utorok", "Streda", "tvrtok", "Piatok", "Sobota"]
};

flatpickr.l10ns.sk.months = {
	shorthand: ["Jan", "Feb", "Mar", "Apr", "Mj", "Jn", "Jl", "Aug", "Sep", "Okt", "Nov", "Dec"],
	longhand: ["Janur", "Februr", "Marec", "Aprl", "Mj", "Jn", "Jl", "August", "September", "Oktber", "November", "December"]
};

flatpickr.l10ns.sk.firstDayOfWeek = 1;
flatpickr.l10ns.sk.rangeSeparator = " do ";
flatpickr.l10ns.sk.ordinal = function () {
	return ".";
};

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

var ar = __webpack_require__(117)["ar"];
var bg = __webpack_require__(118)["bg"];
var bn = __webpack_require__(119)["bn"];
var cat = __webpack_require__(120)["cat"];
var cs = __webpack_require__(121)["cs"];
var cy = __webpack_require__(122)["cy"];
var da = __webpack_require__(123)["da"];
var de = __webpack_require__(124)["de"];
var eo = __webpack_require__(125)["eo"];
var es = __webpack_require__(126)["es"];
var et = __webpack_require__(127)["et"];
var fa = __webpack_require__(128)["fa"];
var fi = __webpack_require__(129)["fi"];
var fr = __webpack_require__(130)["fr"];
var gr = __webpack_require__(131)["gr"];
var he = __webpack_require__(132)["he"];
var hi = __webpack_require__(133)["hi"];
var hr = __webpack_require__(134)["hr"];
var hu = __webpack_require__(135)["hu"];
var id = __webpack_require__(136)["id"];
var it = __webpack_require__(137)["it"];
var ja = __webpack_require__(138)["ja"];
var ko = __webpack_require__(139)["ko"];
var lt = __webpack_require__(140)["lt"];
var lv = __webpack_require__(141)["lv"];
var mk = __webpack_require__(142)["mk"];
var ms = __webpack_require__(143)["ms"];
var my = __webpack_require__(144)["my"];
var nl = __webpack_require__(145)["nl"];
var no = __webpack_require__(146)["no"];
var pa = __webpack_require__(147)["pa"];
var pl = __webpack_require__(148)["pl"];
var pt = __webpack_require__(149)["pt"];
var ro = __webpack_require__(150)["ro"];
var ru = __webpack_require__(151)["ru"];
var si = __webpack_require__(152)["si"];
var sk = __webpack_require__(115)["sk"];
var sl = __webpack_require__(153)["sl"];
var sq = __webpack_require__(154)["sq"];
var sr = __webpack_require__(155)["sr"];
var sv = __webpack_require__(156)["sv"];
var th = __webpack_require__(157)["th"];
var tr = __webpack_require__(158)["tr"];
var uk = __webpack_require__(159)["uk"];
var vn = __webpack_require__(160)["vn"];
var zh = __webpack_require__(161)["zh"];

var l10n = {
	ar: ar,
	bg: bg,
	bn: bn,
	cat: cat,
	cs: cs,
	cy: cy,
	da: da,
	de: de,
	eo: eo,
	es: es,
	et: et,
	fa: fa,
	fi: fi,
	fr: fr,
	gr: gr,
	he: he,
	hi: hi,
	hr: hr,
	hu: hu,
	id: id,
	it: it,
	ja: ja,
	ko: ko,
	lt: lt,
	lv: lv,
	mk: mk,
	ms: ms,
	my: my,
	nl: nl,
	no: no,
	pa: pa,
	pl: pl,
	pt: pt,
	ro: ro,
	ru: ru,
	si: si,
	sk: sk,
	sl: sl,
	sq: sq,
	sr: sr,
	sv: sv,
	th: th,
	tr: tr,
	uk: uk,
	vn: vn,
	zh: zh
};

if (true) module.exports = l10n;

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

/* Arabic locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.ar = {};

flatpickr.l10ns.ar.weekdays = {
	shorthand: ["", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", ""]
};

flatpickr.l10ns.ar.months = {
	shorthand: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
	longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

/* Bulgarian locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.bg = {};

flatpickr.l10ns.bg.weekdays = {
	shorthand: ["", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", ""]
};

flatpickr.l10ns.bg.months = {
	shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

/* Bangla locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.bn = {};

flatpickr.l10ns.bn.weekdays = {
	shorthand: ["", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", ""]
};

flatpickr.l10ns.bn.months = {
	shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

/* Catalan locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.cat = {};

flatpickr.l10ns.cat.weekdays = {
	shorthand: ["Dg", "Dl", "Dt", "Dc", "Dj", "Dv", "Ds"],
	longhand: ["Diumenge", "Dilluns", "Dimarts", "Dimecres", "Dijous", "Divendres", "Dissabte"]
};

flatpickr.l10ns.cat.months = {
	shorthand: ["Gen", "Febr", "Mar", "Abr", "Maig", "Juny", "Jul", "Ag", "Set", "Oct", "Nov", "Des"],
	longhand: ["Gener", "Febrer", "Mar", "Abril", "Maig", "Juny", "Juliol", "Agost", "Setembre", "Octubre", "Novembre", "Desembre"]
};

flatpickr.l10ns.cat.ordinal = function (nth) {
	var s = nth % 100;
	if (s > 3 && s < 21) return "";
	switch (s % 10) {
		case 1:
			return "r";
		case 2:
			return "n";
		case 3:
			return "r";
		case 4:
			return "t";
		default:
			return "";
	}
};

flatpickr.l10ns.cat.firstDayOfWeek = 1;

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

/* Czech locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.cs = {};

flatpickr.l10ns.cs.weekdays = {
	shorthand: ["Ne", "Po", "t", "St", "t", "P", "So"],
	longhand: ["Nedle", "Pondl", "ter", "Steda", "tvrtek", "Ptek", "Sobota"]
};

flatpickr.l10ns.cs.months = {
	shorthand: ["Led", "n", "Be", "Dub", "Kv", "er", "vc", "Srp", "Z", "j", "Lis", "Pro"],
	longhand: ["Leden", "nor", "Bezen", "Duben", "Kvten", "erven", "ervenec", "Srpen", "Z", "jen", "Listopad", "Prosinec"]
};

flatpickr.l10ns.cs.firstDayOfWeek = 1;

flatpickr.l10ns.cs.ordinal = function () {
	return ".";
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

/* Welsh locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.cy = {};

flatpickr.l10ns.cy.weekdays = {
	shorthand: ["Sul", "Llun", "Maw", "Mer", "Iau", "Gwe", "Sad"],
	longhand: ["Dydd Sul", "Dydd Llun", "Dydd Mawrth", "Dydd Mercher", "Dydd Iau", "Dydd Gwener", "Dydd Sadwrn"]
};

flatpickr.l10ns.cy.months = {
	shorthand: ["Ion", "Chwef", "Maw", "Ebr", "Mai", "Meh", "Gorff", "Awst", "Medi", "Hyd", "Tach", "Rhag"],
	longhand: ["Ionawr", "Chwefror", "Mawrth", "Ebrill", "Mai", "Mehefin", "Gorffennaf", "Awst", "Medi", "Hydref", "Tachwedd", "Rhagfyr"]
};

flatpickr.l10ns.cy.firstDayOfWeek = 1;

flatpickr.l10ns.cy.ordinal = function (nth) {
	if (nth === 1) return "af";

	if (nth === 2) return "ail";

	if (nth === 3 || nth === 4) return "ydd";

	if (nth === 5 || nth === 6) return "ed";

	if (nth >= 7 && nth <= 10 || nth == 12 || nth == 15 || nth == 18 || nth == 20) return "fed";

	if (nth == 11 || nth == 13 || nth == 14 || nth == 16 || nth == 17 || nth == 19) return "eg";

	if (nth >= 21 && nth <= 39) return "ain";

	// Inconclusive.
	return "";
};

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

/* Danish locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.da = {};

flatpickr.l10ns.da.weekdays = {
	shorthand: ["Sn", "Man", "Tir", "Ons", "Tors", "Fre", "Lr"],
	longhand: ["Sndag", "Mandag", "Tirsdag", "Onsdag", "Torsdag", "Fredag", "Lrdag"]
};

flatpickr.l10ns.da.months = {
	shorthand: ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dec"],
	longhand: ["Januar", "Februar", "Marts", "April", "Maj", "Juni", "Juli", "August", "September", "Oktober", "November", "December"]
};

flatpickr.l10ns.da.ordinal = function () {
	return ".";
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

/* German locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.de = {};

flatpickr.l10ns.de.weekdays = {
	shorthand: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
	longhand: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"]
};

flatpickr.l10ns.de.months = {
	shorthand: ["Jan", "Feb", "Mr", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"],
	longhand: ["Januar", "Februar", "Mrz", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"]
};

flatpickr.l10ns.de.firstDayOfWeek = 1;
flatpickr.l10ns.de.weekAbbreviation = "KW";
flatpickr.l10ns.de.rangeSeparator = " bis ";
flatpickr.l10ns.de.scrollTitle = "Zum ndern scrollen";
flatpickr.l10ns.de.toggleTitle = "Zum Umschalten klicken";

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

/* Esperanto locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.eo = {};

flatpickr.l10ns.eo.firstDayOfWeek = 1;

flatpickr.l10ns.eo.rangeSeparator = " is ";
flatpickr.l10ns.eo.weekAbbreviation = "Sem";
flatpickr.l10ns.eo.scrollTitle = "Rulumu por pligrandigi la valoron";
flatpickr.l10ns.eo.toggleTitle = "Klaku por alti";

flatpickr.l10ns.eo.weekdays = {
	shorthand: ["Dim", "Lun", "Mar", "Mer", "a", "Ven", "Sab"],
	longhand: ["dimano", "lundo", "mardo", "merkredo", "ado", "vendredo", "sabato"]
};

flatpickr.l10ns.eo.months = {
	shorthand: ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Ag", "Sep", "Okt", "Nov", "Dec"],
	longhand: ["januaro", "februaro", "marto", "aprilo", "majo", "junio", "julio", "agusto", "septembro", "oktobro", "novembro", "decembro"]
};

flatpickr.l10ns.eo.ordinal = function () {
	return "-a";
};

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

/* Spanish locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.es = {};

flatpickr.l10ns.es.weekdays = {
	shorthand: ["Dom", "Lun", "Mar", "Mi", "Jue", "Vie", "Sb"],
	longhand: ["Domingo", "Lunes", "Martes", "Mircoles", "Jueves", "Viernes", "Sbado"]
};

flatpickr.l10ns.es.months = {
	shorthand: ["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"],
	longhand: ["Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"]
};

flatpickr.l10ns.es.ordinal = function () {
	return "";
};

flatpickr.l10ns.es.firstDayOfWeek = 1;
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

/* Estonian locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.et = {};

flatpickr.l10ns.et.weekdays = {
	shorthand: ["P", "E", "T", "K", "N", "R", "L"],
	longhand: ["Phapev", "Esmaspev", "Teisipev", "Kolmapev", "Neljapev", "Reede", "Laupev"]
};

flatpickr.l10ns.et.months = {
	shorthand: ["Jaan", "Veebr", "Mrts", "Apr", "Mai", "Juuni", "Juuli", "Aug", "Sept", "Okt", "Nov", "Dets"],
	longhand: ["Jaanuar", "Veebruar", "Mrts", "Aprill", "Mai", "Juuni", "Juuli", "August", "September", "Oktoober", "November", "Detsember"]
};

flatpickr.l10ns.et.firstDayOfWeek = 1;

flatpickr.l10ns.et.ordinal = function () {
	return ".";
};

flatpickr.l10ns.et.weekAbbreviation = "Nd";
flatpickr.l10ns.et.rangeSeparator = " kuni ";
flatpickr.l10ns.et.scrollTitle = "Keri, et suurendada";
flatpickr.l10ns.et.toggleTitle = "Klpsa, et vahetada";

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

/* Farsi (Persian) locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.fa = {};

flatpickr.l10ns.fa.weekdays = {
	shorthand: ["", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", ""]
};

flatpickr.l10ns.fa.months = {
	shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
};

flatpickr.l10ns.fa.ordinal = function () {
	return "";
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

/* Finnish locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.fi = {};

flatpickr.l10ns.fi.firstDayOfWeek = 1;

flatpickr.l10ns.fi.weekdays = {
	shorthand: ["Su", "Ma", "Ti", "Ke", "To", "Pe", "La"],
	longhand: ["Sunnuntai", "Maanantai", "Tiistai", "Keskiviikko", "Torstai", "Perjantai", "Lauantai"]
};

flatpickr.l10ns.fi.months = {
	shorthand: ["Tammi", "Helmi", "Maalis", "Huhti", "Touko", "Kes", "Hein", "Elo", "Syys", "Loka", "Marras", "Joulu"],
	longhand: ["Tammikuu", "Helmikuu", "Maaliskuu", "Huhtikuu", "Toukokuu", "Keskuu", "Heinkuu", "Elokuu", "Syyskuu", "Lokakuu", "Marraskuu", "Joulukuu"]
};

flatpickr.l10ns.fi.ordinal = function () {
	return ".";
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

/* French locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.fr = {};

flatpickr.l10ns.fr.firstDayOfWeek = 1;

flatpickr.l10ns.fr.weekdays = {
	shorthand: ["Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam"],
	longhand: ["Dimanche", "Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Samedi"]
};

flatpickr.l10ns.fr.months = {
	shorthand: ["Janv", "Fvr", "Mars", "Avr", "Mai", "Juin", "Juil", "Aot", "Sept", "Oct", "Nov", "Dc"],
	longhand: ["Janvier", "Fvrier", "Mars", "Avril", "Mai", "Juin", "Juillet", "Aot", "Septembre", "Octobre", "Novembre", "Dcembre"]
};

flatpickr.l10ns.fr.ordinal = function (nth) {
	if (nth > 1) return "me";

	return "er";
};
if (true) module.exports = flatpickr.l10ns;

flatpickr.l10ns.fr.rangeSeparator = " au ";
flatpickr.l10ns.fr.weekAbbreviation = "Sem";
flatpickr.l10ns.fr.scrollTitle = "Dfiler pour augmenter la valeur";
flatpickr.l10ns.fr.toggleTitle = "Cliquer pour basculer";

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

/* Greek locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.gr = {};

flatpickr.l10ns.gr.weekdays = {
	shorthand: ["", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", ""]
};

flatpickr.l10ns.gr.months = {
	shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
};

flatpickr.l10ns.gr.firstDayOfWeek = 1;

flatpickr.l10ns.gr.ordinal = function () {
	return "";
};

flatpickr.l10ns.gr.weekAbbreviation = "";
flatpickr.l10ns.gr.rangeSeparator = "  ";
flatpickr.l10ns.gr.scrollTitle = "  ";
flatpickr.l10ns.gr.toggleTitle = "   ";

flatpickr.l10ns.gr.am = "";
flatpickr.l10ns.gr.pm = "";

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

/* Hebrew locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.he = {};

flatpickr.l10ns.he.weekdays = {
	shorthand: ["", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", ""]
};

flatpickr.l10ns.he.months = {
	shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

/* Hindi locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.hi = {};

flatpickr.l10ns.hi.weekdays = {
	shorthand: ["", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", ""]
};

flatpickr.l10ns.hi.months = {
	shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
	longhand: [" ", "", "", "", "", "", "", " ", "", "", "", ""]
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

/* Croatian locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.hr = {};

flatpickr.l10ns.hr.firstDayOfWeek = 1;

flatpickr.l10ns.hr.weekdays = {
	shorthand: ["Ned", "Pon", "Uto", "Sri", "et", "Pet", "Sub"],
	longhand: ["Nedjelja", "Ponedjeljak", "Utorak", "Srijeda", "etvrtak", "Petak", "Subota"]
};

flatpickr.l10ns.hr.months = {
	shorthand: ["Sij", "Velj", "Ou", "Tra", "Svi", "Lip", "Srp", "Kol", "Ruj", "Lis", "Stu", "Pro"],
	longhand: ["Sijeanj", "Veljaa", "Oujak", "Travanj", "Svibanj", "Lipanj", "Srpanj", "Kolovoz", "Rujan", "Listopad", "Studeni", "Prosinac"]
};

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

/* Hungarian locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.hu = {};

flatpickr.l10ns.hu.firstDayOfWeek = 1;

flatpickr.l10ns.hu.weekdays = {
	shorthand: ["V", "H", "K", "Sz", "Cs", "P", "Szo"],
	longhand: ["Vasrnap", "Htf", "Kedd", "Szerda", "Cstrtk", "Pntek", "Szombat"]
};

flatpickr.l10ns.hu.months = {
	shorthand: ["Jan", "Feb", "Mr", "pr", "Mj", "Jn", "Jl", "Aug", "Szep", "Okt", "Nov", "Dec"],
	longhand: ["Janur", "Februr", "Mrcius", "prilis", "Mjus", "Jnius", "Jlius", "Augusztus", "Szeptember", "Oktber", "November", "December"]
};

flatpickr.l10ns.hu.ordinal = function () {
	return ".";
};

flatpickr.l10ns.hu.weekAbbreviation = "Ht";
flatpickr.l10ns.hu.scrollTitle = "Grgessen";
flatpickr.l10ns.hu.toggleTitle = "Kattintson a vltshoz";

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

/* Indonesian locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.id = {};

flatpickr.l10ns.id.weekdays = {
	shorthand: ["Min", "Sen", "Sel", "Rab", "Kam", "Jum", "Sab"],
	longhand: ["Minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu"]
};

flatpickr.l10ns.id.months = {
	shorthand: ["Jan", "Feb", "Mar", "Apr", "Mei", "Jun", "Jul", "Agu", "Sep", "Okt", "Nov", "Des"],
	longhand: ["Januari", "Februari", "Maret", "April", "Mei", "Juni", "Juli", "Agustus", "September", "Oktober", "November", "Desember"]
};

flatpickr.l10ns.id.firstDayOfWeek = 1;

flatpickr.l10ns.id.ordinal = function () {
	return "";
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

/* Italian locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.it = {};

flatpickr.l10ns.it.weekdays = {
	shorthand: ["Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"],
	longhand: ["Domenica", "Luned", "Marted", "Mercoled", "Gioved", "Venerd", "Sabato"]
};

flatpickr.l10ns.it.months = {
	shorthand: ["Gen", "Feb", "Mar", "Apr", "Mag", "Giu", "Lug", "Ago", "Set", "Ott", "Nov", "Dic"],
	longhand: ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"]
};

flatpickr.l10ns.it.firstDayOfWeek = 1;

flatpickr.l10ns.it.ordinal = "";

flatpickr.l10ns.it.weekAbbreviation = "Se";

flatpickr.l10ns.it.scrollTitle = "Scrolla per aumentare";

flatpickr.l10ns.it.toggleTitle = "Clicca per cambiare";

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

/* Japanese locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.ja = {};

flatpickr.l10ns.ja.weekdays = {
	shorthand: ["", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", ""]
};

flatpickr.l10ns.ja.months = {
	shorthand: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
	longhand: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"]
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

/* Republic of Korea locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.ko = {};

flatpickr.l10ns.ko.weekdays = {
	shorthand: ["", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", ""]
};

flatpickr.l10ns.ko.months = {
	shorthand: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
	longhand: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"]
};

flatpickr.l10ns.ko.ordinal = function () {
	return "";
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

/* Lithuanian locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.lt = {};

flatpickr.l10ns.lt.weekdays = {
	shorthand: ["S", "Pr", "A", "T", "K", "Pn", ""],
	longhand: ["Sekmadienis", "Pirmadienis", "Antradienis", "Treiadienis", "Ketvirtadienis", "Penktadienis", "etadienis"]
};

flatpickr.l10ns.lt.months = {
	shorthand: ["Sau", "Vas", "Kov", "Bal", "Geg", "Bir", "Lie", "Rgp", "Rgs", "Spl", "Lap", "Grd"],
	longhand: ["Sausis", "Vasaris", "Kovas", "Balandis", "Gegu", "Birelis", "Liepa", "Rugpjutis", "Rugsejis", "Spalis", "Lapkritis", "Gruodis"]
};

flatpickr.l10ns.lt.firstDayOfWeek = 1;

flatpickr.l10ns.lt.ordinal = function () {
	return "-a";
};

flatpickr.l10ns.lt.weekAbbreviation = "Sav";
flatpickr.l10ns.lt.scrollTitle = "Keisti laik pels rateliu";
flatpickr.l10ns.lt.toggleTitle = "Perjungti laiko format";

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

/* Latvian locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.lv = {};

flatpickr.l10ns.lv.firstDayOfWeek = 1;

flatpickr.l10ns.lv.weekdays = {
	shorthand: ["Sv", "P", "Ot", "Tr", "Ce", "Pk", "Se"],
	longhand: ["Svtdiena", "Pirmdiena", "Otrdiena", "Trediena", "Ceturtdiena", "Piektdiena", "Sestdiena"]
};

flatpickr.l10ns.lv.months = {
	shorthand: ["Jan", "Feb", "Mar", "Mai", "Apr", "Jn", "Jl", "Aug", "Sep", "Okt", "Nov", "Dec"],
	longhand: ["Janvris", "Februris", "Marts", "Aprlis", "Maijs", "Jnijs", "Jlijs", "Augusts", "Septembris", "Oktobris", "Novembris", "Decembris"]
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

/* Macedonian locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.mk = {};

flatpickr.l10ns.mk.weekdays = {
	shorthand: ["", "", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", "", ""]
};

flatpickr.l10ns.mk.months = {
	shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
};

flatpickr.l10ns.mk.firstDayOfWeek = 1;
flatpickr.l10ns.mk.weekAbbreviation = ".";
flatpickr.l10ns.mk.rangeSeparator = "  ";

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

/* Malaysian locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.ms = {};

flatpickr.l10ns.ms.weekdays = {
	shorthand: ["Min", "Isn", "Sel", "Rab", "Kha", "Jum", "Sab"],
	longhand: ["Minggu", "Isnin", "Selasa", "Rabu", "Khamis", "Jumaat", "Sabtu"]
};

flatpickr.l10ns.ms.months = {
	shorthand: ["Jan", "Feb", "Mac", "Apr", "Mei", "Jun", "Jul", "Ogo", "Sep", "Okt", "Nov", "Dis"],
	longhand: ["Januari", "Februari", "Mac", "April", "Mei", "Jun", "Julai", "Ogos", "September", "Oktober", "November", "Disember"]
};

flatpickr.l10ns.ms.firstDayOfWeek = 1;

flatpickr.l10ns.ms.ordinal = function () {
	return "";
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

/* Burmese locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.my = {};

flatpickr.l10ns.my.weekdays = {
	shorthand: ["", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", ""]
};

flatpickr.l10ns.my.months = {
	shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
};

flatpickr.l10ns.my.firstDayOfWeek = 1;

flatpickr.l10ns.my.ordinal = function () {
	return "";
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

/* Dutch locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.nl = {};

flatpickr.l10ns.nl.weekdays = {
	shorthand: ["zo", "ma", "di", "wo", "do", "vr", "za"],
	longhand: ["zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag"]
};

flatpickr.l10ns.nl.months = {
	shorthand: ["jan", "feb", "mrt", "apr", "mei", "jun", "jul", "aug", "sept", "okt", "nov", "dec"],
	longhand: ["januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december"]
};

flatpickr.l10ns.nl.firstDayOfWeek = 1;
flatpickr.l10ns.nl.weekAbbreviation = "wk";
flatpickr.l10ns.nl.rangeSeparator = " tot ";
flatpickr.l10ns.nl.scrollTitle = "Scroll voor volgende / vorige";
flatpickr.l10ns.nl.toggleTitle = "Klik om te wisselen";

flatpickr.l10ns.nl.ordinal = function (nth) {
	if (nth === 1 || nth === 8 || nth >= 20) return "ste";

	return "de";
};

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

/* Norwegian locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.no = {};

flatpickr.l10ns.no.weekdays = {
	shorthand: ["Sn", "Man", "Tir", "Ons", "Tor", "Fre", "Lr"],
	longhand: ["Sndag", "Mandag", "Tirsdag", "Onsdag", "Torsdag", "Fredag", "Lrdag"]
};

flatpickr.l10ns.no.months = {
	shorthand: ["Jan", "Feb", "Mar", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Des"],
	longhand: ["Januar", "Februar", "Mars", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Desember"]
};

flatpickr.l10ns.no.firstDayOfWeek = 1;
flatpickr.l10ns.no.rangeSeparator = " til ";
flatpickr.l10ns.no.weekAbbreviation = "Uke";
flatpickr.l10ns.no.scrollTitle = "Scroll for  endre";
flatpickr.l10ns.no.toggleTitle = "Klikk for  veksle";

flatpickr.l10ns.no.ordinal = function () {
	return ".";
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

/* Punjabi locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.pa = {};

flatpickr.l10ns.pa.weekdays = {
	shorthand: ["", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", ""]
};

flatpickr.l10ns.pa.months = {
	shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

/* Polish locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.pl = {};

flatpickr.l10ns.pl.weekdays = {
	shorthand: ["Nd", "Pn", "Wt", "r", "Cz", "Pt", "So"],
	longhand: ["Niedziela", "Poniedziaek", "Wtorek", "roda", "Czwartek", "Pitek", "Sobota"]
};

flatpickr.l10ns.pl.months = {
	shorthand: ["Sty", "Lut", "Mar", "Kwi", "Maj", "Cze", "Lip", "Sie", "Wrz", "Pa", "Lis", "Gru"],
	longhand: ["Stycze", "Luty", "Marzec", "Kwiecie", "Maj", "Czerwiec", "Lipiec", "Sierpie", "Wrzesie", "Padziernik", "Listopad", "Grudzie"]
};

flatpickr.l10ns.pl.ordinal = function () {
	return ".";
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

/* Portuguese locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.pt = {};

flatpickr.l10ns.pt.weekdays = {
	shorthand: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sb"],
	longhand: ["Domingo", "Segunda-feira", "Tera-feira", "Quarta-feira", "Quinta-feira", "Sexta-feira", "Sbado"]
};

flatpickr.l10ns.pt.months = {
	shorthand: ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"],
	longhand: ["Janeiro", "Fevereiro", "Maro", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"]
};

flatpickr.l10ns.pt.rangeSeparator = " at ";

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

/* Romanian locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.ro = {};

flatpickr.l10ns.ro.weekdays = {
	shorthand: ["Dum", "Lun", "Mar", "Mie", "Joi", "Vin", "Sam"],
	longhand: ["Duminic", "Luni", "Mari", "Miercuri", "Joi", "Vineri", "Smbt"]
};

flatpickr.l10ns.ro.months = {
	shorthand: ["Ian", "Feb", "Mar", "Apr", "Mai", "Iun", "Iul", "Aug", "Sep", "Oct", "Noi", "Dec"],
	longhand: ["Ianuarie", "Februarie", "Martie", "Aprilie", "Mai", "Iunie", "Iulie", "August", "Septembrie", "Octombrie", "Noiembrie", "Decembrie"]
};

flatpickr.l10ns.ro.firstDayOfWeek = 1;

flatpickr.l10ns.ro.ordinal = function () {
	return "";
};

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

/* Russian locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.ru = {};

flatpickr.l10ns.ru.firstDayOfWeek = 1; // Monday

flatpickr.l10ns.ru.weekdays = {
	shorthand: ["", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", ""]
};

flatpickr.l10ns.ru.months = {
	shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

/* Sinhala locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.si = {};

flatpickr.l10ns.si.weekdays = {
	shorthand: ["", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", ""]
};

flatpickr.l10ns.si.months = {
	shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
};

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

/* Slovenian locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.sl = {};

flatpickr.l10ns.sl.weekdays = {
	shorthand: ["Ned", "Pon", "Tor", "Sre", "et", "Pet", "Sob"],
	longhand: ["Nedelja", "Ponedeljek", "Torek", "Sreda", "etrtek", "Petek", "Sobota"]
};

flatpickr.l10ns.sl.months = {
	shorthand: ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Avg", "Sep", "Okt", "Nov", "Dec"],
	longhand: ["Januar", "Februar", "Marec", "April", "Maj", "Junij", "Julij", "Avgust", "September", "Oktober", "November", "December"]
};

flatpickr.l10ns.sl.firstDayOfWeek = 1;
flatpickr.l10ns.sl.rangeSeparator = " do ";
flatpickr.l10ns.sl.ordinal = function () {
	return ".";
};

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

/* Albanian locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.sq = {};

flatpickr.l10ns.sq.weekdays = {
	shorthand: ["Di", "H", "Ma", "M", "En", "Pr", "Sh"],
	longhand: ["E Diel", "E Hn", "E Mart", "E Mrkur", "E Enjte", "E Premte", "E Shtun"]
};

flatpickr.l10ns.sq.months = {
	shorthand: ["Jan", "Shk", "Mar", "Pri", "Maj", "Qer", "Kor", "Gus", "Sht", "Tet", "Nn", "Dhj"],
	longhand: ["Janar", "Shkurt", "Mars", "Prill", "Maj", "Qershor", "Korrik", "Gusht", "Shtator", "Tetor", "Nntor", "Dhjetor"]
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

/* Serbian locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.sr = {};

flatpickr.l10ns.sr.weekdays = {
	shorthand: ["Ned", "Pon", "Uto", "Sre", "et", "Pet", "Sub", "Ned"],
	longhand: ["Nedelja", "Ponedeljak", "Utorak", "Sreda", "etvrtak", "Petak", "Subota", "Nedelja"]
};

flatpickr.l10ns.sr.months = {
	shorthand: ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Avg", "Sep", "Okt", "Nov", "Dec"],
	longhand: ["Januar", "Februar", "Mart", "April", "Maj", "Jun", "Jul", "Avgust", "Septembar", "Oktobar", "Novembar", "Decembar"]
};

flatpickr.l10ns.sr.firstDayOfWeek = 1;
flatpickr.l10ns.sr.weekAbbreviation = "Ned.";
flatpickr.l10ns.sr.rangeSeparator = " do ";

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

/* Swedish locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.sv = {};

flatpickr.l10ns.sv.firstDayOfWeek = 1;
flatpickr.l10ns.sv.weekAbbreviation = "v";

flatpickr.l10ns.sv.weekdays = {
	shorthand: ["Sn", "Mn", "Tis", "Ons", "Tor", "Fre", "Lr"],
	longhand: ["Sndag", "Mndag", "Tisdag", "Onsdag", "Torsdag", "Fredag", "Lrdag"]
};

flatpickr.l10ns.sv.months = {
	shorthand: ["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dec"],
	longhand: ["Januari", "Februari", "Mars", "April", "Maj", "Juni", "Juli", "Augusti", "September", "Oktober", "November", "December"]
};

flatpickr.l10ns.sv.ordinal = function () {
	return ".";
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

/* Thai locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.th = {};

flatpickr.l10ns.th.weekdays = {
	shorthand: ["", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", ""]
};

flatpickr.l10ns.th.months = {
	shorthand: ["..", "..", "..", "..", "..", "..", "..", "..", "..", "..", "..", ".."],
	longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
};

flatpickr.l10ns.th.firstDayOfWeek = 1;
flatpickr.l10ns.th.rangeSeparator = "  ";
flatpickr.l10ns.th.scrollTitle = "";
flatpickr.l10ns.th.toggleTitle = "";

flatpickr.l10ns.th.ordinal = function () {
	return "";
};

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

/* Turkish locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.tr = {};

flatpickr.l10ns.tr.firstDayOfWeek = 1;

flatpickr.l10ns.tr.weekdays = {
	shorthand: ["Paz", "Pzt", "Sal", "ar", "Per", "Cum", "Cmt"],
	longhand: ["Pazar", "Pazartesi", "Sal", "aramba", "Perembe", "Cuma", "Cumartesi"]
};

flatpickr.l10ns.tr.months = {
	shorthand: ["Oca", "ub", "Mar", "Nis", "May", "Haz", "Tem", "Au", "Eyl", "Eki", "Kas", "Ara"],
	longhand: ["Ocak", "ubat", "Mart", "Nisan", "Mays", "Haziran", "Temmuz", "Austos", "Eyll", "Ekim", "Kasm", "Aralk"]
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

/* Ukrainian locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.uk = {};

flatpickr.l10ns.uk.firstDayOfWeek = 1;

flatpickr.l10ns.uk.weekdays = {
	shorthand: ["", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "'", ""]
};

flatpickr.l10ns.uk.months = {
	shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
};
if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

/* Vietnamese locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.vn = {};

flatpickr.l10ns.vn.weekdays = {
	shorthand: ["CN", "T2", "T3", "T4", "T5", "T6", "T7"],
	longhand: ["Ch nht", "Th hai", "Th ba", "Th t", "Th nm", "Th su", "Th by"]
};

flatpickr.l10ns.vn.months = {
	shorthand: ["Th1", "Th2", "Th3", "Th4", "Th5", "Th6", "Th7", "Th8", "Th9", "Th10", "Th11", "Th12"],
	longhand: ["Thng mt", "Thng hai", "Thng ba", "Thng t", "Thng nm", "Thng su", "Thng by", "Thng tm", "Thng chn", "Thng mi", "Thng 11", "Thng 12"]
};

flatpickr.l10ns.vn.firstDayOfWeek = 1;

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

/* Mandarin locals for flatpickr */
var flatpickr = flatpickr || { l10ns: {} };
flatpickr.l10ns.zh = {};

flatpickr.l10ns.zh.weekdays = {
	shorthand: ["", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", ""]
};

flatpickr.l10ns.zh.months = {
	shorthand: ["", "", "", "", "", "", "", "", "", "", "", ""],
	longhand: ["", "", "", "", "", "", "", "", "", "", "", ""]
};

flatpickr.l10ns.zh.rangeSeparator = "  ";
flatpickr.l10ns.zh.weekAbbreviation = "";
flatpickr.l10ns.zh.scrollTitle = "";
flatpickr.l10ns.zh.toggleTitle = " 12/24 ";

if (true) module.exports = flatpickr.l10ns;

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./": 116,
	"./ar": 117,
	"./ar.js": 117,
	"./bg": 118,
	"./bg.js": 118,
	"./bn": 119,
	"./bn.js": 119,
	"./cat": 120,
	"./cat.js": 120,
	"./cs": 121,
	"./cs.js": 121,
	"./cy": 122,
	"./cy.js": 122,
	"./da": 123,
	"./da.js": 123,
	"./de": 124,
	"./de.js": 124,
	"./eo": 125,
	"./eo.js": 125,
	"./es": 126,
	"./es.js": 126,
	"./et": 127,
	"./et.js": 127,
	"./fa": 128,
	"./fa.js": 128,
	"./fi": 129,
	"./fi.js": 129,
	"./fr": 130,
	"./fr.js": 130,
	"./gr": 131,
	"./gr.js": 131,
	"./he": 132,
	"./he.js": 132,
	"./hi": 133,
	"./hi.js": 133,
	"./hr": 134,
	"./hr.js": 134,
	"./hu": 135,
	"./hu.js": 135,
	"./id": 136,
	"./id.js": 136,
	"./index": 116,
	"./index.js": 116,
	"./it": 137,
	"./it.js": 137,
	"./ja": 138,
	"./ja.js": 138,
	"./ko": 139,
	"./ko.js": 139,
	"./lt": 140,
	"./lt.js": 140,
	"./lv": 141,
	"./lv.js": 141,
	"./mk": 142,
	"./mk.js": 142,
	"./ms": 143,
	"./ms.js": 143,
	"./my": 144,
	"./my.js": 144,
	"./nl": 145,
	"./nl.js": 145,
	"./no": 146,
	"./no.js": 146,
	"./pa": 147,
	"./pa.js": 147,
	"./pl": 148,
	"./pl.js": 148,
	"./pt": 149,
	"./pt.js": 149,
	"./ro": 150,
	"./ro.js": 150,
	"./ru": 151,
	"./ru.js": 151,
	"./si": 152,
	"./si.js": 152,
	"./sk": 115,
	"./sk.js": 115,
	"./sl": 153,
	"./sl.js": 153,
	"./sq": 154,
	"./sq.js": 154,
	"./sr": 155,
	"./sr.js": 155,
	"./sv": 156,
	"./sv.js": 156,
	"./th": 157,
	"./th.js": 157,
	"./tr": 158,
	"./tr.js": 158,
	"./uk": 159,
	"./uk.js": 159,
	"./vn": 160,
	"./vn.js": 160,
	"./zh": 161,
	"./zh.js": 161
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number or string
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 162;

/***/ }),
/* 163 */,
/* 164 */,
/* 165 */
/***/ (function(module, exports) {

var selector=function(e){function t(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}var n={};return t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=14)}([function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default={data:{selector:null,callback:null,onOpen:null,onClose:null,onSelect:null,destroy:null,element:null,created:null,opened:null,closed:null,selected:null,beforeCreate:null,beforeSelect:null,beforeDestroy:null,destroyed:null,label:null,type:null},get:function(e){return this.data[e]},set:function(e,t){if(!this.data.hasOwnProperty(e))return!1;this.data[e]=t},save:function(e){var t=this;Object.keys(e).forEach(function(n){if(!t.data.hasOwnProperty(n))return!1;t.data[n]=e[n]})}}},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0});var o=n(5),i=r(o),s=n(0),a=r(s);t.default={parentTemplate:void 0,selectedTemplate:void 0,groupTemplate:void 0,optionsTemplate:void 0,optionTemplate:void 0,filterTemplate:void 0,constructor:function(e){this.element=e,this.createElements();var t=new i.default(e);t.renderParent(),t.renderContent(),t.renderSelected(),t.show()},isFilterType:function(){return"filter"===a.default.get("type")||(this.element.getAttribute("data-type")||"").match(/(search)|(find)/)},createElement:function(e,t){var n=document.createElement(e);return Object.keys(t).forEach(function(e){n.setAttribute(e,t[e])}),n},createElements:function(){this.createParentElement(),this.createSelectedElement(),this.createGroupElement(),this.createOptionsElement(),this.createOptionElement(),this.parentTemplate.appendChild(this.selectedTemplate),this.parentTemplate.appendChild(this.optionsTemplate)},createParentElement:function(){this.parentTemplate=this.createElement("div",{class:"selector-element","data-reference":"","data-type":"",id:""})},createSelectedElement:function(){this.selectedTemplate=this.createElement("div",{class:"selector-selected"}),this.selectedTemplate.appendChild(this.createElement("p",{class:"selected-text"}))},createGroupElement:function(){this.groupTemplate=this.createElement("div",{class:"selector-group","data-group":""}),this.groupTemplate.appendChild(this.createElement("span",{class:"group-text"}))},createOptionsElement:function(){this.optionsTemplate=this.createElement("div",{class:"selector-options"})},createOptionElement:function(){this.optionTemplate=this.createElement("div",{class:"selector-option show","data-item":""}),this.optionTemplate.appendChild(this.createElement("span",{class:"option-text"}))},createFilterElement:function(){this.filterTemplate=this.createElement("div",{class:"selector-filter"}),this.filterTemplate.appendChild(this.createElement("input",{class:"selector-filter-input",type:"search","data-placeholder":"SELECTOR_FILTER_PLACEHOLDER",placeholder:"Filter options"})),this.filterTemplate.appendChild(this.createElement("span",{class:"selector-filter-clear"}))}}},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0});var o=n(0),i=r(o),s=n(1),a=r(s);t.default={close:function(){document.addEventListener("click",function(e){document.querySelectorAll(".selector-element").forEach(function(t){e.target===t||t.contains(e.target)||t.querySelector(".selector-options").classList.remove("visible")})})},showOptions:function(e,t){var n=i.default.data,r=a.default.isFilterType(),o=t.matches("[data-disabled]");t.querySelector(".selector-selected").addEventListener("click",function(){if(o)return!1;if(e.classList.toggle("visible"),r){var i=t.querySelector("input");i.focus(),i.value="",i.oninput()}e.classList.contains("visible")?n.closed?n.closed():n.onClose&&n.onClose():n.opened?n.opened():n.onOpen&&n.onOpen()})},clearFilter:function(e,t){e.addEventListener("click",function(){t.value="",t.oninput()})},filterOptions:function(e,t){var n=e.querySelector("input"),r=t.querySelector(".selector-options");this.clearFilter(e.querySelector("span"),n),this.createIndex(r),n.oninput=function(){var e=n.value.trim().toLowerCase(),t=r.querySelectorAll(".selector-option");JSON.parse(r.dataset.index).forEach(function(n,r){-1!==n[0].indexOf(e)||-1!==n[1].indexOf(e)?t[r].classList.add("show"):t[r].classList.remove("show")})},n.onkeyup=function(e){if(e.keyCode&&13===e.keyCode){var n=t.querySelectorAll(".selector-option.show");if(1!==n.length)return!1;n[0].click()}}},createIndex:function(e){var t=Array.from(e.querySelectorAll(".selector-option")).map(function(e){return[e.children[0].innerText.toLowerCase(),e.dataset.item.toLowerCase()]});e.dataset.index=JSON.stringify(t)},select:function(e){var t=e.querySelector(".selector-selected"),n=i.default.data,r=document.querySelector('select[name="'+e.dataset.reference+'"]');e.querySelector(".selector-options").addEventListener("click",function(o){var i=o.target,s=".selector-option";if(i.matches(s)||i.parentNode.matches(s)){if(i.matches(s)||(i=i.parentNode),i.dataset.disabled||i.dataset.selected||i.parentNode.matches("[data-disabled]"))return!1;var a=e.querySelector("[data-selected]");n.beforeSelect&&n.beforeSelect(e,a.dataset.item),delete a.dataset.selected,i.dataset.selected="",t.children[0].innerText=i.children[0].innerText,t.click(),r.querySelector("[selected]").removeAttribute("selected"),r.querySelector('[value="'+i.dataset.item+'"]').setAttribute("selected","true"),n.selected?n.selected(e,i.dataset.item):n.onSelect&&n.onSelect(e,i)}})}}},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0});var o=n(0),i=r(o),s=n(4),a=r(s);t.default=function(){function e(e){i.default.save(e),a.default.constructor()}return function(t){return e(t),{destroy:a.default.destroy}}}()},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(t,"__esModule",{value:!0});var o=n(0),i=r(o),s=n(1),a=r(s),l=n(2),d=r(l);t.default={constructor:function(){this.prepareElements(),this.render()},prepareElements:function(){var e=i.default.get("element");if("string"==typeof e){if(e=document.querySelectorAll(e),0===e.length)throw new DOMException;i.default.set("element",e)}},render:function(){var e=this;i.default.data.element.forEach(function(t){if(!e.checkElement(t))return!1;a.default.constructor(t)}),d.default.close()},checkElement:function(e){return!!e.nodeType&&"SELECT"===e.tagName},destroy:function(){var e=i.default.data;e.beforeDestroy&&e.beforeDestroy(),e.element.forEach(function(e){var t=e.parentNode;t.removeChild(t.querySelector('[data-reference="'+e.name+'"]')),e.style.display=""}),e.destroyed&&e.destroyed()}}},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var i=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),s=n(1),a=r(s),l=n(0),d=r(l),c=n(2),p=r(c),u=function(){function e(t){o(this,e),this._element=t,this.hideOrigin(),this._render=null}return i(e,[{key:"hideOrigin",value:function(){this._element.style.display="none"}},{key:"renderParent",value:function(){var e=a.default.parentTemplate.cloneNode(!0);e.id=this._element.id,e.dataset.reference=this._element.name,e.dataset.type=d.default.get("type")||this._element.dataset.type||"default",this._element.disabled&&(e.dataset.disabled=!0),this._render=e}},{key:"renderContent",value:function(){var e=this,t=void 0,n=this._render.querySelector(".selector-options");if(p.default.showOptions(n,this._render),a.default.isFilterType()){var r=this.renderSearch();n.appendChild(r),p.default.filterOptions(r,this._render)}Array.from(this._element.children).forEach(function(r){var o=r.tagName;if("OPTGROUP"===o)t=e.renderGroup(r);else{if("OPTION"!==o)return!0;t=e.renderOption(r)}n.appendChild(t)}),a.default.isFilterType()&&p.default.createIndex(n),p.default.select(this._render)}},{key:"renderSearch",value:function(){return void 0===a.default.filterTemplate&&a.default.createFilterElement(),a.default.filterTemplate.cloneNode(!0)}},{key:"renderGroup",value:function(e){var t=this,n=a.default.groupTemplate.cloneNode(!0);return n.dataset.group=n.children[0].innerText=e.label,e.disabled&&(n.dataset.disabled=!0),Array.from(e.children).forEach(function(e){n.appendChild(t.renderOption(e))}),n}},{key:"renderOption",value:function(e){var t=a.default.optionTemplate.cloneNode(!0);return Object.keys(e.dataset).forEach(function(n){t.dataset[n]=e.dataset[n]}),t.dataset.item=e.value,t.children[0].innerText=e.innerText,e.disabled&&(t.dataset.disabled=!0),e.selected&&(t.dataset.selected=!0),t}},{key:"renderSelected",value:function(){var e=this._render.querySelector(".selector-selected");if(d.default.get("label"))e.children[0].innerText=d.default.get("label");else if(this._element.dataset.label)e.children[0].innerText=this._element.dataset.label;else{var t=this._element.querySelector("[selected]");t?(e.dataset.item=t.value,e.children[0].innerText=t.innerText):(e.dataset.item=void 0,e.children[0].innerText="---")}}},{key:"show",value:function(){var e=d.default.data;e.beforeCreate&&e.beforeCreate(),this._element.parentNode.insertBefore(this._render,this._element.nextSibling),e.created?e.created():e.callback&&e.callback()}}]),e}();t.default=u},function(e,t,n){"use strict";n(7)},function(e,t,n){var r=n(8);"string"==typeof r&&(r=[[e.i,r,""]]);var o={};o.transform=void 0,n(12)(r,o),r.locals&&(e.exports=r.locals)},function(e,t,n){t=e.exports=n(9)(void 0),t.push([e.i,'div.selector-element{position:relative;display:inline-block;width:320px;height:38px;background:#fff;box-shadow:0 1px 2px rgba(0,0,0,.05);box-sizing:border-box;border:1px solid silver;border-radius:3px;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,sans-serif;font-size:.92rem;transition:.2s ease-in-out}div.selector-element:hover{box-shadow:0 2px 4px rgba(0,0,0,.1)}div.selector-element div.selector-selected{position:relative;display:inline-block;width:100%;height:36px;cursor:pointer;background:#fff;box-sizing:border-box;padding:0 28px 0 11px;transition:.2s ease-in-out}div.selector-element div.selector-selected:hover{background:#fbfbfb}div.selector-element div.selector-selected:after{content:"";position:absolute;right:12px;top:50%;transform:translateY(-50%);border-top:6px solid silver;border-left:6px solid transparent;border-right:6px solid transparent}div.selector-element div.selector-selected p{display:inline-block;width:100%;height:100%;line-height:36px;margin:0;white-space:nowrap;text-overflow:ellipsis;overflow:hidden}div.selector-element div.selector-options{position:absolute;top:100%;left:-1px;display:none;width:100%;height:auto;max-height:210px;overflow:auto;z-index:99;border:1px solid silver;background:#fff;box-shadow:0 2px 4px rgba(0,0,0,.1);border-bottom-left-radius:3px;border-bottom-right-radius:3px}div.selector-element div.selector-options.visible{display:inline-block}div.selector-element div.selector-options div.selector-filter{position:-webkit-sticky;position:sticky;top:0;width:100%;height:32px;border-bottom:1px solid silver;z-index:2}div.selector-element div.selector-options div.selector-filter input{width:100%;height:100%;outline:none;border:none;background:#fff url('+n(10)+") left 11px center no-repeat;background-size:18px;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,sans-serif;font-size:.8rem;box-sizing:border-box;padding:0 36px}div.selector-element div.selector-options div.selector-filter .selector-filter-clear{position:absolute;right:9px;height:18px;width:18px;top:50%;transform:translateY(-50%);background:url("+n(11)+") 50% no-repeat;background-size:18px;opacity:.7;cursor:pointer}div.selector-element div.selector-options div.selector-filter .selector-filter-clear:hover{opacity:1}div.selector-element div.selector-options div.selector-group{display:inline-block;position:relative;float:left;width:100%;border-bottom:3px solid silver}div.selector-element div.selector-options div.selector-group span.group-text{display:inline-block;position:-webkit-sticky;position:sticky;top:0;float:left;width:100%;line-height:32px;text-transform:uppercase;font-size:.75rem;font-weight:600;background:#fbfbfb;color:#6b6b6b;box-sizing:border-box;padding:0 11px;overflow:hidden;white-space:nowrap;text-overflow:ellipsis;z-index:1}div.selector-element div.selector-options div.selector-group[data-disabled],div.selector-element div.selector-options div.selector-group[data-disabled] div.selector-option{opacity:.6;cursor:not-allowed}div.selector-element div.selector-options div.selector-option{position:relative;display:none;width:100%;height:32px;background:#fff;border-bottom:1px solid #ddd;cursor:pointer;box-sizing:border-box;transition:.2s ease-in-out}div.selector-element div.selector-options div.selector-option:hover{background:#f5f5f5}div.selector-element div.selector-options div.selector-option[data-selected]{background:#f2f2f2;font-weight:600}div.selector-element div.selector-options div.selector-option.show{display:inline-block}div.selector-element div.selector-options div.selector-option span.option-text{display:inline-block;width:100%;line-height:32px;font-size:.85rem;box-sizing:border-box;padding:0 11px}div.selector-element div.selector-options div.selector-option:last-of-type{border-bottom:none}div.selector-element div.selector-options div.selector-option[data-disabled]{opacity:.6;cursor:not-allowed}div.selector-element[data-type=find] span.group-text,div.selector-element[data-type=search] span.group-text{top:33px!important}div.selector-element[data-disabled]{opacity:.6;cursor:not-allowed}div.selector-element[data-disabled]:hover{box-shadow:inherit}div.selector-element[data-disabled] div.selector-selected{cursor:not-allowed}div.selector-element[data-disabled] div.selector-selected:hover{background:#fff}",""])},function(e,t){function n(e,t){var n=e[1]||"",o=e[3];if(!o)return n;if(t&&"function"==typeof btoa){var i=r(o);return[n].concat(o.sources.map(function(e){return"/*# sourceURL="+o.sourceRoot+e+" */"})).concat([i]).join("\n")}return[n].join("\n")}function r(e){return"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(e))))+" */"}e.exports=function(e){var t=[];return t.toString=function(){return this.map(function(t){var r=n(t,e);return t[2]?"@media "+t[2]+"{"+r+"}":r}).join("")},t.i=function(e,n){"string"==typeof e&&(e=[[null,e,""]]);for(var r={},o=0;o<this.length;o++){var i=this[o][0];"number"==typeof i&&(r[i]=!0)}for(o=0;o<e.length;o++){var s=e[o];"number"==typeof s[0]&&r[s[0]]||(n&&!s[2]?s[2]=n:n&&(s[2]="("+s[2]+") and ("+n+")"),t.push(s))}},t}},function(e,t){e.exports="\"data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8' standalone='no'?%3E %3Csvg xmlns:dc='http://purl.org/dc/elements/1.1/' xmlns:cc='http://creativecommons.org/ns%23' xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns%23' xmlns:svg='http://www.w3.org/2000/svg' xmlns='http://www.w3.org/2000/svg' xmlns:sodipodi='http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd' xmlns:inkscape='http://www.inkscape.org/namespaces/inkscape' width='24' height='24' viewBox='0 0 24 24' id='svg2' version='1.1' inkscape:version='0.91 r13725' sodipodi:docname='search.svg'%3E %3Cmetadata id='metadata10'%3E %3Crdf:RDF%3E %3Ccc:Work rdf:about=''%3E %3Cdc:format%3Eimage/svg+xml%3C/dc:format%3E %3Cdc:type rdf:resource='http://purl.org/dc/dcmitype/StillImage' /%3E %3C/cc:Work%3E %3C/rdf:RDF%3E %3C/metadata%3E %3Cdefs id='defs8' /%3E %3Csodipodi:namedview pagecolor='%23ffffff' bordercolor='%23666666' borderopacity='1' objecttolerance='10' gridtolerance='10' guidetolerance='10' inkscape:pageopacity='0' inkscape:pageshadow='2' inkscape:window-width='764' inkscape:window-height='480' id='namedview6' showgrid='false' inkscape:zoom='9.8333333' inkscape:cx='12' inkscape:cy='12' inkscape:window-x='59' inkscape:window-y='24' inkscape:window-maximized='0' inkscape:current-layer='svg2' /%3E %3Cpath d='M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z' id='path4' style='fill:%234d4d4d' /%3E %3C/svg%3E\""},function(e,t){e.exports="\"data:image/svg+xml,%3C?xml version='1.0' encoding='UTF-8' standalone='no'?%3E %3Csvg xmlns:dc='http://purl.org/dc/elements/1.1/' xmlns:cc='http://creativecommons.org/ns%23' xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns%23' xmlns:svg='http://www.w3.org/2000/svg' xmlns='http://www.w3.org/2000/svg' xmlns:sodipodi='http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd' xmlns:inkscape='http://www.inkscape.org/namespaces/inkscape' width='24' height='24' viewBox='0 0 24 24' id='svg2' version='1.1' inkscape:version='0.91 r13725' sodipodi:docname='clear.svg'%3E %3Cmetadata id='metadata10'%3E %3Crdf:RDF%3E %3Ccc:Work rdf:about=''%3E %3Cdc:format%3Eimage/svg+xml%3C/dc:format%3E %3Cdc:type rdf:resource='http://purl.org/dc/dcmitype/StillImage' /%3E %3C/cc:Work%3E %3C/rdf:RDF%3E %3C/metadata%3E %3Cdefs id='defs8' /%3E %3Csodipodi:namedview pagecolor='%23ffffff' bordercolor='%23666666' borderopacity='1' objecttolerance='10' gridtolerance='10' guidetolerance='10' inkscape:pageopacity='0' inkscape:pageshadow='2' inkscape:window-width='764' inkscape:window-height='480' id='namedview6' showgrid='false' inkscape:zoom='9.8333333' inkscape:cx='12' inkscape:cy='12' inkscape:window-x='59' inkscape:window-y='24' inkscape:window-maximized='0' inkscape:current-layer='svg2' /%3E %3Cpath d='M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z' id='path4' style='fill:%234d4d4d' /%3E %3C/svg%3E\""},function(e,t,n){function r(e,t){for(var n=0;n<e.length;n++){var r=e[n],o=h[r.id];if(o){o.refs++;for(var i=0;i<o.parts.length;i++)o.parts[i](r.parts[i]);for(;i<r.parts.length;i++)o.parts.push(c(r.parts[i],t))}else{for(var s=[],i=0;i<r.parts.length;i++)s.push(c(r.parts[i],t));h[r.id]={id:r.id,refs:1,parts:s}}}}function o(e,t){for(var n=[],r={},o=0;o<e.length;o++){var i=e[o],s=t.base?i[0]+t.base:i[0],a=i[1],l=i[2],d=i[3],c={css:a,media:l,sourceMap:d};r[s]?r[s].parts.push(c):n.push(r[s]={id:s,parts:[c]})}return n}function i(e,t){var n=m(e.insertInto);if(!n)throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");var r=y[y.length-1];if("top"===e.insertAt)r?r.nextSibling?n.insertBefore(t,r.nextSibling):n.appendChild(t):n.insertBefore(t,n.firstChild),y.push(t);else{if("bottom"!==e.insertAt)throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");n.appendChild(t)}}function s(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e);var t=y.indexOf(e);t>=0&&y.splice(t,1)}function a(e){var t=document.createElement("style");return e.attrs.type="text/css",d(t,e.attrs),i(e,t),t}function l(e){var t=document.createElement("link");return e.attrs.type="text/css",e.attrs.rel="stylesheet",d(t,e.attrs),i(e,t),t}function d(e,t){Object.keys(t).forEach(function(n){e.setAttribute(n,t[n])})}function c(e,t){var n,r,o,i;if(t.transform&&e.css){if(!(i=t.transform(e.css)))return function(){};e.css=i}if(t.singleton){var d=g++;n=b||(b=a(t)),r=p.bind(null,n,d,!1),o=p.bind(null,n,d,!0)}else e.sourceMap&&"function"==typeof URL&&"function"==typeof URL.createObjectURL&&"function"==typeof URL.revokeObjectURL&&"function"==typeof Blob&&"function"==typeof btoa?(n=l(t),r=f.bind(null,n,t),o=function(){s(n),n.href&&URL.revokeObjectURL(n.href)}):(n=a(t),r=u.bind(null,n),o=function(){s(n)});return r(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap)return;r(e=t)}else o()}}function p(e,t,n,r){var o=n?"":r.css;if(e.styleSheet)e.styleSheet.cssText=w(t,o);else{var i=document.createTextNode(o),s=e.childNodes;s[t]&&e.removeChild(s[t]),s.length?e.insertBefore(i,s[t]):e.appendChild(i)}}function u(e,t){var n=t.css,r=t.media;if(r&&e.setAttribute("media",r),e.styleSheet)e.styleSheet.cssText=n;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(n))}}function f(e,t,n){var r=n.css,o=n.sourceMap,i=void 0===t.convertToAbsoluteUrls&&o;(t.convertToAbsoluteUrls||i)&&(r=x(r)),o&&(r+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(o))))+" */");var s=new Blob([r],{type:"text/css"}),a=e.href;e.href=URL.createObjectURL(s),a&&URL.revokeObjectURL(a)}var h={},v=function(e){var t;return function(){return void 0===t&&(t=e.apply(this,arguments)),t}}(function(){return window&&document&&document.all&&!window.atob}),m=function(e){var t={};return function(n){return void 0===t[n]&&(t[n]=e.call(this,n)),t[n]}}(function(e){return document.querySelector(e)}),b=null,g=0,y=[],x=n(13);e.exports=function(e,t){if("undefined"!=typeof DEBUG&&DEBUG&&"object"!=typeof document)throw new Error("The style-loader cannot be used in a non-browser environment");t=t||{},t.attrs="object"==typeof t.attrs?t.attrs:{},t.singleton||(t.singleton=v()),t.insertInto||(t.insertInto="head"),t.insertAt||(t.insertAt="bottom");var n=o(e,t);return r(n,t),function(e){for(var i=[],s=0;s<n.length;s++){var a=n[s],l=h[a.id];l.refs--,i.push(l)}e&&r(o(e,t),t);for(var s=0;s<i.length;s++){var l=i[s];if(0===l.refs){for(var d=0;d<l.parts.length;d++)l.parts[d]();delete h[l.id]}}}};var w=function(){var e=[];return function(t,n){return e[t]=n,e.filter(Boolean).join("\n")}}()},function(e,t){e.exports=function(e){var t="undefined"!=typeof window&&window.location;if(!t)throw new Error("fixUrls requires window.location");if(!e||"string"!=typeof e)return e;var n=t.protocol+"//"+t.host,r=n+t.pathname.replace(/\/[^\/]*$/,"/");return e.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi,function(e,t){var o=t.trim().replace(/^"(.*)"$/,function(e,t){return t}).replace(/^'(.*)'$/,function(e,t){return t});if(/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(o))return e;var i;return i=0===o.indexOf("//")?o:0===o.indexOf("/")?n+o:r+o.replace(/^\.\//,""),"url("+JSON.stringify(i)+")"})}},function(e,t,n){"use strict";n(3),n(6)}]);

/***/ })
/******/ ]);